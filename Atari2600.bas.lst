------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\Atari-2600-Game\Atari2600.bas.asm LEVEL 1 PASS 3
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????				       processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????						; VCS.H
      4  10000 ????						; Version 1.05, 13/November/2003
      5  10000 ????
      6  10000 ????		00 69	    VERSION_VCS =	105
      7  10000 ????
      8  10000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  10000 ????						;
     12  10000 ????						; This file defines hardware registers and memory mapping for the
     13  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  10000 ????						; available at at http://www.atari2600.org/dasm
     16  10000 ????						;
     17  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  10000 ????						; with your views.  Please contribute, if you think you can improve this
     21  10000 ????						; file!
     22  10000 ????						;
     23  10000 ????						; Latest Revisions...
     24  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  10000 ????						;			    This will allow conditional code to verify VCS.H being
     27  10000 ????						;			    used for code assembly.
     28  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  10000 ????						;			 readability issue, and binary compatibility with disassembled
     32  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  10000 ????						;			 which was broken by the use of segments in this file, as
     35  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  10000 ????						;						   it is safe to leave it undefined, and the base address will
     40  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  10000 ????						;			  - register definitions are now generated through assignment
     43  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  10000 ????						;			    address architecture.
     45  10000 ????						; 1.0	22/MAR/2003		Initial release
     46  10000 ????
     47  10000 ????
     48  10000 ????						;-------------------------------------------------------------------------------
     49  10000 ????
     50  10000 ????						; TIA_BASE_ADDRESS
     51  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  10000 ????						; Normally 0, the base address should (externally, before including this file)
     53  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  10000 ????						; < $40 as a bankswitch.
     56  10000 ????
     57  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     58  10000 ????			   -TIA_BASE_ADDRESS =	0
     59  10000 ????				       ENDIF
     60  10000 ????
     61  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  10000 ????						; *OR* by declaring the label before including this file, eg:
     64  10000 ????						; TIA_BASE_ADDRESS = $40
     65  10000 ????						;   include "vcs.h"
     66  10000 ????
     67  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  10000 ????						; for the mirrored ROM hardware registers.
     70  10000 ????
     71  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  10000 ????
     75  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     76  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  10000 ????				       ENDIF
     78  10000 ????
     79  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  10000 ????				       ENDIF
     82  10000 ????
     83  10000 ????						;-------------------------------------------------------------------------------
     84  10000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  10000 ????				       SEG
    201  10000 ????
    202  10000 ????						; EOF
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\Atari-2600-Game\Atari2600.bas.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  10000 ????				       include	"macro.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????						; MACRO.H
      4  10000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  10000 ????
      6  10000 ????		00 69	    VERSION_MACRO =	105
      7  10000 ????
      8  10000 ????						;
      9  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  10000 ????						;
     12  10000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  10000 ????						; It is distributed as a companion machine-specific support package
     14  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  10000 ????						; available at at http://www.atari2600.org/dasm
     16  10000 ????						;
     17  10000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  10000 ????						; contents, or would like to add something, please write to me
     19  10000 ????						; (atari2600@taswegian.com) with your contribution.
     20  10000 ????						;
     21  10000 ????						; Latest Revisions...
     22  10000 ????						;
     23  10000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  10000 ????						;
     28  10000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  10000 ????						;
     30  10000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  10000 ????						;			   (standardised macro for vertical synch code)
     32  10000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  10000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  10000 ????						; 1.0	22/MAR/2003		Initial release
     35  10000 ????
     36  10000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  10000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  10000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  10000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  10000 ????						;   registers and require them to be defined first).
     41  10000 ????
     42  10000 ????						; Available macros...
     43  10000 ????						;   SLEEP n		 - sleep for n cycles
     44  10000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  10000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  10000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  10000 ????
     48  10000 ????						;-------------------------------------------------------------------------------
     49  10000 ????						; SLEEP duration
     50  10000 ????						; Original author: Thomas Jentzsch
     51  10000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  10000 ????						; useful for code where precise timing is required.
     53  10000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  10000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  10000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  10000 ????
     57  10000 ????				       MAC	sleep
     58  10000 ????			    .CYCLES    SET	{1}
     59  10000 ????
     60  10000 ????				       IF	.CYCLES < 2
     61  10000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  10000 ????				       ERR
     63  10000 ????				       ENDIF
     64  10000 ????
     65  10000 ????				       IF	.CYCLES & 1
     66  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     67  10000 ????				       nop	0
     68  10000 ????				       ELSE
     69  10000 ????				       bit	VSYNC
     70  10000 ????				       ENDIF
     71  10000 ????			    .CYCLES    SET	.CYCLES - 3
     72  10000 ????				       ENDIF
     73  10000 ????
     74  10000 ????				       REPEAT	.CYCLES / 2
     75  10000 ????				       nop
     76  10000 ????				       REPEND
     77  10000 ????				       ENDM		;usage: SLEEP n (n>1)
     78  10000 ????
     79  10000 ????						;-------------------------------------------------------------------------------
     80  10000 ????						; VERTICAL_SYNC
     81  10000 ????						; Original author: Manuel Polik
     82  10000 ????						; Inserts the code required for a proper 3 scannline 
     83  10000 ????						; vertical sync sequence
     84  10000 ????						;
     85  10000 ????						; Note: Alters the accumulator
     86  10000 ????						;
     87  10000 ????						; IN:
     88  10000 ????						; OUT: A = 1
     89  10000 ????
     90  10000 ????				       MAC	vertical_sync
     91  10000 ????				       LDA	#$02	; A = VSYNC enable
     92  10000 ????				       STA	WSYNC	; Finish current line
     93  10000 ????				       STA	VSYNC	; Start vertical sync
     94  10000 ????				       STA	WSYNC	; 1st line vertical sync
     95  10000 ????				       STA	WSYNC	; 2nd line vertical sync
     96  10000 ????				       LSR		; A = VSYNC disable
     97  10000 ????				       STA	WSYNC	; 3rd line vertical sync
     98  10000 ????				       STA	VSYNC	; Stop vertical sync
     99  10000 ????				       ENDM
    100  10000 ????
    101  10000 ????						;-------------------------------------------------------------------------------
    102  10000 ????						; CLEAN_START
    103  10000 ????						; Original author: Andrew Davie
    104  10000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  10000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  10000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  10000 ????						; Use as very first section of code on boot (ie: at reset)
    108  10000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  10000 ????
    110  10000 ????				       MAC	clean_start
    111  10000 ????				       sei
    112  10000 ????				       cld
    113  10000 ????
    114  10000 ????				       ldx	#0
    115  10000 ????				       txa
    116  10000 ????				       tay
    117  10000 ????			    .CLEAR_STACK dex
    118  10000 ????				       txs
    119  10000 ????				       pha
    120  10000 ????				       bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  10000 ????
    122  10000 ????				       ENDM
    123  10000 ????
    124  10000 ????						;-------------------------------------------------------
    125  10000 ????						; SET_POINTER
    126  10000 ????						; Original author: Manuel Rotschkar
    127  10000 ????						;
    128  10000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  10000 ????						;
    130  10000 ????						; Usage: SET_POINTER pointer, address
    131  10000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  10000 ????						;
    133  10000 ????						; Note: Alters the accumulator, NZ flags
    134  10000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  10000 ????						; IN 2: absolute address
    136  10000 ????
    137  10000 ????				       MAC	set_pointer
    138  10000 ????			    .POINTER   SET	{1}
    139  10000 ????			    .ADDRESS   SET	{2}
    140  10000 ????
    141  10000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  10000 ????				       STA	.POINTER	; Store in pointer
    143  10000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    144  10000 ????				       STA	.POINTER+1	; Store in pointer+1
    145  10000 ????
    146  10000 ????				       ENDM
    147  10000 ????
    148  10000 ????						; EOF
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\Atari-2600-Game\Atari2600.bas.asm
------- FILE 2600basic.h LEVEL 2 PASS 3
      0  10000 ????				       include	"2600basic.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????				       processor	6502
------- FILE vcs.h LEVEL 3 PASS 3
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????						; VCS.H
      4  10000 ????						; Version 1.05, 13/November/2003
      5  10000 ????
      6  10000 ????		00 69	    VERSION_VCS =	105
      7  10000 ????
      8  10000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  10000 ????						;
     12  10000 ????						; This file defines hardware registers and memory mapping for the
     13  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  10000 ????						; available at at http://www.atari2600.org/dasm
     16  10000 ????						;
     17  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  10000 ????						; with your views.  Please contribute, if you think you can improve this
     21  10000 ????						; file!
     22  10000 ????						;
     23  10000 ????						; Latest Revisions...
     24  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  10000 ????						;			    This will allow conditional code to verify VCS.H being
     27  10000 ????						;			    used for code assembly.
     28  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  10000 ????						;			 readability issue, and binary compatibility with disassembled
     32  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  10000 ????						;			 which was broken by the use of segments in this file, as
     35  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  10000 ????						;						   it is safe to leave it undefined, and the base address will
     40  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  10000 ????						;			  - register definitions are now generated through assignment
     43  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  10000 ????						;			    address architecture.
     45  10000 ????						; 1.0	22/MAR/2003		Initial release
     46  10000 ????
     47  10000 ????
     48  10000 ????						;-------------------------------------------------------------------------------
     49  10000 ????
     50  10000 ????						; TIA_BASE_ADDRESS
     51  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  10000 ????						; Normally 0, the base address should (externally, before including this file)
     53  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  10000 ????						; < $40 as a bankswitch.
     56  10000 ????
     57  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     58  10000 ????			   -TIA_BASE_ADDRESS =	0
     59  10000 ????				       ENDIF
     60  10000 ????
     61  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  10000 ????						; *OR* by declaring the label before including this file, eg:
     64  10000 ????						; TIA_BASE_ADDRESS = $40
     65  10000 ????						;   include "vcs.h"
     66  10000 ????
     67  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  10000 ????						; for the mirrored ROM hardware registers.
     70  10000 ????
     71  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  10000 ????
     75  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     76  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  10000 ????				       ENDIF
     78  10000 ????
     79  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  10000 ????				       ENDIF
     82  10000 ????
     83  10000 ????						;-------------------------------------------------------------------------------
     84  10000 ????
     85 U002d					      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e					      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298					      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  10000 ????				       SEG
    201  10000 ????
    202  10000 ????						; EOF
------- FILE 2600basic.h
------- FILE macro.h LEVEL 3 PASS 3
      0  10000 ????				       include	"macro.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????						; MACRO.H
      4  10000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  10000 ????
      6  10000 ????		00 69	    VERSION_MACRO =	105
      7  10000 ????
      8  10000 ????						;
      9  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  10000 ????						;
     12  10000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  10000 ????						; It is distributed as a companion machine-specific support package
     14  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  10000 ????						; available at at http://www.atari2600.org/dasm
     16  10000 ????						;
     17  10000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  10000 ????						; contents, or would like to add something, please write to me
     19  10000 ????						; (atari2600@taswegian.com) with your contribution.
     20  10000 ????						;
     21  10000 ????						; Latest Revisions...
     22  10000 ????						;
     23  10000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  10000 ????						;
     28  10000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  10000 ????						;
     30  10000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  10000 ????						;			   (standardised macro for vertical synch code)
     32  10000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  10000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  10000 ????						; 1.0	22/MAR/2003		Initial release
     35  10000 ????
     36  10000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  10000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  10000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  10000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  10000 ????						;   registers and require them to be defined first).
     41  10000 ????
     42  10000 ????						; Available macros...
     43  10000 ????						;   SLEEP n		 - sleep for n cycles
     44  10000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  10000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  10000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  10000 ????
     48  10000 ????						;-------------------------------------------------------------------------------
     49  10000 ????						; SLEEP duration
     50  10000 ????						; Original author: Thomas Jentzsch
     51  10000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  10000 ????						; useful for code where precise timing is required.
     53  10000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  10000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  10000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  10000 ????
     57  10000 ????				       MAC	sleep
     58  10000 ????			    .CYCLES    SET	{1}
     59  10000 ????
     60  10000 ????				       IF	.CYCLES < 2
     61  10000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  10000 ????				       ERR
     63  10000 ????				       ENDIF
     64  10000 ????
     65  10000 ????				       IF	.CYCLES & 1
     66  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     67  10000 ????				       nop	0
     68  10000 ????				       ELSE
     69  10000 ????				       bit	VSYNC
     70  10000 ????				       ENDIF
     71  10000 ????			    .CYCLES    SET	.CYCLES - 3
     72  10000 ????				       ENDIF
     73  10000 ????
     74  10000 ????				       REPEAT	.CYCLES / 2
     75  10000 ????				       nop
     76  10000 ????				       REPEND
     77  10000 ????				       ENDM		;usage: SLEEP n (n>1)
     78  10000 ????
     79  10000 ????						;-------------------------------------------------------------------------------
     80  10000 ????						; VERTICAL_SYNC
     81  10000 ????						; Original author: Manuel Polik
     82  10000 ????						; Inserts the code required for a proper 3 scannline 
     83  10000 ????						; vertical sync sequence
     84  10000 ????						;
     85  10000 ????						; Note: Alters the accumulator
     86  10000 ????						;
     87  10000 ????						; IN:
     88  10000 ????						; OUT: A = 1
     89  10000 ????
     90  10000 ????				       MAC	vertical_sync
     91  10000 ????				       LDA	#$02	; A = VSYNC enable
     92  10000 ????				       STA	WSYNC	; Finish current line
     93  10000 ????				       STA	VSYNC	; Start vertical sync
     94  10000 ????				       STA	WSYNC	; 1st line vertical sync
     95  10000 ????				       STA	WSYNC	; 2nd line vertical sync
     96  10000 ????				       LSR		; A = VSYNC disable
     97  10000 ????				       STA	WSYNC	; 3rd line vertical sync
     98  10000 ????				       STA	VSYNC	; Stop vertical sync
     99  10000 ????				       ENDM
    100  10000 ????
    101  10000 ????						;-------------------------------------------------------------------------------
    102  10000 ????						; CLEAN_START
    103  10000 ????						; Original author: Andrew Davie
    104  10000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  10000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  10000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  10000 ????						; Use as very first section of code on boot (ie: at reset)
    108  10000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  10000 ????
    110  10000 ????				       MAC	clean_start
    111  10000 ????				       sei
    112  10000 ????				       cld
    113  10000 ????
    114  10000 ????				       ldx	#0
    115  10000 ????				       txa
    116  10000 ????				       tay
    117  10000 ????			    .CLEAR_STACK dex
    118  10000 ????				       txs
    119  10000 ????				       pha
    120  10000 ????				       bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  10000 ????
    122  10000 ????				       ENDM
    123  10000 ????
    124  10000 ????						;-------------------------------------------------------
    125  10000 ????						; SET_POINTER
    126  10000 ????						; Original author: Manuel Rotschkar
    127  10000 ????						;
    128  10000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  10000 ????						;
    130  10000 ????						; Usage: SET_POINTER pointer, address
    131  10000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  10000 ????						;
    133  10000 ????						; Note: Alters the accumulator, NZ flags
    134  10000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  10000 ????						; IN 2: absolute address
    136  10000 ????
    137  10000 ????				       MAC	set_pointer
    138  10000 ????			    .POINTER   SET	{1}
    139  10000 ????			    .ADDRESS   SET	{2}
    140  10000 ????
    141  10000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  10000 ????				       STA	.POINTER	; Store in pointer
    143  10000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    144  10000 ????				       STA	.POINTER+1	; Store in pointer+1
    145  10000 ????
    146  10000 ????				       ENDM
    147  10000 ????
    148  10000 ????						; EOF
------- FILE 2600basic.h
      6  10000 ????				       include	"2600basic_variable_redefs.h"
      7  10000 ????
      8  10000 ????		00 80	    player0x   =	$80
      9  10000 ????		00 81	    player1x   =	$81
     10  10000 ????		00 82	    missile0x  =	$82
     11  10000 ????		00 83	    missile1x  =	$83
     12  10000 ????		00 84	    ballx      =	$84
     13  10000 ????
     14  10000 ????		00 85	    objecty    =	$85
     15  10000 ????		00 85	    player0y   =	$85
     16  10000 ????		00 86	    player1y   =	$86
     17  10000 ????		00 87	    missile1height =	$87
     18  10000 ????		00 88	    missile1y  =	$88
     19  10000 ????		00 89	    bally      =	$89
     20  10000 ????
     21  10000 ????		00 87	    player1color =	$87	; replaces missile 1
     22  10000 ????
     23  10000 ????		00 8a	    player0pointer =	$8A	;uses $8A-$8B
     24  10000 ????		00 8a	    player0pointerlo =	$8A
     25  10000 ????		00 8b	    player0pointerhi =	$8B
     26  10000 ????		00 8c	    player1pointer =	$8C	; $8C-$8D
     27  10000 ????		00 8c	    player1pointerlo =	$8C
     28  10000 ????		00 8d	    player1pointerhi =	$8D
     29  10000 ????
     30  10000 ????		00 8e	    player0height =	$8E
     31  10000 ????		00 8f	    player1height =	$8F
     32  10000 ????		00 90	    missile0height =	$90
     33  10000 ????		00 91	    missile0y  =	$91
     34  10000 ????		00 92	    ballheight =	$92
     35  10000 ????
     36  10000 ????		00 90	    currentpaddle =	$90	; replaces missile 0 (and can't be used with playercolor)
     37  10000 ????		00 91	    paddle     =	$91	; replaces missile 0
     38  10000 ????		00 82	    player0colorstore =	$82	; replaces missile 0
     39  10000 ????		00 90	    player0color =	$90	; replaces missile 0
     40  10000 ????
     41  10000 ????		00 93	    score      =	$93	; $93-$95
     42  10000 ????		00 96	    scorepointers =	$96	; $96-$9B = 6 bytes
     43  10000 ????		00 9c	    temp1      =	$9C	;used by kernel.  can be used in program too, but
     44  10000 ????		00 9d	    temp2      =	$9D	;are obliterated when drawscreen is called.
     45  10000 ????		00 9e	    temp3      =	$9E
     46  10000 ????		00 9f	    temp4      =	$9F
     47  10000 ????		00 a0	    temp5      =	$A0
     48  10000 ????		00 a1	    temp6      =	$A1
     49  10000 ????
     50  10000 ????		00 a2	    rand       =	$A2
     51  10000 ????		00 a3	    scorecolor =	$A3
     52  10000 ????
     53  10000 ????		00 a4	    var0       =	$A4
     54  10000 ????		00 a5	    var1       =	$A5
     55  10000 ????		00 a6	    var2       =	$A6
     56  10000 ????		00 a7	    var3       =	$A7
     57  10000 ????		00 a8	    var4       =	$A8
     58  10000 ????		00 a9	    var5       =	$A9
     59  10000 ????		00 aa	    var6       =	$AA
     60  10000 ????		00 ab	    var7       =	$AB
     61  10000 ????		00 ac	    var8       =	$AC
     62  10000 ????		00 ad	    var9       =	$AD
     63  10000 ????		00 ae	    var10      =	$AE
     64  10000 ????		00 af	    var11      =	$AF
     65  10000 ????		00 b0	    var12      =	$B0
     66  10000 ????		00 b1	    var13      =	$B1
     67  10000 ????		00 b2	    var14      =	$B2
     68  10000 ????		00 b3	    var15      =	$B3
     69  10000 ????		00 b4	    var16      =	$B4
     70  10000 ????		00 b5	    var17      =	$B5
     71  10000 ????		00 b6	    var18      =	$B6
     72  10000 ????		00 b7	    var19      =	$B7
     73  10000 ????		00 b8	    var20      =	$B8
     74  10000 ????		00 b9	    var21      =	$B9
     75  10000 ????		00 ba	    var22      =	$BA
     76  10000 ????		00 bb	    var23      =	$BB
     77  10000 ????		00 bc	    var24      =	$BC
     78  10000 ????		00 bd	    var25      =	$BD
     79  10000 ????		00 be	    var26      =	$BE
     80  10000 ????		00 bf	    var27      =	$BF
     81  10000 ????		00 c0	    var28      =	$C0
     82  10000 ????		00 c1	    var29      =	$C1
     83  10000 ????		00 c2	    var30      =	$C2
     84  10000 ????		00 c3	    var31      =	$C3
     85  10000 ????		00 c4	    var32      =	$C4
     86  10000 ????		00 c5	    var33      =	$C5
     87  10000 ????		00 c6	    var34      =	$C6
     88  10000 ????		00 c7	    var35      =	$C7
     89  10000 ????		00 c8	    var36      =	$C8
     90  10000 ????		00 c9	    var37      =	$C9
     91  10000 ????		00 ca	    var38      =	$CA
     92  10000 ????		00 cb	    var39      =	$CB
     93  10000 ????		00 cc	    var40      =	$CC
     94  10000 ????		00 cd	    var41      =	$CD
     95  10000 ????		00 ce	    var42      =	$CE
     96  10000 ????		00 cf	    var43      =	$CF
     97  10000 ????		00 d0	    var44      =	$D0
     98  10000 ????		00 d1	    var45      =	$D1
     99  10000 ????		00 d2	    var46      =	$D2
    100  10000 ????		00 d3	    var47      =	$D3
    101  10000 ????
    102  10000 ????		00 d4	    A	       =	$d4
    103  10000 ????		00 d4	    a	       =	$d4
    104  10000 ????		00 d5	    B	       =	$d5
    105  10000 ????		00 d5	    b	       =	$d5
    106  10000 ????		00 d6	    C	       =	$d6
    107  10000 ????		00 d6	    c	       =	$d6
    108  10000 ????		00 d7	    D	       =	$d7
    109  10000 ????		00 d7	    d	       =	$d7
    110  10000 ????		00 d8	    E	       =	$d8
    111  10000 ????		00 d8	    e	       =	$d8
    112  10000 ????		00 d9	    F	       =	$d9
    113  10000 ????		00 d9	    f	       =	$d9
    114  10000 ????		00 da	    G	       =	$da
    115  10000 ????		00 da	    g	       =	$da
    116  10000 ????		00 db	    H	       =	$db
    117  10000 ????		00 db	    h	       =	$db
    118  10000 ????		00 dc	    I	       =	$dc
    119  10000 ????		00 dc	    i	       =	$dc
    120  10000 ????		00 dd	    J	       =	$dd
    121  10000 ????		00 dd	    j	       =	$dd
    122  10000 ????		00 de	    K	       =	$de
    123  10000 ????		00 de	    k	       =	$de
    124  10000 ????		00 df	    L	       =	$df
    125  10000 ????		00 df	    l	       =	$df
    126  10000 ????		00 e0	    M	       =	$e0
    127  10000 ????		00 e0	    m	       =	$e0
    128  10000 ????		00 e1	    N	       =	$e1
    129  10000 ????		00 e1	    n	       =	$e1
    130  10000 ????		00 e2	    O	       =	$e2
    131  10000 ????		00 e2	    o	       =	$e2
    132  10000 ????		00 e3	    P	       =	$e3
    133  10000 ????		00 e3	    p	       =	$e3
    134  10000 ????		00 e4	    Q	       =	$e4
    135  10000 ????		00 e4	    q	       =	$e4
    136  10000 ????		00 e5	    R	       =	$e5
    137  10000 ????		00 e5	    r	       =	$e5
    138  10000 ????		00 e6	    S	       =	$e6
    139  10000 ????		00 e6	    s	       =	$e6
    140  10000 ????		00 e7	    T	       =	$e7
    141  10000 ????		00 e7	    t	       =	$e7
    142  10000 ????		00 e8	    U	       =	$e8
    143  10000 ????		00 e8	    u	       =	$e8
    144  10000 ????		00 e9	    V	       =	$e9
    145  10000 ????		00 e9	    v	       =	$e9
    146  10000 ????		00 ea	    W	       =	$ea
    147  10000 ????		00 ea	    w	       =	$ea
    148  10000 ????		00 eb	    X	       =	$eb
    149  10000 ????		00 eb	    x	       =	$eb
    150  10000 ????		00 ec	    Y	       =	$ec
    151  10000 ????		00 ec	    y	       =	$ec
    152  10000 ????		00 ed	    Z	       =	$ed
    153  10000 ????		00 ed	    z	       =	$ed
    154  10000 ????
    155  10000 ????		00 ee	    temp7      =	$ee	; This is used to aid in bankswitching
    156  10000 ????		00 ef	    playfieldpos =	$ef
    157  10000 ????
    158  10000 ????						; available for other uses, or if unused, provide more stack space
    159  10000 ????
    160  10000 ????		00 f0	    aux1       =	$f0
    161  10000 ????		00 f1	    aux2       =	$f1
    162  10000 ????		00 f2	    aux3       =	$f2
    163  10000 ????		00 f3	    aux4       =	$f3
    164  10000 ????		00 f4	    aux5       =	$f4
    165  10000 ????		00 f5	    aux6       =	$f5
    166  10000 ????
    167  10000 ????						; playfield color/height pointers
    168  10000 ????		00 f0	    pfcolortable =	$f0	; and $d5
    169  10000 ????		00 f0	    pfheighttable =	$f0	; and $d5
    170  10000 ????						; the above pointers are the same because if color and height are both used together,
    171  10000 ????						; they must used absolute indexed and cannot use pointers
    172  10000 ????
    173  10000 ????		00 f2	    lifepointer =	$f2	; pointer to "lives" shape
    174  10000 ????						; upper 3 bits of $f2 contain the number of lives
    175  10000 ????		00 f4	    lifecolor  =	$f4
    176  10000 ????		00 f3	    lives      =	$f3	; # lives >> 5
    177  10000 ????		00 f5	    statusbarlength =	$f5	; only uses upper 5 bits; other bits free
    178  10000 ????
    179  10000 ????		00 f2	    pfscore1   =	$f2	; optional playfield bytes in score
    180  10000 ????		00 f3	    pfscore2   =	$f3
    181  10000 ????		00 f4	    pfscorecolor =	$f4
    182  10000 ????
    183  10000 ????		00 f6	    stack1     =	$f6
    184  10000 ????		00 f7	    stack2     =	$f7
    185  10000 ????		00 f8	    stack3     =	$f8
    186  10000 ????		00 f9	    stack4     =	$f9
    187  10000 ????						; the stack bytes above may be used in the kernel
    188  10000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    189  10000 ????
    190  10000 ????				       MAC	return
    191  10000 ????				       ifnconst	bankswitch
    192  10000 ????				       rts
    193  10000 ????				       else
    194  10000 ????				       jmp	BS_return
    195  10000 ????				       endif
    196  10000 ????				       ENDM		; auto-return from either a regular or bankswitched module
    197  10000 ????
    198  10000 ????			   -	       ifconst	superchip
    199  10000 ????			   -playfieldbase =	$10D0
    200  10000 ????			   -	       include	superchip.h
    201  10000 ????				       else
    202  10000 ????		00 a4	    playfieldbase =	$A4
    203  10000 ????				       endif
    204  10000 ????
    205  10000 ????				       ifnconst	pfhalfwidth
    206  10000 ????		00 04	    pfwidth    =	4
    207  10000 ????		00 0e	    PF1L       =	PF1
    208  10000 ????		00 0f	    PF2L       =	PF2
    209  10000 ????		00 0e	    PF1R       =	PF1
    210  10000 ????		00 0f	    PF2R       =	PF2
    211  10000 ????		00 00	    pfadjust   =	0
    212  10000 ????			   -	       else
    213  10000 ????			   -pfwidth    =	2
    214  10000 ????			   -	       ifconst	pfcenter
    215  10000 ????			   -PF1L       =	$3F	; no effect
    216  10000 ????			   -PF2L       =	PF2
    217  10000 ????			   -PF1R       =	$3F
    218  10000 ????			   -PF2R       =	PF2	; no effect
    219  10000 ????			   -pfadjust   =	1
    220  10000 ????			   -	       else
    221  10000 ????			   -PF1L       =	PF1
    222  10000 ????			   -PF2L       =	PF2
    223  10000 ????			   -PF1R       =	$3F	; no effect
    224  10000 ????			   -PF2R       =	$3F	; no effect
    225  10000 ????			   -pfadjust   =	0
    226  10000 ????			   -	       endif
    227  10000 ????				       endif
    228  10000 ????
    229  10000 ????						; define playfield start based on height
    230  10000 ????				       ifnconst	pfres
    231  10000 ????		00 a4	    playfield  =	playfieldbase
    232  10000 ????			   -	       else
    233  10000 ????			   -playfield  =	playfieldbase-(pfres-12*(4/pfwidth))*pfwidth
    234  10000 ????				       endif
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\Atari-2600-Game\Atari2600.bas.asm
      7  10000 ????				       include	"2600basic_variable_redefs.h"
      8  10000 ????			   -	       ifconst	bankswitch
      9  10000 ????			   -	       if	bankswitch == 8
     10  10000 ????			   -	       ORG	$1000
     11  10000 ????			   -	       RORG	$D000
     12  10000 ????			   -	       endif
     13  10000 ????			   -	       if	bankswitch == 16
     14  10000 ????			   -	       ORG	$1000
     15  10000 ????			   -	       RORG	$9000
     16  10000 ????			   -	       endif
     17  10000 ????			   -	       if	bankswitch == 32
     18  10000 ????			   -	       ORG	$1000
     19  10000 ????			   -	       RORG	$1000
     20  10000 ????			   -	       endif
     21  10000 ????			   -	       if	bankswitch == 64
     22  10000 ????			   -	       ORG	$1000
     23  10000 ????			   -	       RORG	$1000
     24  10000 ????			   -	       endif
     25  10000 ????				       else
     26  f000					      ORG	$F000
     27  f000					      endif
     28  f000
     29  f000				  -	      ifconst	bankswitch_hotspot
     30  f000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  f000				  -	      .byte	0	; stop unexpected bankswitches
     32  f000				  -	      endif
     33  f000					      endif
     34  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
     35  f000
     36  f000							; This is a 2-line kernel!
     37  f000					      ifnconst	vertical_reflect
     38  f000				   kernel
     39  f000					      endif
     40  f000		       85 02		      sta	WSYNC
     41  f002		       a9 ff		      lda	#255
     42  f004		       8d 96 02 	      sta	TIM64T
     43  f007
     44  f007		       a9 01		      lda	#1
     45  f009		       85 27		      sta	VDELBL
     46  f00b		       85 25		      sta	VDELP0
     47  f00d		       a6 92		      ldx	ballheight
     48  f00f		       e8		      inx
     49  f010		       e8		      inx
     50  f011		       86 9f		      stx	temp4
     51  f013		       a5 86		      lda	player1y
     52  f015		       85 9e		      sta	temp3
     53  f017
     54  f017				  -	      ifconst	shakescreen
     55  f017				  -	      jsr	doshakescreen
     56  f017					      else
     57  f017		       a6 90		      ldx	missile0height
     58  f019		       e8		      inx
     59  f01a					      endif
     60  f01a
     61  f01a		       e8		      inx
     62  f01b		       86 f6		      stx	stack1
     63  f01d
     64  f01d		       a5 89		      lda	bally
     65  f01f		       85 f7		      sta	stack2
     66  f021
     67  f021		       a5 85		      lda	player0y
     68  f023		       a2 00		      ldx	#0
     69  f025		       85 02		      sta	WSYNC
     70  f027		       86 1b		      stx	GRP0
     71  f029		       86 1c		      stx	GRP1
     72  f02b		       86 0e		      stx	PF1L
     73  f02d		       86 0f		      stx	PF2
     74  f02f		       86 2c		      stx	CXCLR
     75  f031				  -	      ifconst	readpaddle
     76  f031				  -	      stx	paddle
     77  f031					      else
      0  f031					      sleep	3
      1  f031				   .CYCLES    SET	3
      2  f031
      3  f031				  -	      IF	.CYCLES < 2
      4  f031				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f031				  -	      ERR
      6  f031					      ENDIF
      7  f031
      8  f031					      IF	.CYCLES & 1
      9  f031					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f031		       04 00		      nop	0
     11  f033				  -	      ELSE
     12  f033				  -	      bit	VSYNC
     13  f033					      ENDIF
     14  f033				   .CYCLES    SET	.CYCLES - 3
     15  f033					      ENDIF
     16  f033
     17  f033				  -	      REPEAT	.CYCLES / 2
     18  f033				  -	      nop
     19  f033					      REPEND
     79  f033					      endif
     80  f033
     81  f033		       95 9d		      sta	temp2,x
     82  f035
     83  f035							;store these so they can be retrieved later
     84  f035					      ifnconst	pfres
     85  f035		       a2 54		      ldx	#128-44+(4-pfwidth)*12
     86  f037				  -	      else
     87  f037				  -	      ldx	#132-pfres*pfwidth
     88  f037					      endif
     89  f037
     90  f037		       c6 85		      dec	player0y
     91  f039
     92  f039		       a5 91		      lda	missile0y
     93  f03b		       85 a0		      sta	temp5
     94  f03d		       a5 88		      lda	missile1y
     95  f03f		       85 a1		      sta	temp6
     96  f041
     97  f041		       a5 ef		      lda	playfieldpos
     98  f043		       85 9c		      sta	temp1
     99  f045
    100  f045				  -	      ifconst	pfrowheight
    101  f045				  -	      lda	#pfrowheight+2
    102  f045					      else
    103  f045					      ifnconst	pfres
    104  f045		       a9 0a		      lda	#10
    105  f047				  -	      else
    106  f047				  -	      lda	#(96/pfres)+2	; try to come close to the real size
    107  f047					      endif
    108  f047					      endif
    109  f047		       18		      clc
    110  f048		       e5 ef		      sbc	playfieldpos
    111  f04a		       85 ef		      sta	playfieldpos
    112  f04c		       4c 74 f0 	      jmp	.startkernel
    113  f04f
    114  f04f				   .skipDrawP0
    115  f04f		       a9 00		      lda	#0
    116  f051		       a8		      tay
    117  f052		       4c a2 f0 	      jmp	.continueP0
    118  f055
    119  f055				   .skipDrawP1
    120  f055		       a9 00		      lda	#0
    121  f057		       a8		      tay
    122  f058		       4c 7e f0 	      jmp	.continueP1
    123  f05b
    124  f05b				   .kerloop		; enter at cycle 59??
    125  f05b
    126  f05b				   continuekernel
      0  f05b					      sleep	2
      1  f05b				   .CYCLES    SET	2
      2  f05b
      3  f05b				  -	      IF	.CYCLES < 2
      4  f05b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f05b				  -	      ERR
      6  f05b					      ENDIF
      7  f05b
      8  f05b				  -	      IF	.CYCLES & 1
      9  f05b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f05b				  -	      nop	0
     11  f05b				  -	      ELSE
     12  f05b				  -	      bit	VSYNC
     13  f05b				  -	      ENDIF
     14  f05b				  -.CYCLES    SET	.CYCLES - 3
     15  f05b					      ENDIF
     16  f05b
     17  f05b					      REPEAT	.CYCLES / 2
     18  f05b		       ea		      nop
     19  f05c					      REPEND
    128  f05c				   continuekernel2
    129  f05c		       a5 92		      lda	ballheight
    130  f05e
    131  f05e				  -	      ifconst	pfres
    132  f05e				  -	      ldy	playfield+pfres*pfwidth-132,x
    133  f05e				  -	      sty	PF1L	;3
    134  f05e				  -	      ldy	playfield+pfres*pfwidth-131-pfadjust,x
    135  f05e				  -	      sty	PF2L	;3
    136  f05e				  -	      ldy	playfield+pfres*pfwidth-129,x
    137  f05e				  -	      sty	PF1R	; 3 too early?
    138  f05e				  -	      ldy	playfield+pfres*pfwidth-130-pfadjust,x
    139  f05e				  -	      sty	PF2R	;3
    140  f05e					      else
    141  f05e		       b4 50		      ldy	playfield-48+pfwidth*12+44-128,x
    142  f060		       84 0e		      sty	PF1L	;3
    143  f062		       b4 51		      ldy	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
    144  f064		       84 0f		      sty	PF2L	;3
    145  f066		       b4 53		      ldy	playfield-48+pfwidth*12+47-128,x	;4
    146  f068		       84 0e		      sty	PF1R	; 3 too early?
    147  f06a		       b4 52		      ldy	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
    148  f06c		       84 0f		      sty	PF2R	;3
    149  f06e					      endif
    150  f06e
    151  f06e							; should be playfield+$38 for width=2
    152  f06e
    153  f06e		       c7 89		      dcp	bally
    154  f070		       2a		      rol
    155  f071		       2a		      rol
    156  f072							; rol
    157  f072							; rol
    158  f072				   goback
    159  f072		       85 1f		      sta	ENABL
    160  f074				   .startkernel
    161  f074		       a5 8f		      lda	player1height	;3
    162  f076		       c7 86		      dcp	player1y	;5
    163  f078		       90 db		      bcc	.skipDrawP1	;2
    164  f07a		       a4 86		      ldy	player1y	;3
    165  f07c		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
    166  f07e							; so it doesn't cross a page boundary!
    167  f07e
    168  f07e				   .continueP1
    169  f07e		       85 1c		      sta	GRP1	;3
    170  f080
    171  f080					      ifnconst	player1colors
    172  f080		       a5 87		      lda	missile1height	;3
    173  f082		       c7 88		      dcp	missile1y	;5
    174  f084		       2a		      rol		;2
    175  f085		       2a		      rol		;2
    176  f086		       85 1e		      sta	ENAM1	;3
    177  f088				  -	      else
    178  f088				  -	      lda	(player1color),y
    179  f088				  -	      sta	COLUP1
    180  f088				  -	      ifnconst	playercolors
    181  f088				  -	      sleep	7
    182  f088				  -	      else
    183  f088				  -	      lda.w	player0colorstore
    184  f088				  -	      sta	COLUP0
    185  f088				  -	      endif
    186  f088					      endif
    187  f088
    188  f088				  -	      ifconst	pfres
    189  f088				  -	      lda	playfield+pfres*pfwidth-132,x
    190  f088				  -	      sta	PF1L	;3
    191  f088				  -	      lda	playfield+pfres*pfwidth-131-pfadjust,x
    192  f088				  -	      sta	PF2L	;3
    193  f088				  -	      lda	playfield+pfres*pfwidth-129,x
    194  f088				  -	      sta	PF1R	; 3 too early?
    195  f088				  -	      lda	playfield+pfres*pfwidth-130-pfadjust,x
    196  f088				  -	      sta	PF2R	;3
    197  f088					      else
    198  f088		       b5 50		      lda	playfield-48+pfwidth*12+44-128,x	;4
    199  f08a		       85 0e		      sta	PF1L	;3
    200  f08c		       b5 51		      lda	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
    201  f08e		       85 0f		      sta	PF2L	;3
    202  f090		       b5 53		      lda	playfield-48+pfwidth*12+47-128,x	;4
    203  f092		       85 0e		      sta	PF1R	; 3 too early?
    204  f094		       b5 52		      lda	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
    205  f096		       85 0f		      sta	PF2R	;3
    206  f098					      endif
    207  f098							; sleep 3
    208  f098
    209  f098		       a5 8e		      lda	player0height
    210  f09a		       c7 85		      dcp	player0y
    211  f09c		       90 b1		      bcc	.skipDrawP0
    212  f09e		       a4 85		      ldy	player0y
    213  f0a0		       b1 8a		      lda	(player0pointer),y
    214  f0a2				   .continueP0
    215  f0a2		       85 1b		      sta	GRP0
    216  f0a4
    217  f0a4					      ifnconst	no_blank_lines
    218  f0a4					      ifnconst	playercolors
    219  f0a4		       a5 90		      lda	missile0height	;3
    220  f0a6		       c7 91		      dcp	missile0y	;5
    221  f0a8		       e5 f6		      sbc	stack1
    222  f0aa		       85 1d		      sta	ENAM0	;3
    223  f0ac				  -	      else
    224  f0ac				  -	      lda	(player0color),y
    225  f0ac				  -	      sta	player0colorstore
    226  f0ac				  -	      sleep	6
    227  f0ac					      endif
    228  f0ac		       c6 9c		      dec	temp1
    229  f0ae		       d0 ab		      bne	continuekernel
    230  f0b0				  -	      else
    231  f0b0				  -	      dec	temp1
    232  f0b0				  -	      beq	altkernel2
    233  f0b0				  -	      ifconst	readpaddle
    234  f0b0				  -	      ldy	currentpaddle
    235  f0b0				  -	      lda	INPT0,y
    236  f0b0				  -	      bpl	noreadpaddle
    237  f0b0				  -	      inc	paddle
    238  f0b0				  -	      jmp	continuekernel2
    239  f0b0				  -noreadpaddle
    240  f0b0				  -	      sleep	2
    241  f0b0				  -	      jmp	continuekernel
    242  f0b0				  -	      else
    243  f0b0				  -	      ifnconst	playercolors
    244  f0b0				  -	      ifconst	PFcolors
    245  f0b0				  -	      txa
    246  f0b0				  -	      tay
    247  f0b0				  -	      lda	(pfcolortable),y
    248  f0b0				  -	      ifnconst	backgroundchange
    249  f0b0				  -	      sta	COLUPF
    250  f0b0				  -	      else
    251  f0b0				  -	      sta	COLUBK
    252  f0b0				  -	      endif
    253  f0b0				  -	      jmp	continuekernel
    254  f0b0				  -	      else
    255  f0b0				  -	      ifconst	kernelmacrodef
    256  f0b0				  -	      kernelmacro
    257  f0b0				  -	      else
    258  f0b0				  -	      sleep	12
    259  f0b0				  -	      endif
    260  f0b0				  -	      endif
    261  f0b0				  -	      else
    262  f0b0				  -	      lda	(player0color),y
    263  f0b0				  -	      sta	player0colorstore
    264  f0b0				  -	      sleep	4
    265  f0b0				  -	      endif
    266  f0b0				  -	      jmp	continuekernel
    267  f0b0				  -	      endif
    268  f0b0				  -altkernel2
    269  f0b0				  -	      txa
    270  f0b0				  -	      ifnconst	vertical_reflect
    271  f0b0				  -	      sbx	#256-pfwidth
    272  f0b0				  -	      else
    273  f0b0				  -	      sbx	#256-pfwidth/2
    274  f0b0				  -	      endif
    275  f0b0				  -	      bmi	lastkernelline
    276  f0b0				  -	      ifconst	pfrowheight
    277  f0b0				  -	      lda	#pfrowheight
    278  f0b0				  -	      else
    279  f0b0				  -	      ifnconst	pfres
    280  f0b0				  -	      lda	#8
    281  f0b0				  -	      else
    282  f0b0				  -	      lda	#(96/pfres)	; try to come close to the real size
    283  f0b0				  -	      endif
    284  f0b0				  -	      endif
    285  f0b0				  -	      sta	temp1
    286  f0b0				  -	      jmp	continuekernel
    287  f0b0					      endif
    288  f0b0
    289  f0b0				   altkernel
    290  f0b0
    291  f0b0				  -	      ifconst	PFmaskvalue
    292  f0b0				  -	      lda	#PFmaskvalue
    293  f0b0					      else
    294  f0b0		       a9 00		      lda	#0
    295  f0b2					      endif
    296  f0b2		       85 0e		      sta	PF1L
    297  f0b4		       85 0f		      sta	PF2
    298  f0b6
    299  f0b6
    300  f0b6							;sleep 3
    301  f0b6
    302  f0b6							;28 cycles to fix things
    303  f0b6							;minus 11=17
    304  f0b6
    305  f0b6							; lax temp4
    306  f0b6							; clc
    307  f0b6		       8a		      txa
    308  f0b7					      ifnconst	vertical_reflect
    309  f0b7		       cb fc		      sbx	#256-pfwidth
    310  f0b9				  -	      else
    311  f0b9				  -	      sbx	#256-pfwidth/2
    312  f0b9					      endif
    313  f0b9
    314  f0b9		       30 12		      bmi	lastkernelline
    315  f0bb
    316  f0bb				  -	      ifconst	PFcolorandheight
    317  f0bb				  -	      ifconst	pfres
    318  f0bb				  -	      ldy	playfieldcolorandheight-131+pfres*pfwidth,x
    319  f0bb				  -	      else
    320  f0bb				  -	      ldy	playfieldcolorandheight-87,x
    321  f0bb				  -	      endif
    322  f0bb				  -	      ifnconst	backgroundchange
    323  f0bb				  -	      sty	COLUPF
    324  f0bb				  -	      else
    325  f0bb				  -	      sty	COLUBK
    326  f0bb				  -	      endif
    327  f0bb				  -	      ifconst	pfres
    328  f0bb				  -	      lda	playfieldcolorandheight-132+pfres*pfwidth,x
    329  f0bb				  -	      else
    330  f0bb				  -	      lda	playfieldcolorandheight-88,x
    331  f0bb				  -	      endif
    332  f0bb				  -	      sta.w	temp1
    333  f0bb					      endif
    334  f0bb				  -	      ifconst	PFheights
    335  f0bb				  -	      lsr
    336  f0bb				  -	      lsr
    337  f0bb				  -	      tay
    338  f0bb				  -	      lda	(pfheighttable),y
    339  f0bb				  -	      sta.w	temp1
    340  f0bb					      endif
    341  f0bb				  -	      ifconst	PFcolors
    342  f0bb				  -	      tay
    343  f0bb				  -	      lda	(pfcolortable),y
    344  f0bb				  -	      ifnconst	backgroundchange
    345  f0bb				  -	      sta	COLUPF
    346  f0bb				  -	      else
    347  f0bb				  -	      sta	COLUBK
    348  f0bb				  -	      endif
    349  f0bb				  -	      ifconst	pfrowheight
    350  f0bb				  -	      lda	#pfrowheight
    351  f0bb				  -	      else
    352  f0bb				  -	      ifnconst	pfres
    353  f0bb				  -	      lda	#8
    354  f0bb				  -	      else
    355  f0bb				  -	      lda	#(96/pfres)	; try to come close to the real size
    356  f0bb				  -	      endif
    357  f0bb				  -	      endif
    358  f0bb				  -	      sta	temp1
    359  f0bb					      endif
    360  f0bb					      ifnconst	PFcolorandheight
    361  f0bb					      ifnconst	PFcolors
    362  f0bb					      ifnconst	PFheights
    363  f0bb					      ifnconst	no_blank_lines
    364  f0bb							; read paddle 0
    365  f0bb							; lo-res paddle read
    366  f0bb							; bit INPT0
    367  f0bb							; bmi paddleskipread
    368  f0bb							; inc paddle0
    369  f0bb							;donepaddleskip
      0  f0bb					      sleep	10
      1  f0bb				   .CYCLES    SET	10
      2  f0bb
      3  f0bb				  -	      IF	.CYCLES < 2
      4  f0bb				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f0bb				  -	      ERR
      6  f0bb					      ENDIF
      7  f0bb
      8  f0bb				  -	      IF	.CYCLES & 1
      9  f0bb				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f0bb				  -	      nop	0
     11  f0bb				  -	      ELSE
     12  f0bb				  -	      bit	VSYNC
     13  f0bb				  -	      ENDIF
     14  f0bb				  -.CYCLES    SET	.CYCLES - 3
     15  f0bb					      ENDIF
     16  f0bb
     17  f0bb					      REPEAT	.CYCLES / 2
     18  f0bb		       ea		      nop
     17  f0bb					      REPEND
     18  f0bc		       ea		      nop
     17  f0bc					      REPEND
     18  f0bd		       ea		      nop
     17  f0bd					      REPEND
     18  f0be		       ea		      nop
     17  f0be					      REPEND
     18  f0bf		       ea		      nop
     19  f0c0					      REPEND
    371  f0c0				  -	      ifconst	pfrowheight
    372  f0c0				  -	      lda	#pfrowheight
    373  f0c0					      else
    374  f0c0					      ifnconst	pfres
    375  f0c0		       a9 08		      lda	#8
    376  f0c2				  -	      else
    377  f0c2				  -	      lda	#(96/pfres)	; try to come close to the real size
    378  f0c2					      endif
    379  f0c2					      endif
    380  f0c2		       85 9c		      sta	temp1
    381  f0c4					      endif
    382  f0c4					      endif
    383  f0c4					      endif
    384  f0c4					      endif
    385  f0c4
    386  f0c4
    387  f0c4		       a5 92		      lda	ballheight
    388  f0c6		       c7 89		      dcp	bally
    389  f0c8		       e5 9f		      sbc	temp4
    390  f0ca
    391  f0ca
    392  f0ca		       4c 72 f0 	      jmp	goback
    393  f0cd
    394  f0cd
    395  f0cd					      ifnconst	no_blank_lines
    396  f0cd				   lastkernelline
    397  f0cd					      ifnconst	PFcolors
      0  f0cd					      sleep	10
      1  f0cd				   .CYCLES    SET	10
      2  f0cd
      3  f0cd				  -	      IF	.CYCLES < 2
      4  f0cd				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f0cd				  -	      ERR
      6  f0cd					      ENDIF
      7  f0cd
      8  f0cd				  -	      IF	.CYCLES & 1
      9  f0cd				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f0cd				  -	      nop	0
     11  f0cd				  -	      ELSE
     12  f0cd				  -	      bit	VSYNC
     13  f0cd				  -	      ENDIF
     14  f0cd				  -.CYCLES    SET	.CYCLES - 3
     15  f0cd					      ENDIF
     16  f0cd
     17  f0cd					      REPEAT	.CYCLES / 2
     18  f0cd		       ea		      nop
     17  f0cd					      REPEND
     18  f0ce		       ea		      nop
     17  f0ce					      REPEND
     18  f0cf		       ea		      nop
     17  f0cf					      REPEND
     18  f0d0		       ea		      nop
     17  f0d0					      REPEND
     18  f0d1		       ea		      nop
     19  f0d2					      REPEND
    399  f0d2				  -	      else
    400  f0d2				  -	      ldy	#124
    401  f0d2				  -	      lda	(pfcolortable),y
    402  f0d2				  -	      sta	COLUPF
    403  f0d2					      endif
    404  f0d2
    405  f0d2				  -	      ifconst	PFheights
    406  f0d2				  -	      ldx	#1
    407  f0d2				  -			;sleep 4
    408  f0d2				  -	      sleep	3	; this was over 1 cycle
    409  f0d2					      else
    410  f0d2		       a6 ef		      ldx	playfieldpos
    411  f0d4							;sleep 3
      0  f0d4					      sleep	2	; this was over 1 cycle
      1  f0d4				   .CYCLES    SET	2
      2  f0d4
      3  f0d4				  -	      IF	.CYCLES < 2
      4  f0d4				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f0d4				  -	      ERR
      6  f0d4					      ENDIF
      7  f0d4
      8  f0d4				  -	      IF	.CYCLES & 1
      9  f0d4				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f0d4				  -	      nop	0
     11  f0d4				  -	      ELSE
     12  f0d4				  -	      bit	VSYNC
     13  f0d4				  -	      ENDIF
     14  f0d4				  -.CYCLES    SET	.CYCLES - 3
     15  f0d4					      ENDIF
     16  f0d4
     17  f0d4					      REPEAT	.CYCLES / 2
     18  f0d4		       ea		      nop
     19  f0d5					      REPEND
    413  f0d5					      endif
    414  f0d5
    415  f0d5		       4c 1b f1 	      jmp	enterlastkernel
    416  f0d8
    417  f0d8				  -	      else
    418  f0d8				  -lastkernelline
    419  f0d8				  -
    420  f0d8				  -	      ifconst	PFheights
    421  f0d8				  -	      ldx	#1
    422  f0d8				  -			;sleep 5
    423  f0d8				  -	      sleep	4	; this was over 1 cycle
    424  f0d8				  -	      else
    425  f0d8				  -	      ldx	playfieldpos
    426  f0d8				  -			;sleep 4
    427  f0d8				  -	      sleep	3	; this was over 1 cycle
    428  f0d8				  -	      endif
    429  f0d8				  -
    430  f0d8				  -	      cpx	#0
    431  f0d8				  -	      bne	.enterfromNBL
    432  f0d8				  -	      jmp	no_blank_lines_bailout
    433  f0d8					      endif
    434  f0d8
    435  f0d8					      if	((<*)>$d5)
    436  f100		       00 00 00 00*	      align	256
    437  f100					      endif
    438  f100							; this is a kludge to prevent page wrapping - fix!!!
    439  f100
    440  f100				   .skipDrawlastP1
    441  f100		       a9 00		      lda	#0
    442  f102		       a8		      tay		; added so we don't cross a page
    443  f103		       4c 2d f1 	      jmp	.continuelastP1
    444  f106
    445  f106				   .endkerloop		; enter at cycle 59??
    446  f106
    447  f106		       ea		      nop
    448  f107
    449  f107				   .enterfromNBL
    450  f107				  -	      ifconst	pfres
    451  f107				  -	      ldy.w	playfield+pfres*pfwidth-4
    452  f107				  -	      sty	PF1L	;3
    453  f107				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
    454  f107				  -	      sty	PF2L	;3
    455  f107				  -	      ldy.w	playfield+pfres*pfwidth-1
    456  f107				  -	      sty	PF1R	; possibly too early?
    457  f107				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
    458  f107				  -	      sty	PF2R	;3
    459  f107					      else
    460  f107		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
    461  f10a		       84 0e		      sty	PF1L	;3
    462  f10c		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
    463  f10f		       84 0f		      sty	PF2L	;3
    464  f111		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
    465  f114		       84 0e		      sty	PF1R	; possibly too early?
    466  f116		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
    467  f119		       84 0f		      sty	PF2R	;3
    468  f11b					      endif
    469  f11b
    470  f11b				   enterlastkernel
    471  f11b		       a5 92		      lda	ballheight
    472  f11d
    473  f11d							; tya
    474  f11d		       c7 89		      dcp	bally
    475  f11f							; sleep 4
    476  f11f
    477  f11f							; sbc stack3
    478  f11f		       2a		      rol
    479  f120		       2a		      rol
    480  f121		       85 1f		      sta	ENABL
    481  f123
    482  f123		       a5 8f		      lda	player1height	;3
    483  f125		       c7 86		      dcp	player1y	;5
    484  f127		       90 d7		      bcc	.skipDrawlastP1
    485  f129		       a4 86		      ldy	player1y	;3
    486  f12b		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
    487  f12d							; so it doesn't cross a page boundary!
    488  f12d
    489  f12d				   .continuelastP1
    490  f12d		       85 1c		      sta	GRP1	;3
    491  f12f
    492  f12f					      ifnconst	player1colors
    493  f12f		       a5 87		      lda	missile1height	;3
    494  f131		       c7 88		      dcp	missile1y	;5
    495  f133				  -	      else
    496  f133				  -	      lda	(player1color),y
    497  f133				  -	      sta	COLUP1
    498  f133					      endif
    499  f133
    500  f133		       ca		      dex
    501  f134							;dec temp4 ; might try putting this above PF writes
    502  f134		       f0 36		      beq	endkernel
    503  f136
    504  f136
    505  f136				  -	      ifconst	pfres
    506  f136				  -	      ldy.w	playfield+pfres*pfwidth-4
    507  f136				  -	      sty	PF1L	;3
    508  f136				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
    509  f136				  -	      sty	PF2L	;3
    510  f136				  -	      ldy.w	playfield+pfres*pfwidth-1
    511  f136				  -	      sty	PF1R	; possibly too early?
    512  f136				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
    513  f136				  -	      sty	PF2R	;3
    514  f136					      else
    515  f136		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
    516  f139		       84 0e		      sty	PF1L	;3
    517  f13b		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
    518  f13e		       84 0f		      sty	PF2L	;3
    519  f140		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
    520  f143		       84 0e		      sty	PF1R	; possibly too early?
    521  f145		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
    522  f148		       84 0f		      sty	PF2R	;3
    523  f14a					      endif
    524  f14a
    525  f14a					      ifnconst	player1colors
    526  f14a		       2a		      rol		;2
    527  f14b		       2a		      rol		;2
    528  f14c		       85 1e		      sta	ENAM1	;3
    529  f14e				  -	      else
    530  f14e				  -	      ifnconst	playercolors
    531  f14e				  -	      sleep	7
    532  f14e				  -	      else
    533  f14e				  -	      lda.w	player0colorstore
    534  f14e				  -	      sta	COLUP0
    535  f14e				  -	      endif
    536  f14e					      endif
    537  f14e
    538  f14e		       ad 8e 00 	      lda.w	player0height
    539  f151		       c7 85		      dcp	player0y
    540  f153		       90 11		      bcc	.skipDrawlastP0
    541  f155		       a4 85		      ldy	player0y
    542  f157		       b1 8a		      lda	(player0pointer),y
    543  f159				   .continuelastP0
    544  f159		       85 1b		      sta	GRP0
    545  f15b
    546  f15b
    547  f15b
    548  f15b					      ifnconst	no_blank_lines
    549  f15b		       a5 90		      lda	missile0height	;3
    550  f15d		       c7 91		      dcp	missile0y	;5
    551  f15f		       e5 f6		      sbc	stack1
    552  f161		       85 1d		      sta	ENAM0	;3
    553  f163		       4c 06 f1 	      jmp	.endkerloop
    554  f166				  -	      else
    555  f166				  -	      ifconst	readpaddle
    556  f166				  -	      ldy	currentpaddle
    557  f166				  -	      lda	INPT0,y
    558  f166				  -	      bpl	noreadpaddle2
    559  f166				  -	      inc	paddle
    560  f166				  -	      jmp	.endkerloop
    561  f166				  -noreadpaddle2
    562  f166				  -	      sleep	4
    563  f166				  -	      jmp	.endkerloop
    564  f166				  -	      else		; no_blank_lines and no paddle reading
    565  f166				  -	      pla
    566  f166				  -	      pha		; 14 cycles in 4 bytes
    567  f166				  -	      pla
    568  f166				  -	      pha
    569  f166				  -			; sleep 14
    570  f166				  -	      jmp	.endkerloop
    571  f166				  -	      endif
    572  f166					      endif
    573  f166
    574  f166
    575  f166							; ifconst donepaddleskip
    576  f166							;paddleskipread
    577  f166							; this is kind of lame, since it requires 4 cycles from a page boundary crossing
    578  f166							; plus we get a lo-res paddle read
    579  f166							; bmi donepaddleskip
    580  f166							; endif
    581  f166
    582  f166				   .skipDrawlastP0
    583  f166		       a9 00		      lda	#0
    584  f168		       a8		      tay
    585  f169		       4c 59 f1 	      jmp	.continuelastP0
    586  f16c
    587  f16c				  -	      ifconst	no_blank_lines
    588  f16c				  -no_blank_lines_bailout
    589  f16c				  -	      ldx	#0
    590  f16c					      endif
    591  f16c
    592  f16c				   endkernel
    593  f16c							; 6 digit score routine
    594  f16c		       86 0e		      stx	PF1
    595  f16e		       86 0f		      stx	PF2
    596  f170		       86 0d		      stx	PF0
    597  f172		       18		      clc
    598  f173
    599  f173				  -	      ifconst	pfrowheight
    600  f173				  -	      lda	#pfrowheight+2
    601  f173					      else
    602  f173					      ifnconst	pfres
    603  f173		       a9 0a		      lda	#10
    604  f175				  -	      else
    605  f175				  -	      lda	#(96/pfres)+2	; try to come close to the real size
    606  f175					      endif
    607  f175					      endif
    608  f175
    609  f175		       e5 ef		      sbc	playfieldpos
    610  f177		       85 ef		      sta	playfieldpos
    611  f179		       8a		      txa
    612  f17a
    613  f17a				  -	      ifconst	shakescreen
    614  f17a				  -	      bit	shakescreen
    615  f17a				  -	      bmi	noshakescreen2
    616  f17a				  -	      ldx	#$3D
    617  f17a				  -noshakescreen2
    618  f17a					      endif
    619  f17a
    620  f17a		       95 02		      sta	WSYNC,x
    621  f17c
    622  f17c							; STA WSYNC ;first one, need one more
    623  f17c		       85 0b		      sta	REFP0
    624  f17e		       85 0c		      sta	REFP1
    625  f180		       85 1b		      STA	GRP0
    626  f182		       85 1c		      STA	GRP1
    627  f184							; STA PF1
    628  f184							; STA PF2
    629  f184		       85 2b		      sta	HMCLR
    630  f186		       85 1d		      sta	ENAM0
    631  f188		       85 1e		      sta	ENAM1
    632  f18a		       85 1f		      sta	ENABL
    633  f18c
    634  f18c		       a5 9d		      lda	temp2	;restore variables that were obliterated by kernel
    635  f18e		       85 85		      sta	player0y
    636  f190		       a5 9e		      lda	temp3
    637  f192		       85 86		      sta	player1y
    638  f194					      ifnconst	player1colors
    639  f194		       a5 a1		      lda	temp6
    640  f196		       85 88		      sta	missile1y
    641  f198					      endif
    642  f198					      ifnconst	playercolors
    643  f198					      ifnconst	readpaddle
    644  f198		       a5 a0		      lda	temp5
    645  f19a		       85 91		      sta	missile0y
    646  f19c					      endif
    647  f19c					      endif
    648  f19c		       a5 f7		      lda	stack2
    649  f19e		       85 89		      sta	bally
    650  f1a0
    651  f1a0							; strangely, this isn't required any more. might have
    652  f1a0							; resulted from the no_blank_lines score bounce fix
    653  f1a0							;ifconst no_blank_lines
    654  f1a0							;sta WSYNC
    655  f1a0							;endif
    656  f1a0
    657  f1a0		       ad 84 02 	      lda	INTIM
    658  f1a3		       18		      clc
    659  f1a4					      ifnconst	vblank_time
    660  f1a4		       69 8e		      adc	#43+12+87
    661  f1a6				  -	      else
    662  f1a6				  -	      adc	#vblank_time+12+87
    663  f1a6				  -
    664  f1a6					      endif
    665  f1a6							; sta WSYNC
    666  f1a6		       8d 96 02 	      sta	TIM64T
    667  f1a9
    668  f1a9				  -	      ifconst	minikernel
    669  f1a9				  -	      jsr	minikernel
    670  f1a9					      endif
    671  f1a9
    672  f1a9							; now reassign temp vars for score pointers
    673  f1a9
    674  f1a9							; score pointers contain:
    675  f1a9							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
    676  f1a9							; swap lo2->temp1
    677  f1a9							; swap lo4->temp3
    678  f1a9							; swap lo6->temp5
    679  f1a9					      ifnconst	noscore
    680  f1a9		       a5 97		      lda	scorepointers+1
    681  f1ab							; ldy temp1
    682  f1ab		       85 9c		      sta	temp1
    683  f1ad							; sty scorepointers+1
    684  f1ad
    685  f1ad		       a5 99		      lda	scorepointers+3
    686  f1af							; ldy temp3
    687  f1af		       85 9e		      sta	temp3
    688  f1b1							; sty scorepointers+3
    689  f1b1
    690  f1b1
    691  f1b1		       85 2b		      sta	HMCLR
    692  f1b3		       ba		      tsx
    693  f1b4		       86 f6		      stx	stack1
    694  f1b6		       a2 e0		      ldx	#$E0
    695  f1b8		       86 20		      stx	HMP0
    696  f1ba
    697  f1ba		       a5 a3		      LDA	scorecolor
    698  f1bc		       85 06		      STA	COLUP0
    699  f1be		       85 07		      STA	COLUP1
    700  f1c0				  -	      ifconst	scorefade
    701  f1c0				  -	      STA	stack2
    702  f1c0					      endif
    703  f1c0				  -	      ifconst	pfscore
    704  f1c0				  -	      lda	pfscorecolor
    705  f1c0				  -	      sta	COLUPF
    706  f1c0					      endif
    707  f1c0		       85 02		      sta	WSYNC
    708  f1c2		       a2 00		      ldx	#0
    709  f1c4		       86 1b		      STx	GRP0
    710  f1c6		       86 1c		      STx	GRP1	; seems to be needed because of vdel
    711  f1c8
    712  f1c8		       a5 9b		      lda	scorepointers+5
    713  f1ca							; ldy temp5
    714  f1ca		       95 a0		      sta	temp5,x
    715  f1cc							; sty scorepointers+5
    716  f1cc		       a9 ff		      lda	#>scoretable
    717  f1ce		       85 97		      sta	scorepointers+1
    718  f1d0		       85 99		      sta	scorepointers+3
    719  f1d2		       85 9b		      sta	scorepointers+5
    720  f1d4		       85 9d		      sta	temp2
    721  f1d6		       85 9f		      sta	temp4
    722  f1d8		       85 a1		      sta	temp6
    723  f1da		       a0 07		      LDY	#7
    724  f1dc		       84 25		      STY	VDELP0
    725  f1de		       85 10		      STA	RESP0
    726  f1e0		       85 11		      STA	RESP1
    727  f1e2
    728  f1e2
    729  f1e2		       a9 03		      LDA	#$03
    730  f1e4		       85 04		      STA	NUSIZ0
    731  f1e6		       85 05		      STA	NUSIZ1
    732  f1e8		       85 26		      STA	VDELP1
    733  f1ea		       a9 f0		      LDA	#$F0
    734  f1ec		       85 21		      STA	HMP1
    735  f1ee		       b1 96		      lda	(scorepointers),y
    736  f1f0		       85 1b		      sta	GRP0
    737  f1f2		       85 2a		      STA	HMOVE	; cycle 73 ?
    738  f1f4		       4c 08 f2 	      jmp	beginscore
    739  f1f7
    740  f1f7
    741  f1f7					      if	((<*)>$d4)
    742  f200		       00 00 00 00*	      align	256	; kludge that potentially wastes space! should be fixed!
    743  f200					      endif
    744  f200
    745  f200				   loop2
    746  f200		       b1 96		      lda	(scorepointers),y	;+5 68 204
    747  f202		       85 1b		      sta	GRP0	;+3 71 213 D1 -- -- --
    748  f204				  -	      ifconst	pfscore
    749  f204				  -	      lda.w	pfscore1
    750  f204				  -	      sta	PF1
    751  f204					      else
    752  f204				  -	      ifconst	scorefade
    753  f204				  -	      sleep	2
    754  f204				  -	      dec	stack2	; decrement the temporary scorecolor
    755  f204					      else
      0  f204					      sleep	7
      1  f204				   .CYCLES    SET	7
      2  f204
      3  f204				  -	      IF	.CYCLES < 2
      4  f204				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f204				  -	      ERR
      6  f204					      ENDIF
      7  f204
      8  f204					      IF	.CYCLES & 1
      9  f204					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f204		       04 00		      nop	0
     11  f206				  -	      ELSE
     12  f206				  -	      bit	VSYNC
     13  f206					      ENDIF
     14  f206				   .CYCLES    SET	.CYCLES - 3
     15  f206					      ENDIF
     16  f206
     17  f206					      REPEAT	.CYCLES / 2
     18  f206		       ea		      nop
     17  f206					      REPEND
     18  f207		       ea		      nop
     19  f208					      REPEND
    757  f208					      endif
    758  f208					      endif
    759  f208							; cycle 0
    760  f208				   beginscore
    761  f208		       b1 9e		      lda	(scorepointers+$8),y	;+5 5 15
    762  f20a		       85 1c		      sta	GRP1	;+3 8 24 D1 D1 D2 --
    763  f20c		       b1 9c		      lda	(scorepointers+$6),y	;+5 13 39
    764  f20e		       85 1b		      sta	GRP0	;+3 16 48 D3 D1 D2 D2
    765  f210		       b3 98		      lax	(scorepointers+$2),y	;+5 29 87
    766  f212		       9a		      txs
    767  f213		       b3 9a		      lax	(scorepointers+$4),y	;+5 36 108
    768  f215				  -	      ifconst	scorefade
    769  f215				  -	      lda	stack2
    770  f215					      else
      0  f215					      sleep	3
      1  f215				   .CYCLES    SET	3
      2  f215
      3  f215				  -	      IF	.CYCLES < 2
      4  f215				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f215				  -	      ERR
      6  f215					      ENDIF
      7  f215
      8  f215					      IF	.CYCLES & 1
      9  f215					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f215		       04 00		      nop	0
     11  f217				  -	      ELSE
     12  f217				  -	      bit	VSYNC
     13  f217					      ENDIF
     14  f217				   .CYCLES    SET	.CYCLES - 3
     15  f217					      ENDIF
     16  f217
     17  f217				  -	      REPEAT	.CYCLES / 2
     18  f217				  -	      nop
     19  f217					      REPEND
    772  f217					      endif
    773  f217
    774  f217				  -	      ifconst	pfscore
    775  f217				  -	      lda	pfscore2
    776  f217				  -	      sta	PF1
    777  f217					      else
    778  f217				  -	      ifconst	scorefade
    779  f217				  -	      sta	COLUP0
    780  f217				  -	      sta	COLUP1
    781  f217					      else
      0  f217					      sleep	6
      1  f217				   .CYCLES    SET	6
      2  f217
      3  f217				  -	      IF	.CYCLES < 2
      4  f217				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f217				  -	      ERR
      6  f217					      ENDIF
      7  f217
      8  f217				  -	      IF	.CYCLES & 1
      9  f217				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f217				  -	      nop	0
     11  f217				  -	      ELSE
     12  f217				  -	      bit	VSYNC
     13  f217				  -	      ENDIF
     14  f217				  -.CYCLES    SET	.CYCLES - 3
     15  f217					      ENDIF
     16  f217
     17  f217					      REPEAT	.CYCLES / 2
     18  f217		       ea		      nop
     17  f217					      REPEND
     18  f218		       ea		      nop
     17  f218					      REPEND
     18  f219		       ea		      nop
     19  f21a					      REPEND
    783  f21a					      endif
    784  f21a					      endif
    785  f21a
    786  f21a		       b1 a0		      lda	(scorepointers+$A),y	;+5 21 63
    787  f21c		       86 1c		      stx	GRP1	;+3 44 132 D3 D3 D4 D2!
    788  f21e		       ba		      tsx
    789  f21f		       86 1b		      stx	GRP0	;+3 47 141 D5 D3! D4 D4
    790  f221		       85 1c		      sta	GRP1	;+3 50 150 D5 D5 D6 D4!
    791  f223		       84 1b		      sty	GRP0	;+3 53 159 D4* D5! D6 D6
    792  f225		       88		      dey
    793  f226		       10 d8		      bpl	loop2	;+2 60 180
    794  f228
    795  f228		       a6 f6		      ldx	stack1
    796  f22a		       9a		      txs
    797  f22b							; lda scorepointers+1
    798  f22b		       a4 9c		      ldy	temp1
    799  f22d							; sta temp1
    800  f22d		       84 97		      sty	scorepointers+1
    801  f22f
    802  f22f		       a9 00		      LDA	#0
    803  f231		       85 0e		      sta	PF1
    804  f233		       85 1b		      STA	GRP0
    805  f235		       85 1c		      STA	GRP1
    806  f237		       85 25		      STA	VDELP0
    807  f239		       85 26		      STA	VDELP1	;do we need these
    808  f23b		       85 04		      STA	NUSIZ0
    809  f23d		       85 05		      STA	NUSIZ1
    810  f23f
    811  f23f							; lda scorepointers+3
    812  f23f		       a4 9e		      ldy	temp3
    813  f241							; sta temp3
    814  f241		       84 99		      sty	scorepointers+3
    815  f243
    816  f243							; lda scorepointers+5
    817  f243		       a4 a0		      ldy	temp5
    818  f245							; sta temp5
    819  f245		       84 9b		      sty	scorepointers+5
    820  f247					      endif		;noscore
    821  f247				  -	      ifconst	readpaddle
    822  f247				  -	      lda	#%11000010
    823  f247					      else
    824  f247				  -	      ifconst	qtcontroller
    825  f247				  -	      lda	qtcontroller
    826  f247				  -	      lsr		; bit 0 in carry
    827  f247				  -	      lda	#4
    828  f247				  -	      ror		; carry into top of A
    829  f247					      else
    830  f247		       a9 02		      lda	#2
    831  f249					      endif		; qtcontroller
    832  f249					      endif		; readpaddle
    833  f249		       85 02		      sta	WSYNC
    834  f24b		       85 01		      sta	VBLANK
      0  f24d					      RETURN
      1  f24d					      ifnconst	bankswitch
      2  f24d		       60		      rts
      3  f24e				  -	      else
      4  f24e				  -	      jmp	BS_return
      5  f24e					      endif
    836  f24e				  -	      ifconst	shakescreen
    837  f24e				  -doshakescreen
    838  f24e				  -	      bit	shakescreen
    839  f24e				  -	      bmi	noshakescreen
    840  f24e				  -	      sta	WSYNC
    841  f24e				  -noshakescreen
    842  f24e				  -	      ldx	missile0height
    843  f24e				  -	      inx
    844  f24e				  -	      rts
    845  f24e					      endif
    846  f24e
    847  f24e							; Provided under the CC0 license. See the included LICENSE.txt for details.
    848  f24e
    849  f24e				   start
    850  f24e		       78		      sei
    851  f24f		       d8		      cld
    852  f250		       a0 00		      ldy	#0
    853  f252		       a5 d0		      lda	$D0
    854  f254		       c9 2c		      cmp	#$2C	;check RAM location #1
    855  f256		       d0 07		      bne	MachineIs2600
    856  f258		       a5 d1		      lda	$D1
    857  f25a		       c9 a9		      cmp	#$A9	;check RAM location #2
    858  f25c		       d0 01		      bne	MachineIs2600
    859  f25e		       88		      dey
    860  f25f				   MachineIs2600
    861  f25f		       a2 00		      ldx	#0
    862  f261		       8a		      txa
    863  f262				   clearmem
    864  f262		       e8		      inx
    865  f263		       9a		      txs
    866  f264		       48		      pha
    867  f265		       d0 fb		      bne	clearmem
    868  f267		       84 9c		      sty	temp1
    869  f269					      ifnconst	multisprite
    870  f269				  -	      ifconst	pfrowheight
    871  f269				  -	      lda	#pfrowheight
    872  f269					      else
    873  f269				  -	      ifconst	pfres
    874  f269				  -	      lda	#(96/pfres)
    875  f269					      else
    876  f269		       a9 08		      lda	#8
    877  f26b					      endif
    878  f26b					      endif
    879  f26b		       85 ef		      sta	playfieldpos
    880  f26d					      endif
    881  f26d		       a2 05		      ldx	#5
    882  f26f				   initscore
    883  f26f		       a9 9c		      lda	#<scoretable
    884  f271		       95 96		      sta	scorepointers,x
    885  f273		       ca		      dex
    886  f274		       10 f9		      bpl	initscore
    887  f276		       a9 01		      lda	#1
    888  f278		       85 0a		      sta	CTRLPF
    889  f27a		       0d 84 02 	      ora	INTIM
    890  f27d		       85 a2		      sta	rand
    891  f27f
    892  f27f				  -	      ifconst	multisprite
    893  f27f				  -	      jsr	multisprite_setup
    894  f27f					      endif
    895  f27f
    896  f27f					      ifnconst	bankswitch
    897  f27f		       4c 00 00 	      jmp	game
    898  f282				  -	      else
    899  f282				  -	      lda	#>(game-1)
    900  f282				  -	      pha
    901  f282				  -	      lda	#<(game-1)
    902  f282				  -	      pha
    903  f282				  -	      pha
    904  f282				  -	      pha
    905  f282				  -	      ldx	#1
    906  f282				  -	      jmp	BS_jsr
    907  f282					      endif
    908  f282							; Provided under the CC0 license. See the included LICENSE.txt for details.
    909  f282
    910  f282							; playfield drawing routines
    911  f282							; you get a 32x12 bitmapped display in a single color :)
    912  f282							; 0-31 and 0-11
    913  f282
    914  f282				   pfclear		; clears playfield - or fill with pattern
    915  f282				  -	      ifconst	pfres
    916  f282				  -	      ldx	#pfres*pfwidth-1
    917  f282					      else
    918  f282		       a2 2f		      ldx	#47-(4-pfwidth)*12	; will this work?
    919  f284					      endif
    920  f284				   pfclear_loop
    921  f284					      ifnconst	superchip
    922  f284		       95 a4		      sta	playfield,x
    923  f286				  -	      else
    924  f286				  -	      sta	playfield-128,x
    925  f286					      endif
    926  f286		       ca		      dex
    927  f287		       10 fb		      bpl	pfclear_loop
      0  f289					      RETURN
      1  f289					      ifnconst	bankswitch
      2  f289		       60		      rts
      3  f28a				  -	      else
      4  f28a				  -	      jmp	BS_return
      5  f28a					      endif
    929  f28a
    930  f28a				   setuppointers
    931  f28a		       86 9d		      stx	temp2	; store on.off.flip value
    932  f28c		       aa		      tax		; put x-value in x 
    933  f28d		       4a		      lsr
    934  f28e		       4a		      lsr
    935  f28f		       4a		      lsr		; divide x pos by 8 
    936  f290		       85 9c		      sta	temp1
    937  f292		       98		      tya
    938  f293		       0a		      asl
    939  f294					      if	pfwidth=4
    940  f294		       0a		      asl		; multiply y pos by 4
    941  f295					      endif		; else multiply by 2
    942  f295		       18		      clc
    943  f296		       65 9c		      adc	temp1	; add them together to get actual memory location offset
    944  f298		       a8		      tay		; put the value in y
    945  f299		       a5 9d		      lda	temp2	; restore on.off.flip value
    946  f29b		       60		      rts
    947  f29c
    948  f29c				   pfread
    949  f29c							;x=xvalue, y=yvalue
    950  f29c		       20 8a f2 	      jsr	setuppointers
    951  f29f		       bd 04 f3 	      lda	setbyte,x
    952  f2a2		       39 a4 00 	      and	playfield,y
    953  f2a5		       5d 04 f3 	      eor	setbyte,x
    954  f2a8							; beq readzero
    955  f2a8							; lda #1
    956  f2a8							; readzero
      0  f2a8					      RETURN
      1  f2a8					      ifnconst	bankswitch
      2  f2a8		       60		      rts
      3  f2a9				  -	      else
      4  f2a9				  -	      jmp	BS_return
      5  f2a9					      endif
    958  f2a9
    959  f2a9				   pfpixel
    960  f2a9							;x=xvalue, y=yvalue, a=0,1,2
    961  f2a9		       20 8a f2 	      jsr	setuppointers
    962  f2ac
    963  f2ac				  -	      ifconst	bankswitch
    964  f2ac				  -	      lda	temp2	; load on.off.flip value (0,1, or 2)
    965  f2ac				  -	      beq	pixelon_r	; if "on" go to on
    966  f2ac				  -	      lsr
    967  f2ac				  -	      bcs	pixeloff_r	; value is 1 if true
    968  f2ac				  -	      lda	playfield,y	; if here, it's "flip"
    969  f2ac				  -	      eor	setbyte,x
    970  f2ac				  -	      ifconst	superchip
    971  f2ac				  -	      sta	playfield-128,y
    972  f2ac				  -	      else
    973  f2ac				  -	      sta	playfield,y
    974  f2ac				  -	      endif
    975  f2ac				  -	      RETURN
    976  f2ac				  -pixelon_r
    977  f2ac				  -	      lda	playfield,y
    978  f2ac				  -	      ora	setbyte,x
    979  f2ac				  -	      ifconst	superchip
    980  f2ac				  -	      sta	playfield-128,y
    981  f2ac				  -	      else
    982  f2ac				  -	      sta	playfield,y
    983  f2ac				  -	      endif
    984  f2ac				  -	      RETURN
    985  f2ac				  -pixeloff_r
    986  f2ac				  -	      lda	setbyte,x
    987  f2ac				  -	      eor	#$ff
    988  f2ac				  -	      and	playfield,y
    989  f2ac				  -	      ifconst	superchip
    990  f2ac				  -	      sta	playfield-128,y
    991  f2ac				  -	      else
    992  f2ac				  -	      sta	playfield,y
    993  f2ac				  -	      endif
    994  f2ac				  -	      RETURN
    995  f2ac				  -
    996  f2ac					      else
    997  f2ac		       4c dd f2 	      jmp	plotpoint
    998  f2af					      endif
    999  f2af
   1000  f2af				   pfhline
   1001  f2af							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   1002  f2af		       20 8a f2 	      jsr	setuppointers
   1003  f2b2		       4c bc f2 	      jmp	noinc
   1004  f2b5				   keepgoing
   1005  f2b5		       e8		      inx
   1006  f2b6		       8a		      txa
   1007  f2b7		       29 07		      and	#7
   1008  f2b9		       d0 01		      bne	noinc
   1009  f2bb		       c8		      iny
   1010  f2bc				   noinc
   1011  f2bc		       20 dd f2 	      jsr	plotpoint
   1012  f2bf		       e4 9e		      cpx	temp3
   1013  f2c1		       30 f2		      bmi	keepgoing
      0  f2c3					      RETURN
      1  f2c3					      ifnconst	bankswitch
      2  f2c3		       60		      rts
      3  f2c4				  -	      else
      4  f2c4				  -	      jmp	BS_return
      5  f2c4					      endif
   1015  f2c4
   1016  f2c4				   pfvline
   1017  f2c4							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   1018  f2c4		       20 8a f2 	      jsr	setuppointers
   1019  f2c7		       84 9c		      sty	temp1	; store memory location offset
   1020  f2c9		       e6 9e		      inc	temp3	; increase final x by 1 
   1021  f2cb		       a5 9e		      lda	temp3
   1022  f2cd		       0a		      asl
   1023  f2ce					      if	pfwidth=4
   1024  f2ce		       0a		      asl		; multiply by 4
   1025  f2cf					      endif		; else multiply by 2
   1026  f2cf		       85 9e		      sta	temp3	; store it
   1027  f2d1							; Thanks to Michael Rideout for fixing a bug in this code
   1028  f2d1							; right now, temp1=y=starting memory location, temp3=final
   1029  f2d1							; x should equal original x value
   1030  f2d1				   keepgoingy
   1031  f2d1		       20 dd f2 	      jsr	plotpoint
   1032  f2d4		       c8		      iny
   1033  f2d5		       c8		      iny
   1034  f2d6					      if	pfwidth=4
   1035  f2d6		       c8		      iny
   1036  f2d7		       c8		      iny
   1037  f2d8					      endif
   1038  f2d8		       c4 9e		      cpy	temp3
   1039  f2da		       30 f5		      bmi	keepgoingy
      0  f2dc					      RETURN
      1  f2dc					      ifnconst	bankswitch
      2  f2dc		       60		      rts
      3  f2dd				  -	      else
      4  f2dd				  -	      jmp	BS_return
      5  f2dd					      endif
   1041  f2dd
   1042  f2dd				   plotpoint
   1043  f2dd		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   1044  f2df		       f0 0d		      beq	pixelon	; if "on" go to on
   1045  f2e1		       4a		      lsr
   1046  f2e2		       b0 14		      bcs	pixeloff	; value is 1 if true
   1047  f2e4		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   1048  f2e7		       5d 04 f3 	      eor	setbyte,x
   1049  f2ea				  -	      ifconst	superchip
   1050  f2ea				  -	      sta	playfield-128,y
   1051  f2ea					      else
   1052  f2ea		       99 a4 00 	      sta	playfield,y
   1053  f2ed					      endif
   1054  f2ed		       60		      rts
   1055  f2ee				   pixelon
   1056  f2ee		       b9 a4 00 	      lda	playfield,y
   1057  f2f1		       1d 04 f3 	      ora	setbyte,x
   1058  f2f4				  -	      ifconst	superchip
   1059  f2f4				  -	      sta	playfield-128,y
   1060  f2f4					      else
   1061  f2f4		       99 a4 00 	      sta	playfield,y
   1062  f2f7					      endif
   1063  f2f7		       60		      rts
   1064  f2f8				   pixeloff
   1065  f2f8		       bd 04 f3 	      lda	setbyte,x
   1066  f2fb		       49 ff		      eor	#$ff
   1067  f2fd		       39 a4 00 	      and	playfield,y
   1068  f300				  -	      ifconst	superchip
   1069  f300				  -	      sta	playfield-128,y
   1070  f300					      else
   1071  f300		       99 a4 00 	      sta	playfield,y
   1072  f303					      endif
   1073  f303		       60		      rts
   1074  f304
   1075  f304				   setbyte
   1076  f304					      ifnconst	pfcenter
   1077  f304		       80		      .byte.b	$80
   1078  f305		       40		      .byte.b	$40
   1079  f306		       20		      .byte.b	$20
   1080  f307		       10		      .byte.b	$10
   1081  f308		       08		      .byte.b	$08
   1082  f309		       04		      .byte.b	$04
   1083  f30a		       02		      .byte.b	$02
   1084  f30b		       01		      .byte.b	$01
   1085  f30c					      endif
   1086  f30c		       01		      .byte.b	$01
   1087  f30d		       02		      .byte.b	$02
   1088  f30e		       04		      .byte.b	$04
   1089  f30f		       08		      .byte.b	$08
   1090  f310		       10		      .byte.b	$10
   1091  f311		       20		      .byte.b	$20
   1092  f312		       40		      .byte.b	$40
   1093  f313		       80		      .byte.b	$80
   1094  f314		       80		      .byte.b	$80
   1095  f315		       40		      .byte.b	$40
   1096  f316		       20		      .byte.b	$20
   1097  f317		       10		      .byte.b	$10
   1098  f318		       08		      .byte.b	$08
   1099  f319		       04		      .byte.b	$04
   1100  f31a		       02		      .byte.b	$02
   1101  f31b		       01		      .byte.b	$01
   1102  f31c		       01		      .byte.b	$01
   1103  f31d		       02		      .byte.b	$02
   1104  f31e		       04		      .byte.b	$04
   1105  f31f		       08		      .byte.b	$08
   1106  f320		       10		      .byte.b	$10
   1107  f321		       20		      .byte.b	$20
   1108  f322		       40		      .byte.b	$40
   1109  f323		       80		      .byte.b	$80
   1110  f324							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1111  f324
   1112  f324				   pfscroll		;(a=0 left, 1 right, 2 up, 4 down, 6=upup, 12=downdown)
   1113  f324		       d0 13		      bne	notleft
   1114  f326							;left
   1115  f326				  -	      ifconst	pfres
   1116  f326				  -	      ldx	#pfres*4
   1117  f326					      else
   1118  f326		       a2 30		      ldx	#48
   1119  f328					      endif
   1120  f328				   leftloop
   1121  f328		       b5 a3		      lda	playfield-1,x
   1122  f32a		       4a		      lsr
   1123  f32b
   1124  f32b				  -	      ifconst	superchip
   1125  f32b				  -	      lda	playfield-2,x
   1126  f32b				  -	      rol
   1127  f32b				  -	      sta	playfield-130,x
   1128  f32b				  -	      lda	playfield-3,x
   1129  f32b				  -	      ror
   1130  f32b				  -	      sta	playfield-131,x
   1131  f32b				  -	      lda	playfield-4,x
   1132  f32b				  -	      rol
   1133  f32b				  -	      sta	playfield-132,x
   1134  f32b				  -	      lda	playfield-1,x
   1135  f32b				  -	      ror
   1136  f32b				  -	      sta	playfield-129,x
   1137  f32b					      else
   1138  f32b		       36 a2		      rol	playfield-2,x
   1139  f32d		       76 a1		      ror	playfield-3,x
   1140  f32f		       36 a0		      rol	playfield-4,x
   1141  f331		       76 a3		      ror	playfield-1,x
   1142  f333					      endif
   1143  f333
   1144  f333		       8a		      txa
   1145  f334		       cb 04		      sbx	#4
   1146  f336		       d0 f0		      bne	leftloop
      0  f338					      RETURN
      1  f338					      ifnconst	bankswitch
      2  f338		       60		      rts
      3  f339				  -	      else
      4  f339				  -	      jmp	BS_return
      5  f339					      endif
   1148  f339
   1149  f339				   notleft
   1150  f339		       4a		      lsr
   1151  f33a		       90 13		      bcc	notright
   1152  f33c							;right
   1153  f33c
   1154  f33c				  -	      ifconst	pfres
   1155  f33c				  -	      ldx	#pfres*4
   1156  f33c					      else
   1157  f33c		       a2 30		      ldx	#48
   1158  f33e					      endif
   1159  f33e				   rightloop
   1160  f33e		       b5 a0		      lda	playfield-4,x
   1161  f340		       4a		      lsr
   1162  f341				  -	      ifconst	superchip
   1163  f341				  -	      lda	playfield-3,x
   1164  f341				  -	      rol
   1165  f341				  -	      sta	playfield-131,x
   1166  f341				  -	      lda	playfield-2,x
   1167  f341				  -	      ror
   1168  f341				  -	      sta	playfield-130,x
   1169  f341				  -	      lda	playfield-1,x
   1170  f341				  -	      rol
   1171  f341				  -	      sta	playfield-129,x
   1172  f341				  -	      lda	playfield-4,x
   1173  f341				  -	      ror
   1174  f341				  -	      sta	playfield-132,x
   1175  f341					      else
   1176  f341		       36 a1		      rol	playfield-3,x
   1177  f343		       76 a2		      ror	playfield-2,x
   1178  f345		       36 a3		      rol	playfield-1,x
   1179  f347		       76 a0		      ror	playfield-4,x
   1180  f349					      endif
   1181  f349		       8a		      txa
   1182  f34a		       cb 04		      sbx	#4
   1183  f34c		       d0 f0		      bne	rightloop
      0  f34e					      RETURN
      1  f34e					      ifnconst	bankswitch
      2  f34e		       60		      rts
      3  f34f				  -	      else
      4  f34f				  -	      jmp	BS_return
      5  f34f					      endif
   1185  f34f
   1186  f34f				   notright
   1187  f34f		       4a		      lsr
   1188  f350		       90 49		      bcc	notup
   1189  f352							;up
   1190  f352		       4a		      lsr
   1191  f353		       90 02		      bcc	onedecup
   1192  f355		       c6 ef		      dec	playfieldpos
   1193  f357				   onedecup
   1194  f357		       c6 ef		      dec	playfieldpos
   1195  f359		       f0 02		      beq	shiftdown
   1196  f35b		       10 3d		      bpl	noshiftdown2
   1197  f35d				   shiftdown
   1198  f35d				  -	      ifconst	pfrowheight
   1199  f35d				  -	      lda	#pfrowheight
   1200  f35d					      else
   1201  f35d					      ifnconst	pfres
   1202  f35d		       a9 08		      lda	#8
   1203  f35f				  -	      else
   1204  f35f				  -	      lda	#(96/pfres)	; try to come close to the real size
   1205  f35f					      endif
   1206  f35f					      endif
   1207  f35f
   1208  f35f		       85 ef		      sta	playfieldpos
   1209  f361		       a5 a7		      lda	playfield+3
   1210  f363		       85 9f		      sta	temp4
   1211  f365		       a5 a6		      lda	playfield+2
   1212  f367		       85 9e		      sta	temp3
   1213  f369		       a5 a5		      lda	playfield+1
   1214  f36b		       85 9d		      sta	temp2
   1215  f36d		       a5 a4		      lda	playfield
   1216  f36f		       85 9c		      sta	temp1
   1217  f371		       a2 00		      ldx	#0
   1218  f373				   up2
   1219  f373		       b5 a8		      lda	playfield+4,x
   1220  f375				  -	      ifconst	superchip
   1221  f375				  -	      sta	playfield-128,x
   1222  f375				  -	      lda	playfield+5,x
   1223  f375				  -	      sta	playfield-127,x
   1224  f375				  -	      lda	playfield+6,x
   1225  f375				  -	      sta	playfield-126,x
   1226  f375				  -	      lda	playfield+7,x
   1227  f375				  -	      sta	playfield-125,x
   1228  f375					      else
   1229  f375		       95 a4		      sta	playfield,x
   1230  f377		       b5 a9		      lda	playfield+5,x
   1231  f379		       95 a5		      sta	playfield+1,x
   1232  f37b		       b5 aa		      lda	playfield+6,x
   1233  f37d		       95 a6		      sta	playfield+2,x
   1234  f37f		       b5 ab		      lda	playfield+7,x
   1235  f381		       95 a7		      sta	playfield+3,x
   1236  f383					      endif
   1237  f383		       8a		      txa
   1238  f384		       cb fc		      sbx	#252
   1239  f386				  -	      ifconst	pfres
   1240  f386				  -	      cpx	#(pfres-1)*4
   1241  f386					      else
   1242  f386		       e0 2c		      cpx	#44
   1243  f388					      endif
   1244  f388		       d0 e9		      bne	up2
   1245  f38a
   1246  f38a		       a5 9f		      lda	temp4
   1247  f38c
   1248  f38c				  -	      ifconst	superchip
   1249  f38c				  -	      ifconst	pfres
   1250  f38c				  -	      sta	playfield+pfres*4-129
   1251  f38c				  -	      lda	temp3
   1252  f38c				  -	      sta	playfield+pfres*4-130
   1253  f38c				  -	      lda	temp2
   1254  f38c				  -	      sta	playfield+pfres*4-131
   1255  f38c				  -	      lda	temp1
   1256  f38c				  -	      sta	playfield+pfres*4-132
   1257  f38c				  -	      else
   1258  f38c				  -	      sta	playfield+47-128
   1259  f38c				  -	      lda	temp3
   1260  f38c				  -	      sta	playfield+46-128
   1261  f38c				  -	      lda	temp2
   1262  f38c				  -	      sta	playfield+45-128
   1263  f38c				  -	      lda	temp1
   1264  f38c				  -	      sta	playfield+44-128
   1265  f38c				  -	      endif
   1266  f38c					      else
   1267  f38c				  -	      ifconst	pfres
   1268  f38c				  -	      sta	playfield+pfres*4-1
   1269  f38c				  -	      lda	temp3
   1270  f38c				  -	      sta	playfield+pfres*4-2
   1271  f38c				  -	      lda	temp2
   1272  f38c				  -	      sta	playfield+pfres*4-3
   1273  f38c				  -	      lda	temp1
   1274  f38c				  -	      sta	playfield+pfres*4-4
   1275  f38c					      else
   1276  f38c		       85 d3		      sta	playfield+47
   1277  f38e		       a5 9e		      lda	temp3
   1278  f390		       85 d2		      sta	playfield+46
   1279  f392		       a5 9d		      lda	temp2
   1280  f394		       85 d1		      sta	playfield+45
   1281  f396		       a5 9c		      lda	temp1
   1282  f398		       85 d0		      sta	playfield+44
   1283  f39a					      endif
   1284  f39a					      endif
   1285  f39a				   noshiftdown2
      0  f39a					      RETURN
      1  f39a					      ifnconst	bankswitch
      2  f39a		       60		      rts
      3  f39b				  -	      else
      4  f39b				  -	      jmp	BS_return
      5  f39b					      endif
   1287  f39b
   1288  f39b
   1289  f39b				   notup
   1290  f39b							;down
   1291  f39b		       4a		      lsr
   1292  f39c		       b0 02		      bcs	oneincup
   1293  f39e		       e6 ef		      inc	playfieldpos
   1294  f3a0				   oneincup
   1295  f3a0		       e6 ef		      inc	playfieldpos
   1296  f3a2		       a5 ef		      lda	playfieldpos
   1297  f3a4
   1298  f3a4				  -	      ifconst	pfrowheight
   1299  f3a4				  -	      cmp	#pfrowheight+1
   1300  f3a4					      else
   1301  f3a4					      ifnconst	pfres
   1302  f3a4		       c9 09		      cmp	#9
   1303  f3a6				  -	      else
   1304  f3a6				  -	      cmp	#(96/pfres)+1	; try to come close to the real size
   1305  f3a6					      endif
   1306  f3a6					      endif
   1307  f3a6
   1308  f3a6		       90 3b		      bcc	noshiftdown
   1309  f3a8		       a9 01		      lda	#1
   1310  f3aa		       85 ef		      sta	playfieldpos
   1311  f3ac
   1312  f3ac				  -	      ifconst	pfres
   1313  f3ac				  -	      lda	playfield+pfres*4-1
   1314  f3ac				  -	      sta	temp4
   1315  f3ac				  -	      lda	playfield+pfres*4-2
   1316  f3ac				  -	      sta	temp3
   1317  f3ac				  -	      lda	playfield+pfres*4-3
   1318  f3ac				  -	      sta	temp2
   1319  f3ac				  -	      lda	playfield+pfres*4-4
   1320  f3ac					      else
   1321  f3ac		       a5 d3		      lda	playfield+47
   1322  f3ae		       85 9f		      sta	temp4
   1323  f3b0		       a5 d2		      lda	playfield+46
   1324  f3b2		       85 9e		      sta	temp3
   1325  f3b4		       a5 d1		      lda	playfield+45
   1326  f3b6		       85 9d		      sta	temp2
   1327  f3b8		       a5 d0		      lda	playfield+44
   1328  f3ba					      endif
   1329  f3ba
   1330  f3ba		       85 9c		      sta	temp1
   1331  f3bc
   1332  f3bc				  -	      ifconst	pfres
   1333  f3bc				  -	      ldx	#(pfres-1)*4
   1334  f3bc					      else
   1335  f3bc		       a2 2c		      ldx	#44
   1336  f3be					      endif
   1337  f3be				   down2
   1338  f3be		       b5 a3		      lda	playfield-1,x
   1339  f3c0				  -	      ifconst	superchip
   1340  f3c0				  -	      sta	playfield-125,x
   1341  f3c0				  -	      lda	playfield-2,x
   1342  f3c0				  -	      sta	playfield-126,x
   1343  f3c0				  -	      lda	playfield-3,x
   1344  f3c0				  -	      sta	playfield-127,x
   1345  f3c0				  -	      lda	playfield-4,x
   1346  f3c0				  -	      sta	playfield-128,x
   1347  f3c0					      else
   1348  f3c0		       95 a7		      sta	playfield+3,x
   1349  f3c2		       b5 a2		      lda	playfield-2,x
   1350  f3c4		       95 a6		      sta	playfield+2,x
   1351  f3c6		       b5 a1		      lda	playfield-3,x
   1352  f3c8		       95 a5		      sta	playfield+1,x
   1353  f3ca		       b5 a0		      lda	playfield-4,x
   1354  f3cc		       95 a4		      sta	playfield,x
   1355  f3ce					      endif
   1356  f3ce		       8a		      txa
   1357  f3cf		       cb 04		      sbx	#4
   1358  f3d1		       d0 eb		      bne	down2
   1359  f3d3
   1360  f3d3		       a5 9f		      lda	temp4
   1361  f3d5				  -	      ifconst	superchip
   1362  f3d5				  -	      sta	playfield-125
   1363  f3d5				  -	      lda	temp3
   1364  f3d5				  -	      sta	playfield-126
   1365  f3d5				  -	      lda	temp2
   1366  f3d5				  -	      sta	playfield-127
   1367  f3d5				  -	      lda	temp1
   1368  f3d5				  -	      sta	playfield-128
   1369  f3d5					      else
   1370  f3d5		       85 a7		      sta	playfield+3
   1371  f3d7		       a5 9e		      lda	temp3
   1372  f3d9		       85 a6		      sta	playfield+2
   1373  f3db		       a5 9d		      lda	temp2
   1374  f3dd		       85 a5		      sta	playfield+1
   1375  f3df		       a5 9c		      lda	temp1
   1376  f3e1		       85 a4		      sta	playfield
   1377  f3e3					      endif
   1378  f3e3				   noshiftdown
      0  f3e3					      RETURN
      1  f3e3					      ifnconst	bankswitch
      2  f3e3		       60		      rts
      3  f3e4				  -	      else
      4  f3e4				  -	      jmp	BS_return
      5  f3e4					      endif
   1380  f3e4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1381  f3e4
   1382  f3e4							;standard routines needed for pretty much all games
   1383  f3e4							; just the random number generator is left - maybe we should remove this asm file altogether?
   1384  f3e4							; repositioning code and score pointer setup moved to overscan
   1385  f3e4							; read switches, joysticks now compiler generated (more efficient)
   1386  f3e4
   1387  f3e4				   randomize
   1388  f3e4		       a5 a2		      lda	rand
   1389  f3e6		       4a		      lsr
   1390  f3e7				  -	      ifconst	rand16
   1391  f3e7				  -	      rol	rand16
   1392  f3e7					      endif
   1393  f3e7		       90 02		      bcc	noeor
   1394  f3e9		       49 b4		      eor	#$B4
   1395  f3eb				   noeor
   1396  f3eb		       85 a2		      sta	rand
   1397  f3ed				  -	      ifconst	rand16
   1398  f3ed				  -	      eor	rand16
   1399  f3ed					      endif
      0  f3ed					      RETURN
      1  f3ed					      ifnconst	bankswitch
      2  f3ed		       60		      rts
      3  f3ee				  -	      else
      4  f3ee				  -	      jmp	BS_return
      5  f3ee					      endif
   1401  f3ee							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1402  f3ee
   1403  f3ee				   drawscreen
   1404  f3ee				  -	      ifconst	debugscore
   1405  f3ee				  -	      ldx	#14
   1406  f3ee				  -	      lda	INTIM	; display # cycles left in the score
   1407  f3ee				  -
   1408  f3ee				  -	      ifconst	mincycles
   1409  f3ee				  -	      lda	mincycles
   1410  f3ee				  -	      cmp	INTIM
   1411  f3ee				  -	      lda	mincycles
   1412  f3ee				  -	      bcc	nochange
   1413  f3ee				  -	      lda	INTIM
   1414  f3ee				  -	      sta	mincycles
   1415  f3ee				  -nochange
   1416  f3ee				  -	      endif
   1417  f3ee				  -
   1418  f3ee				  -			; cmp #$2B
   1419  f3ee				  -			; bcs no_cycles_left
   1420  f3ee				  -	      bmi	cycles_left
   1421  f3ee				  -	      ldx	#64
   1422  f3ee				  -	      eor	#$ff	;make negative
   1423  f3ee				  -cycles_left
   1424  f3ee				  -	      stx	scorecolor
   1425  f3ee				  -	      and	#$7f	; clear sign bit
   1426  f3ee				  -	      tax
   1427  f3ee				  -	      lda	scorebcd,x
   1428  f3ee				  -	      sta	score+2
   1429  f3ee				  -	      lda	scorebcd1,x
   1430  f3ee				  -	      sta	score+1
   1431  f3ee				  -	      jmp	done_debugscore
   1432  f3ee				  -scorebcd
   1433  f3ee				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   1434  f3ee				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   1435  f3ee				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   1436  f3ee				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   1437  f3ee				  -scorebcd1
   1438  f3ee				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   1439  f3ee				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   1440  f3ee				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   1441  f3ee				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   1442  f3ee				  -done_debugscore
   1443  f3ee					      endif
   1444  f3ee
   1445  f3ee				  -	      ifconst	debugcycles
   1446  f3ee				  -	      lda	INTIM	; if we go over, it mucks up the background color
   1447  f3ee				  -			; cmp #$2B
   1448  f3ee				  -			; BCC overscan
   1449  f3ee				  -	      bmi	overscan
   1450  f3ee				  -	      sta	COLUBK
   1451  f3ee				  -	      bcs	doneoverscan
   1452  f3ee					      endif
   1453  f3ee
   1454  f3ee				   overscan
   1455  f3ee				  -	      ifconst	interlaced
   1456  f3ee				  -	      PHP
   1457  f3ee				  -	      PLA
   1458  f3ee				  -	      EOR	#4	; flip interrupt bit
   1459  f3ee				  -	      PHA
   1460  f3ee				  -	      PLP
   1461  f3ee				  -	      AND	#4	; isolate the interrupt bit
   1462  f3ee				  -	      TAX		; save it for later
   1463  f3ee					      endif
   1464  f3ee
   1465  f3ee				   overscanloop
   1466  f3ee		       ad 84 02 	      lda	INTIM	;wait for sync
   1467  f3f1		       30 fb		      bmi	overscanloop
   1468  f3f3				   doneoverscan
   1469  f3f3
   1470  f3f3							;do VSYNC
   1471  f3f3
   1472  f3f3				  -	      ifconst	interlaced
   1473  f3f3				  -	      CPX	#4
   1474  f3f3				  -	      BNE	oddframevsync
   1475  f3f3					      endif
   1476  f3f3
   1477  f3f3		       a9 02		      lda	#2
   1478  f3f5		       85 02		      sta	WSYNC
   1479  f3f7		       85 00		      sta	VSYNC
   1480  f3f9		       85 02		      STA	WSYNC
   1481  f3fb		       85 02		      STA	WSYNC
   1482  f3fd		       4a		      lsr
   1483  f3fe		       85 02		      STA	WSYNC
   1484  f400		       85 00		      STA	VSYNC
   1485  f402		       85 01		      sta	VBLANK
   1486  f404					      ifnconst	overscan_time
   1487  f404		       a9 a5		      lda	#37+128
   1488  f406				  -	      else
   1489  f406				  -	      lda	#overscan_time+128
   1490  f406					      endif
   1491  f406		       8d 96 02 	      sta	TIM64T
   1492  f409
   1493  f409				  -	      ifconst	interlaced
   1494  f409				  -	      jmp	postsync
   1495  f409				  -
   1496  f409				  -oddframevsync
   1497  f409				  -	      sta	WSYNC
   1498  f409				  -
   1499  f409				  -	      LDA	($80,X)	; 11 waste
   1500  f409				  -	      LDA	($80,X)	; 11 waste
   1501  f409				  -	      LDA	($80,X)	; 11 waste
   1502  f409				  -
   1503  f409				  -	      lda	#2
   1504  f409				  -	      sta	VSYNC
   1505  f409				  -	      sta	WSYNC
   1506  f409				  -	      sta	WSYNC
   1507  f409				  -	      sta	WSYNC
   1508  f409				  -
   1509  f409				  -	      LDA	($80,X)	; 11 waste
   1510  f409				  -	      LDA	($80,X)	; 11 waste
   1511  f409				  -	      LDA	($80,X)	; 11 waste
   1512  f409				  -
   1513  f409				  -	      lda	#0
   1514  f409				  -	      sta	VSYNC
   1515  f409				  -	      sta	VBLANK
   1516  f409				  -	      ifnconst	overscan_time
   1517  f409				  -	      lda	#37+128
   1518  f409				  -	      else
   1519  f409				  -	      lda	#overscan_time+128
   1520  f409				  -	      endif
   1521  f409				  -	      sta	TIM64T
   1522  f409				  -
   1523  f409				  -postsync
   1524  f409					      endif
   1525  f409
   1526  f409				  -	      ifconst	legacy
   1527  f409				  -	      if	legacy < 100
   1528  f409				  -	      ldx	#4
   1529  f409				  -adjustloop
   1530  f409				  -	      lda	player0x,x
   1531  f409				  -	      sec
   1532  f409				  -	      sbc	#14	;?
   1533  f409				  -	      sta	player0x,x
   1534  f409				  -	      dex
   1535  f409				  -	      bpl	adjustloop
   1536  f409				  -	      endif
   1537  f409					      endif
   1538  f409				  -	      if	((<*)>$e9)&&((<*)<$fa)
   1539  f409				  -	      repeat	($fa-(<*))
   1540  f409				  -	      nop
   1541  f409				  -	      repend
   1542  f409					      endif
   1543  f409		       85 02		      sta	WSYNC
   1544  f40b		       a2 04		      ldx	#4
      0  f40d					      SLEEP	3
      1  f40d				   .CYCLES    SET	3
      2  f40d
      3  f40d				  -	      IF	.CYCLES < 2
      4  f40d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f40d				  -	      ERR
      6  f40d					      ENDIF
      7  f40d
      8  f40d					      IF	.CYCLES & 1
      9  f40d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f40d		       04 00		      nop	0
     11  f40f				  -	      ELSE
     12  f40f				  -	      bit	VSYNC
     13  f40f					      ENDIF
     14  f40f				   .CYCLES    SET	.CYCLES - 3
     15  f40f					      ENDIF
     16  f40f
     17  f40f				  -	      REPEAT	.CYCLES / 2
     18  f40f				  -	      nop
     19  f40f					      REPEND
   1546  f40f				   HorPosLoop		; 5
   1547  f40f		       b5 80		      lda	player0x,X	;+4 9
   1548  f411		       38		      sec		;+2 11
   1549  f412				   DivideLoop
   1550  f412		       e9 0f		      sbc	#15
   1551  f414		       b0 fc		      bcs	DivideLoop	;+4 15
   1552  f416		       95 9c		      sta	temp1,X	;+4 19
   1553  f418		       95 10		      sta	RESP0,X	;+4 23
   1554  f41a		       85 02		      sta	WSYNC
   1555  f41c		       ca		      dex
   1556  f41d		       10 f0		      bpl	HorPosLoop	;+5 5
   1557  f41f							; 4
   1558  f41f
   1559  f41f		       a2 04		      ldx	#4
   1560  f421		       b4 9c		      ldy	temp1,X
   1561  f423		       b9 7f f3 	      lda	repostable-256,Y
   1562  f426		       95 20		      sta	HMP0,X	;+14 18
   1563  f428
   1564  f428		       ca		      dex
   1565  f429		       b4 9c		      ldy	temp1,X
   1566  f42b		       b9 7f f3 	      lda	repostable-256,Y
   1567  f42e		       95 20		      sta	HMP0,X	;+14 32
   1568  f430
   1569  f430		       ca		      dex
   1570  f431		       b4 9c		      ldy	temp1,X
   1571  f433		       b9 7f f3 	      lda	repostable-256,Y
   1572  f436		       95 20		      sta	HMP0,X	;+14 46
   1573  f438
   1574  f438		       ca		      dex
   1575  f439		       b4 9c		      ldy	temp1,X
   1576  f43b		       b9 7f f3 	      lda	repostable-256,Y
   1577  f43e		       95 20		      sta	HMP0,X	;+14 60
   1578  f440
   1579  f440		       ca		      dex
   1580  f441		       b4 9c		      ldy	temp1,X
   1581  f443		       b9 7f f3 	      lda	repostable-256,Y
   1582  f446		       95 20		      sta	HMP0,X	;+14 74
   1583  f448
   1584  f448		       85 02		      sta	WSYNC
   1585  f44a
   1586  f44a		       85 2a		      sta	HMOVE	;+3 3
   1587  f44c
   1588  f44c
   1589  f44c				  -	      ifconst	legacy
   1590  f44c				  -	      if	legacy < 100
   1591  f44c				  -	      ldx	#4
   1592  f44c				  -adjustloop2
   1593  f44c				  -	      lda	player0x,x
   1594  f44c				  -	      clc
   1595  f44c				  -	      adc	#14	;?
   1596  f44c				  -	      sta	player0x,x
   1597  f44c				  -	      dex
   1598  f44c				  -	      bpl	adjustloop2
   1599  f44c				  -	      endif
   1600  f44c					      endif
   1601  f44c
   1602  f44c
   1603  f44c
   1604  f44c
   1605  f44c							;set score pointers
   1606  f44c		       a7 95		      lax	score+2
   1607  f44e		       20 7f f4 	      jsr	scorepointerset
   1608  f451		       84 9b		      sty	scorepointers+5
   1609  f453		       86 98		      stx	scorepointers+2
   1610  f455		       a7 94		      lax	score+1
   1611  f457		       20 7f f4 	      jsr	scorepointerset
   1612  f45a		       84 9a		      sty	scorepointers+4
   1613  f45c		       86 97		      stx	scorepointers+1
   1614  f45e		       a7 93		      lax	score
   1615  f460		       20 7f f4 	      jsr	scorepointerset
   1616  f463		       84 99		      sty	scorepointers+3
   1617  f465		       86 96		      stx	scorepointers
   1618  f467
   1619  f467				   vblk
   1620  f467							; run possible vblank bB code
   1621  f467				  -	      ifconst	vblank_bB_code
   1622  f467				  -	      jsr	vblank_bB_code
   1623  f467					      endif
   1624  f467				   vblk2
   1625  f467		       ad 84 02 	      LDA	INTIM
   1626  f46a		       30 fb		      bmi	vblk2
   1627  f46c		       4c 00 f0 	      jmp	kernel
   1628  f46f
   1629  f46f
   1630  f46f		       80 70 60 50*	      .byte.b	$80,$70,$60,$50,$40,$30,$20,$10,$00
   1631  f478		       f0 e0 d0 c0*	      .byte.b	$F0,$E0,$D0,$C0,$B0,$A0,$90
   1632  f47f				   repostable
   1633  f47f
   1634  f47f				   scorepointerset
   1635  f47f		       29 0f		      and	#$0F
   1636  f481		       0a		      asl
   1637  f482		       0a		      asl
   1638  f483		       0a		      asl
   1639  f484		       69 9c		      adc	#<scoretable
   1640  f486		       a8		      tay
   1641  f487		       8a		      txa
   1642  f488							; and #$F0
   1643  f488							; lsr
   1644  f488		       4b f0		      asr	#$F0
   1645  f48a		       69 9c		      adc	#<scoretable
   1646  f48c		       aa		      tax
   1647  f48d		       60		      rts
   1648  f48e							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1649  f48e
   1650  f48e							; feel free to modify the score graphics - just keep each digit 8 high
   1651  f48e							; and keep the conditional compilation stuff intact
   1652  f48e				  -	      ifconst	ROM2k
   1653  f48e				  -	      ORG	$F7AC-8
   1654  f48e					      else
   1655  f48e				  -	      ifconst	bankswitch
   1656  f48e				  -	      if	bankswitch == 8
   1657  f48e				  -	      ORG	$2F94-bscode_length
   1658  f48e				  -	      RORG	$FF94-bscode_length
   1659  f48e				  -	      endif
   1660  f48e				  -	      if	bankswitch == 16
   1661  f48e				  -	      ORG	$4F94-bscode_length
   1662  f48e				  -	      RORG	$FF94-bscode_length
   1663  f48e				  -	      endif
   1664  f48e				  -	      if	bankswitch == 32
   1665  f48e				  -	      ORG	$8F94-bscode_length
   1666  f48e				  -	      RORG	$FF94-bscode_length
   1667  f48e				  -	      endif
   1668  f48e				  -	      if	bankswitch == 64
   1669  f48e				  -	      ORG	$10F80-bscode_length
   1670  f48e				  -	      RORG	$1FF80-bscode_length
   1671  f48e				  -	      endif
   1672  f48e					      else
   1673  ff9c					      ORG	$FF9C
   1674  ff9c					      endif
   1675  ff9c					      endif
   1676  ff9c
   1677  ff9c							; font equates
   1678  ff9c		       00 01	   .21stcentury =	1
   1679  ff9c		       00 02	   alarmclock =	2
   1680  ff9c		       00 03	   handwritten =	3
   1681  ff9c		       00 04	   interrupted =	4
   1682  ff9c		       00 05	   retroputer =	5
   1683  ff9c		       00 06	   whimsey    =	6
   1684  ff9c		       00 07	   tiny       =	7
   1685  ff9c		       00 08	   hex	      =	8
   1686  ff9c
   1687  ff9c				  -	      ifconst	font
   1688  ff9c				  -	      if	font == hex
   1689  ff9c				  -	      ORG	. - 48
   1690  ff9c				  -	      endif
   1691  ff9c					      endif
   1692  ff9c
   1693  ff9c				   scoretable
   1694  ff9c
   1695  ff9c				  -	      ifconst	font
   1696  ff9c				  -	      if	font == .21stcentury
   1697  ff9c				  -	      include	"score_graphics.asm.21stcentury"
   1698  ff9c				  -	      endif
   1699  ff9c				  -	      if	font == alarmclock
   1700  ff9c				  -	      include	"score_graphics.asm.alarmclock"
   1701  ff9c				  -	      endif
   1702  ff9c				  -	      if	font == handwritten
   1703  ff9c				  -	      include	"score_graphics.asm.handwritten"
   1704  ff9c				  -	      endif
   1705  ff9c				  -	      if	font == interrupted
   1706  ff9c				  -	      include	"score_graphics.asm.interrupted"
   1707  ff9c				  -	      endif
   1708  ff9c				  -	      if	font == retroputer
   1709  ff9c				  -	      include	"score_graphics.asm.retroputer"
   1710  ff9c				  -	      endif
   1711  ff9c				  -	      if	font == whimsey
   1712  ff9c				  -	      include	"score_graphics.asm.whimsey"
   1713  ff9c				  -	      endif
   1714  ff9c				  -	      if	font == tiny
   1715  ff9c				  -	      include	"score_graphics.asm.tiny"
   1716  ff9c				  -	      endif
   1717  ff9c				  -	      if	font == hex
   1718  ff9c				  -	      include	"score_graphics.asm.hex"
   1719  ff9c				  -	      endif
   1720  ff9c					      else		; default font
   1721  ff9c
   1722  ff9c		       3c		      .byte.b	%00111100
   1723  ff9d		       66		      .byte.b	%01100110
   1724  ff9e		       66		      .byte.b	%01100110
   1725  ff9f		       66		      .byte.b	%01100110
   1726  ffa0		       66		      .byte.b	%01100110
   1727  ffa1		       66		      .byte.b	%01100110
   1728  ffa2		       66		      .byte.b	%01100110
   1729  ffa3		       3c		      .byte.b	%00111100
   1730  ffa4
   1731  ffa4		       7e		      .byte.b	%01111110
   1732  ffa5		       18		      .byte.b	%00011000
   1733  ffa6		       18		      .byte.b	%00011000
   1734  ffa7		       18		      .byte.b	%00011000
   1735  ffa8		       18		      .byte.b	%00011000
   1736  ffa9		       38		      .byte.b	%00111000
   1737  ffaa		       18		      .byte.b	%00011000
   1738  ffab		       08		      .byte.b	%00001000
   1739  ffac
   1740  ffac		       7e		      .byte.b	%01111110
   1741  ffad		       60		      .byte.b	%01100000
   1742  ffae		       60		      .byte.b	%01100000
   1743  ffaf		       3c		      .byte.b	%00111100
   1744  ffb0		       06		      .byte.b	%00000110
   1745  ffb1		       06		      .byte.b	%00000110
   1746  ffb2		       46		      .byte.b	%01000110
   1747  ffb3		       3c		      .byte.b	%00111100
   1748  ffb4
   1749  ffb4		       3c		      .byte.b	%00111100
   1750  ffb5		       46		      .byte.b	%01000110
   1751  ffb6		       06		      .byte.b	%00000110
   1752  ffb7		       06		      .byte.b	%00000110
   1753  ffb8		       1c		      .byte.b	%00011100
   1754  ffb9		       06		      .byte.b	%00000110
   1755  ffba		       46		      .byte.b	%01000110
   1756  ffbb		       3c		      .byte.b	%00111100
   1757  ffbc
   1758  ffbc		       0c		      .byte.b	%00001100
   1759  ffbd		       0c		      .byte.b	%00001100
   1760  ffbe		       7e		      .byte.b	%01111110
   1761  ffbf		       4c		      .byte.b	%01001100
   1762  ffc0		       4c		      .byte.b	%01001100
   1763  ffc1		       2c		      .byte.b	%00101100
   1764  ffc2		       1c		      .byte.b	%00011100
   1765  ffc3		       0c		      .byte.b	%00001100
   1766  ffc4
   1767  ffc4		       3c		      .byte.b	%00111100
   1768  ffc5		       46		      .byte.b	%01000110
   1769  ffc6		       06		      .byte.b	%00000110
   1770  ffc7		       06		      .byte.b	%00000110
   1771  ffc8		       3c		      .byte.b	%00111100
   1772  ffc9		       60		      .byte.b	%01100000
   1773  ffca		       60		      .byte.b	%01100000
   1774  ffcb		       7e		      .byte.b	%01111110
   1775  ffcc
   1776  ffcc		       3c		      .byte.b	%00111100
   1777  ffcd		       66		      .byte.b	%01100110
   1778  ffce		       66		      .byte.b	%01100110
   1779  ffcf		       66		      .byte.b	%01100110
   1780  ffd0		       7c		      .byte.b	%01111100
   1781  ffd1		       60		      .byte.b	%01100000
   1782  ffd2		       62		      .byte.b	%01100010
   1783  ffd3		       3c		      .byte.b	%00111100
   1784  ffd4
   1785  ffd4		       30		      .byte.b	%00110000
   1786  ffd5		       30		      .byte.b	%00110000
   1787  ffd6		       30		      .byte.b	%00110000
   1788  ffd7		       18		      .byte.b	%00011000
   1789  ffd8		       0c		      .byte.b	%00001100
   1790  ffd9		       06		      .byte.b	%00000110
   1791  ffda		       42		      .byte.b	%01000010
   1792  ffdb		       3e		      .byte.b	%00111110
   1793  ffdc
   1794  ffdc		       3c		      .byte.b	%00111100
   1795  ffdd		       66		      .byte.b	%01100110
   1796  ffde		       66		      .byte.b	%01100110
   1797  ffdf		       66		      .byte.b	%01100110
   1798  ffe0		       3c		      .byte.b	%00111100
   1799  ffe1		       66		      .byte.b	%01100110
   1800  ffe2		       66		      .byte.b	%01100110
   1801  ffe3		       3c		      .byte.b	%00111100
   1802  ffe4
   1803  ffe4		       3c		      .byte.b	%00111100
   1804  ffe5		       46		      .byte.b	%01000110
   1805  ffe6		       06		      .byte.b	%00000110
   1806  ffe7		       3e		      .byte.b	%00111110
   1807  ffe8		       66		      .byte.b	%01100110
   1808  ffe9		       66		      .byte.b	%01100110
   1809  ffea		       66		      .byte.b	%01100110
   1810  ffeb		       3c		      .byte.b	%00111100
   1811  ffec
   1812  ffec					      ifnconst	DPC_kernel_options
   1813  ffec
   1814  ffec		       00		      .byte.b	%00000000
   1815  ffed		       00		      .byte.b	%00000000
   1816  ffee		       00		      .byte.b	%00000000
   1817  ffef		       00		      .byte.b	%00000000
   1818  fff0		       00		      .byte.b	%00000000
   1819  fff1		       00		      .byte.b	%00000000
   1820  fff2		       00		      .byte.b	%00000000
   1821  fff3		       00		      .byte.b	%00000000
   1822  fff4
   1823  fff4					      endif
   1824  fff4
   1825  fff4					      endif
   1826  fff4
   1827  fff4				  -	      ifconst	ROM2k
   1828  fff4				  -	      ORG	$F7FC
   1829  fff4					      else
   1830  fff4				  -	      ifconst	bankswitch
   1831  fff4				  -	      if	bankswitch == 8
   1832  fff4				  -	      ORG	$2FF4-bscode_length
   1833  fff4				  -	      RORG	$FFF4-bscode_length
   1834  fff4				  -	      endif
   1835  fff4				  -	      if	bankswitch == 16
   1836  fff4				  -	      ORG	$4FF4-bscode_length
   1837  fff4				  -	      RORG	$FFF4-bscode_length
   1838  fff4				  -	      endif
   1839  fff4				  -	      if	bankswitch == 32
   1840  fff4				  -	      ORG	$8FF4-bscode_length
   1841  fff4				  -	      RORG	$FFF4-bscode_length
   1842  fff4				  -	      endif
   1843  fff4				  -	      if	bankswitch == 64
   1844  fff4				  -	      ORG	$10FE0-bscode_length
   1845  fff4				  -	      RORG	$1FFE0-bscode_length
   1846  fff4				  -	      endif
   1847  fff4					      else
   1848  fffc					      ORG	$FFFC
   1849  fffc					      endif
   1850  fffc					      endif
   1851  fffc							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1852  fffc
   1853  fffc							; every bank has this stuff at the same place
   1854  fffc							; this code can switch to/from any bank at any entry point
   1855  fffc							; and can preserve register values
   1856  fffc							; note: lines not starting with a space are not placed in all banks
   1857  fffc							;
   1858  fffc							; line below tells the compiler how long this is - do not remove
   1859  fffc							;size=32
   1860  fffc
   1861  fffc				   begin_bscode
   1862  fffc		       a2 ff		      ldx	#$ff
   1863  fffe				  -	      ifconst	FASTFETCH	; using DPC+
   1864  fffe				  -	      stx	FASTFETCH
   1865  fffe					      endif
   1866  fffe		       9a		      txs
   1867  ffff				  -	      if	bankswitch == 64
   1868  ffff				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1869  ffff				  -	      else
   1870  ffff				  -	      lda	#>(start-1)
   1871  ffff					      endif
   1872  ffff		       48		      pha
   1873  10000			a9 4d		       lda	#<(start-1)
   1874  10002			48		       pha
   1875  10003
   1876  10003				    BS_return
   1877  10003			48		       pha
   1878  10004			8a		       txa
   1879  10005			48		       pha
   1880  10006			ba		       tsx
   1881  10007
   1882  10007				   -	       if	bankswitch != 64
   1883  10007				   -	       lda	4,x	; get high byte of return address
   1884  10007				   -
   1885  10007				   -	       rol
   1886  10007				   -	       rol
   1887  10007				   -	       rol
   1888  10007				   -	       rol
   1889  10007				   -	       and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1890  10007				   -	       tax
   1891  10007				   -	       inx
   1892  10007				   -	       else
   1893  10007				   -	       lda	4,x	; get high byte of return address
   1894  10007				   -	       tay
   1895  10007				   -	       ora	#$10	; change our bank nibble into a valid rom mirror
   1896  10007				   -	       sta	4,x
   1897  10007				   -	       tya
   1898  10007				   -	       lsr
   1899  10007				   -	       lsr
   1900  10007				   -	       lsr
   1901  10007				   -	       lsr
   1902  10007				   -	       tax
   1903  10007				   -	       inx
   1904  10007					       endif
   1905  10007
   1906  10007				    BS_jsr
   1907  10007			bd ff ff	       lda	bankswitch_hotspot-1,x
   1908  1000a			68		       pla
   1909  1000b			aa		       tax
   1910  1000c			68		       pla
   1911  1000d			60		       rts
   1912  1000e				   -	       if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1913  1000e				   -	       echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1914  1000e				   -	       echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1915  1000e					       endif
   1916  1000e							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1917  1000e
   1918  1000e				   -	       ifconst	bankswitch
   1919  1000e				   -	       if	bankswitch == 8
   1920  1000e				   -	       ORG	$2FFC
   1921  1000e				   -	       RORG	$FFFC
   1922  1000e				   -	       endif
   1923  1000e				   -	       if	bankswitch == 16
   1924  1000e				   -	       ORG	$4FFC
   1925  1000e				   -	       RORG	$FFFC
   1926  1000e				   -	       endif
   1927  1000e				   -	       if	bankswitch == 32
   1928  1000e				   -	       ORG	$8FFC
   1929  1000e				   -	       RORG	$FFFC
   1930  1000e				   -	       endif
   1931  1000e				   -	       if	bankswitch == 64
   1932  1000e				   -	       ORG	$10FF0
   1933  1000e				   -	       RORG	$1FFF0
   1934  1000e				   -	       lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   1935  1000e				   -	       ORG	$10FF8
   1936  1000e				   -	       RORG	$1FFF8
   1937  1000e				   -	       ifconst	superchip
   1938  1000e				   -	       .byte	"E","F","S","C"
   1939  1000e				   -	       else
   1940  1000e				   -	       .byte	"E","F","E","F"
   1941  1000e				   -	       endif
   1942  1000e				   -	       ORG	$10FFC
   1943  1000e				   -	       RORG	$1FFFC
   1944  1000e				   -	       endif
   1945  1000e					       else
   1946  1000e				   -	       ifconst	ROM2k
   1947  1000e				   -	       ORG	$F7FC
   1948  1000e					       else
   1949  fffc					      ORG	$FFFC
   1950  fffc					      endif
   1951  fffc					      endif
   1952  fffc		       4e f2		      .word.w	(start & $ffff)
   1953  fffe		       4e f2		      .word.w	(start & $ffff)
