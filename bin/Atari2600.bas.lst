------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\Atari-2600-Game\Atari2600.bas.asm LEVEL 1 PASS 2
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  3000 ????				      include	"vcs.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; VCS.H
      4  3000 ????						; Version 1.05, 13/November/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_VCS =	105
      7  3000 ????
      8  3000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines hardware registers and memory mapping for the
     13  3000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  3000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  3000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  3000 ????						; with your views.  Please contribute, if you think you can improve this
     21  3000 ????						; file!
     22  3000 ????						;
     23  3000 ????						; Latest Revisions...
     24  3000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  3000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  3000 ????						;			    This will allow conditional code to verify VCS.H being
     27  3000 ????						;			    used for code assembly.
     28  3000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  3000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  3000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  3000 ????						;			 readability issue, and binary compatibility with disassembled
     32  3000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  3000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  3000 ????						;			 which was broken by the use of segments in this file, as
     35  3000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  3000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  3000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  3000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  3000 ????						;						   it is safe to leave it undefined, and the base address will
     40  3000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  3000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  3000 ????						;			  - register definitions are now generated through assignment
     43  3000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  3000 ????						;			    address architecture.
     45  3000 ????						; 1.0	22/MAR/2003		Initial release
     46  3000 ????
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????
     50  3000 ????						; TIA_BASE_ADDRESS
     51  3000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  3000 ????						; Normally 0, the base address should (externally, before including this file)
     53  3000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  3000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  3000 ????						; < $40 as a bankswitch.
     56  3000 ????
     57  3000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  3000 ????			  -TIA_BASE_ADDRESS =	0
     59  3000 ????				      ENDIF
     60  3000 ????
     61  3000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  3000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  3000 ????						; *OR* by declaring the label before including this file, eg:
     64  3000 ????						; TIA_BASE_ADDRESS = $40
     65  3000 ????						;   include "vcs.h"
     66  3000 ????
     67  3000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  3000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  3000 ????						; for the mirrored ROM hardware registers.
     70  3000 ????
     71  3000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  3000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  3000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  3000 ????
     75  3000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  3000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  3000 ????				      ENDIF
     78  3000 ????
     79  3000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  3000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  3000 ????				      ENDIF
     82  3000 ????
     83  3000 ????						;-------------------------------------------------------------------------------
     84  3000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  3000 ????				      SEG
    201  3000 ????
    202  3000 ????						; EOF
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\Atari-2600-Game\Atari2600.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  3000 ????				      include	"macro.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; MACRO.H
      4  3000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_MACRO =	105
      7  3000 ????
      8  3000 ????						;
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  3000 ????						; It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  3000 ????						; contents, or would like to add something, please write to me
     19  3000 ????						; (atari2600@taswegian.com) with your contribution.
     20  3000 ????						;
     21  3000 ????						; Latest Revisions...
     22  3000 ????						;
     23  3000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  3000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  3000 ????						;			    used for code assembly.
     26  3000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  3000 ????						;
     28  3000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  3000 ????						;
     30  3000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  3000 ????						;			   (standardised macro for vertical synch code)
     32  3000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  3000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  3000 ????						; 1.0	22/MAR/2003		Initial release
     35  3000 ????
     36  3000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  3000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  3000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  3000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  3000 ????						;   registers and require them to be defined first).
     41  3000 ????
     42  3000 ????						; Available macros...
     43  3000 ????						;   SLEEP n		 - sleep for n cycles
     44  3000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  3000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  3000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????						; SLEEP duration
     50  3000 ????						; Original author: Thomas Jentzsch
     51  3000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  3000 ????						; useful for code where precise timing is required.
     53  3000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  3000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  3000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  3000 ????
     57  3000 ????				      MAC	sleep
     58  3000 ????			   .CYCLES    SET	{1}
     59  3000 ????
     60  3000 ????				      IF	.CYCLES < 2
     61  3000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  3000 ????				      ERR
     63  3000 ????				      ENDIF
     64  3000 ????
     65  3000 ????				      IF	.CYCLES & 1
     66  3000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  3000 ????				      nop	0
     68  3000 ????				      ELSE
     69  3000 ????				      bit	VSYNC
     70  3000 ????				      ENDIF
     71  3000 ????			   .CYCLES    SET	.CYCLES - 3
     72  3000 ????				      ENDIF
     73  3000 ????
     74  3000 ????				      REPEAT	.CYCLES / 2
     75  3000 ????				      nop
     76  3000 ????				      REPEND
     77  3000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  3000 ????
     79  3000 ????						;-------------------------------------------------------------------------------
     80  3000 ????						; VERTICAL_SYNC
     81  3000 ????						; Original author: Manuel Polik
     82  3000 ????						; Inserts the code required for a proper 3 scannline 
     83  3000 ????						; vertical sync sequence
     84  3000 ????						;
     85  3000 ????						; Note: Alters the accumulator
     86  3000 ????						;
     87  3000 ????						; IN:
     88  3000 ????						; OUT: A = 1
     89  3000 ????
     90  3000 ????				      MAC	vertical_sync
     91  3000 ????				      LDA	#$02	; A = VSYNC enable
     92  3000 ????				      STA	WSYNC	; Finish current line
     93  3000 ????				      STA	VSYNC	; Start vertical sync
     94  3000 ????				      STA	WSYNC	; 1st line vertical sync
     95  3000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  3000 ????				      LSR		; A = VSYNC disable
     97  3000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  3000 ????				      STA	VSYNC	; Stop vertical sync
     99  3000 ????				      ENDM
    100  3000 ????
    101  3000 ????						;-------------------------------------------------------------------------------
    102  3000 ????						; CLEAN_START
    103  3000 ????						; Original author: Andrew Davie
    104  3000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  3000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  3000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  3000 ????						; Use as very first section of code on boot (ie: at reset)
    108  3000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  3000 ????
    110  3000 ????				      MAC	clean_start
    111  3000 ????				      sei
    112  3000 ????				      cld
    113  3000 ????
    114  3000 ????				      ldx	#0
    115  3000 ????				      txa
    116  3000 ????				      tay
    117  3000 ????			   .CLEAR_STACK dex
    118  3000 ????				      txs
    119  3000 ????				      pha
    120  3000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  3000 ????
    122  3000 ????				      ENDM
    123  3000 ????
    124  3000 ????						;-------------------------------------------------------
    125  3000 ????						; SET_POINTER
    126  3000 ????						; Original author: Manuel Rotschkar
    127  3000 ????						;
    128  3000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  3000 ????						;
    130  3000 ????						; Usage: SET_POINTER pointer, address
    131  3000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  3000 ????						;
    133  3000 ????						; Note: Alters the accumulator, NZ flags
    134  3000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  3000 ????						; IN 2: absolute address
    136  3000 ????
    137  3000 ????				      MAC	set_pointer
    138  3000 ????			   .POINTER   SET	{1}
    139  3000 ????			   .ADDRESS   SET	{2}
    140  3000 ????
    141  3000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  3000 ????				      STA	.POINTER	; Store in pointer
    143  3000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  3000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  3000 ????
    146  3000 ????				      ENDM
    147  3000 ????
    148  3000 ????						; EOF
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\Atari-2600-Game\Atari2600.bas.asm
------- FILE 2600basic.h LEVEL 2 PASS 2
      0  3000 ????				      include	"2600basic.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????				      processor	6502
------- FILE vcs.h LEVEL 3 PASS 2
      0  3000 ????				      include	"vcs.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; VCS.H
      4  3000 ????						; Version 1.05, 13/November/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_VCS =	105
      7  3000 ????
      8  3000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines hardware registers and memory mapping for the
     13  3000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  3000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  3000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  3000 ????						; with your views.  Please contribute, if you think you can improve this
     21  3000 ????						; file!
     22  3000 ????						;
     23  3000 ????						; Latest Revisions...
     24  3000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  3000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  3000 ????						;			    This will allow conditional code to verify VCS.H being
     27  3000 ????						;			    used for code assembly.
     28  3000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  3000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  3000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  3000 ????						;			 readability issue, and binary compatibility with disassembled
     32  3000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  3000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  3000 ????						;			 which was broken by the use of segments in this file, as
     35  3000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  3000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  3000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  3000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  3000 ????						;						   it is safe to leave it undefined, and the base address will
     40  3000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  3000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  3000 ????						;			  - register definitions are now generated through assignment
     43  3000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  3000 ????						;			    address architecture.
     45  3000 ????						; 1.0	22/MAR/2003		Initial release
     46  3000 ????
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????
     50  3000 ????						; TIA_BASE_ADDRESS
     51  3000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  3000 ????						; Normally 0, the base address should (externally, before including this file)
     53  3000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  3000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  3000 ????						; < $40 as a bankswitch.
     56  3000 ????
     57  3000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  3000 ????			  -TIA_BASE_ADDRESS =	0
     59  3000 ????				      ENDIF
     60  3000 ????
     61  3000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  3000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  3000 ????						; *OR* by declaring the label before including this file, eg:
     64  3000 ????						; TIA_BASE_ADDRESS = $40
     65  3000 ????						;   include "vcs.h"
     66  3000 ????
     67  3000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  3000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  3000 ????						; for the mirrored ROM hardware registers.
     70  3000 ????
     71  3000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  3000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  3000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  3000 ????
     75  3000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  3000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  3000 ????				      ENDIF
     78  3000 ????
     79  3000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  3000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  3000 ????				      ENDIF
     82  3000 ????
     83  3000 ????						;-------------------------------------------------------------------------------
     84  3000 ????
     85 U002d					      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e					      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298					      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  3000 ????				      SEG
    201  3000 ????
    202  3000 ????						; EOF
------- FILE 2600basic.h
------- FILE macro.h LEVEL 3 PASS 2
      0  3000 ????				      include	"macro.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; MACRO.H
      4  3000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_MACRO =	105
      7  3000 ????
      8  3000 ????						;
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  3000 ????						; It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  3000 ????						; contents, or would like to add something, please write to me
     19  3000 ????						; (atari2600@taswegian.com) with your contribution.
     20  3000 ????						;
     21  3000 ????						; Latest Revisions...
     22  3000 ????						;
     23  3000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  3000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  3000 ????						;			    used for code assembly.
     26  3000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  3000 ????						;
     28  3000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  3000 ????						;
     30  3000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  3000 ????						;			   (standardised macro for vertical synch code)
     32  3000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  3000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  3000 ????						; 1.0	22/MAR/2003		Initial release
     35  3000 ????
     36  3000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  3000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  3000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  3000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  3000 ????						;   registers and require them to be defined first).
     41  3000 ????
     42  3000 ????						; Available macros...
     43  3000 ????						;   SLEEP n		 - sleep for n cycles
     44  3000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  3000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  3000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????						; SLEEP duration
     50  3000 ????						; Original author: Thomas Jentzsch
     51  3000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  3000 ????						; useful for code where precise timing is required.
     53  3000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  3000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  3000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  3000 ????
     57  3000 ????				      MAC	sleep
     58  3000 ????			   .CYCLES    SET	{1}
     59  3000 ????
     60  3000 ????				      IF	.CYCLES < 2
     61  3000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  3000 ????				      ERR
     63  3000 ????				      ENDIF
     64  3000 ????
     65  3000 ????				      IF	.CYCLES & 1
     66  3000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  3000 ????				      nop	0
     68  3000 ????				      ELSE
     69  3000 ????				      bit	VSYNC
     70  3000 ????				      ENDIF
     71  3000 ????			   .CYCLES    SET	.CYCLES - 3
     72  3000 ????				      ENDIF
     73  3000 ????
     74  3000 ????				      REPEAT	.CYCLES / 2
     75  3000 ????				      nop
     76  3000 ????				      REPEND
     77  3000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  3000 ????
     79  3000 ????						;-------------------------------------------------------------------------------
     80  3000 ????						; VERTICAL_SYNC
     81  3000 ????						; Original author: Manuel Polik
     82  3000 ????						; Inserts the code required for a proper 3 scannline 
     83  3000 ????						; vertical sync sequence
     84  3000 ????						;
     85  3000 ????						; Note: Alters the accumulator
     86  3000 ????						;
     87  3000 ????						; IN:
     88  3000 ????						; OUT: A = 1
     89  3000 ????
     90  3000 ????				      MAC	vertical_sync
     91  3000 ????				      LDA	#$02	; A = VSYNC enable
     92  3000 ????				      STA	WSYNC	; Finish current line
     93  3000 ????				      STA	VSYNC	; Start vertical sync
     94  3000 ????				      STA	WSYNC	; 1st line vertical sync
     95  3000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  3000 ????				      LSR		; A = VSYNC disable
     97  3000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  3000 ????				      STA	VSYNC	; Stop vertical sync
     99  3000 ????				      ENDM
    100  3000 ????
    101  3000 ????						;-------------------------------------------------------------------------------
    102  3000 ????						; CLEAN_START
    103  3000 ????						; Original author: Andrew Davie
    104  3000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  3000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  3000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  3000 ????						; Use as very first section of code on boot (ie: at reset)
    108  3000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  3000 ????
    110  3000 ????				      MAC	clean_start
    111  3000 ????				      sei
    112  3000 ????				      cld
    113  3000 ????
    114  3000 ????				      ldx	#0
    115  3000 ????				      txa
    116  3000 ????				      tay
    117  3000 ????			   .CLEAR_STACK dex
    118  3000 ????				      txs
    119  3000 ????				      pha
    120  3000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  3000 ????
    122  3000 ????				      ENDM
    123  3000 ????
    124  3000 ????						;-------------------------------------------------------
    125  3000 ????						; SET_POINTER
    126  3000 ????						; Original author: Manuel Rotschkar
    127  3000 ????						;
    128  3000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  3000 ????						;
    130  3000 ????						; Usage: SET_POINTER pointer, address
    131  3000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  3000 ????						;
    133  3000 ????						; Note: Alters the accumulator, NZ flags
    134  3000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  3000 ????						; IN 2: absolute address
    136  3000 ????
    137  3000 ????				      MAC	set_pointer
    138  3000 ????			   .POINTER   SET	{1}
    139  3000 ????			   .ADDRESS   SET	{2}
    140  3000 ????
    141  3000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  3000 ????				      STA	.POINTER	; Store in pointer
    143  3000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  3000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  3000 ????
    146  3000 ????				      ENDM
    147  3000 ????
    148  3000 ????						; EOF
------- FILE 2600basic.h
------- FILE 2600basic_variable_redefs.h LEVEL 3 PASS 2
      0  3000 ????				      include	"2600basic_variable_redefs.h"
      1  3000 ????						; This file contains variable mapping and other information for the current project.
      2  3000 ????
      3  3000 ????	       00 20	   bscode_length =	32
      4  3000 ????	       00 01	   bs_mask    =	1
      5  3000 ????	       00 08	   bankswitch =	8
      6  3000 ????	       1f f8	   bankswitch_hotspot =	$1FF8
------- FILE 2600basic.h
      7  3000 ????
      8  3000 ????	       00 80	   player0x   =	$80
      9  3000 ????	       00 81	   player1x   =	$81
     10  3000 ????	       00 82	   missile0x  =	$82
     11  3000 ????	       00 83	   missile1x  =	$83
     12  3000 ????	       00 84	   ballx      =	$84
     13  3000 ????
     14  3000 ????	       00 85	   objecty    =	$85
     15  3000 ????	       00 85	   player0y   =	$85
     16  3000 ????	       00 86	   player1y   =	$86
     17  3000 ????	       00 87	   missile1height =	$87
     18  3000 ????	       00 88	   missile1y  =	$88
     19  3000 ????	       00 89	   bally      =	$89
     20  3000 ????
     21  3000 ????	       00 87	   player1color =	$87	; replaces missile 1
     22  3000 ????
     23  3000 ????	       00 8a	   player0pointer =	$8A	;uses $8A-$8B
     24  3000 ????	       00 8a	   player0pointerlo =	$8A
     25  3000 ????	       00 8b	   player0pointerhi =	$8B
     26  3000 ????	       00 8c	   player1pointer =	$8C	; $8C-$8D
     27  3000 ????	       00 8c	   player1pointerlo =	$8C
     28  3000 ????	       00 8d	   player1pointerhi =	$8D
     29  3000 ????
     30  3000 ????	       00 8e	   player0height =	$8E
     31  3000 ????	       00 8f	   player1height =	$8F
     32  3000 ????	       00 90	   missile0height =	$90
     33  3000 ????	       00 91	   missile0y  =	$91
     34  3000 ????	       00 92	   ballheight =	$92
     35  3000 ????
     36  3000 ????	       00 90	   currentpaddle =	$90	; replaces missile 0 (and can't be used with playercolor)
     37  3000 ????	       00 91	   paddle     =	$91	; replaces missile 0
     38  3000 ????	       00 82	   player0colorstore =	$82	; replaces missile 0
     39  3000 ????	       00 90	   player0color =	$90	; replaces missile 0
     40  3000 ????
     41  3000 ????	       00 93	   score      =	$93	; $93-$95
     42  3000 ????	       00 96	   scorepointers =	$96	; $96-$9B = 6 bytes
     43  3000 ????	       00 9c	   temp1      =	$9C	;used by kernel.  can be used in program too, but
     44  3000 ????	       00 9d	   temp2      =	$9D	;are obliterated when drawscreen is called.
     45  3000 ????	       00 9e	   temp3      =	$9E
     46  3000 ????	       00 9f	   temp4      =	$9F
     47  3000 ????	       00 a0	   temp5      =	$A0
     48  3000 ????	       00 a1	   temp6      =	$A1
     49  3000 ????
     50  3000 ????	       00 a2	   rand       =	$A2
     51  3000 ????	       00 a3	   scorecolor =	$A3
     52  3000 ????
     53  3000 ????	       00 a4	   var0       =	$A4
     54  3000 ????	       00 a5	   var1       =	$A5
     55  3000 ????	       00 a6	   var2       =	$A6
     56  3000 ????	       00 a7	   var3       =	$A7
     57  3000 ????	       00 a8	   var4       =	$A8
     58  3000 ????	       00 a9	   var5       =	$A9
     59  3000 ????	       00 aa	   var6       =	$AA
     60  3000 ????	       00 ab	   var7       =	$AB
     61  3000 ????	       00 ac	   var8       =	$AC
     62  3000 ????	       00 ad	   var9       =	$AD
     63  3000 ????	       00 ae	   var10      =	$AE
     64  3000 ????	       00 af	   var11      =	$AF
     65  3000 ????	       00 b0	   var12      =	$B0
     66  3000 ????	       00 b1	   var13      =	$B1
     67  3000 ????	       00 b2	   var14      =	$B2
     68  3000 ????	       00 b3	   var15      =	$B3
     69  3000 ????	       00 b4	   var16      =	$B4
     70  3000 ????	       00 b5	   var17      =	$B5
     71  3000 ????	       00 b6	   var18      =	$B6
     72  3000 ????	       00 b7	   var19      =	$B7
     73  3000 ????	       00 b8	   var20      =	$B8
     74  3000 ????	       00 b9	   var21      =	$B9
     75  3000 ????	       00 ba	   var22      =	$BA
     76  3000 ????	       00 bb	   var23      =	$BB
     77  3000 ????	       00 bc	   var24      =	$BC
     78  3000 ????	       00 bd	   var25      =	$BD
     79  3000 ????	       00 be	   var26      =	$BE
     80  3000 ????	       00 bf	   var27      =	$BF
     81  3000 ????	       00 c0	   var28      =	$C0
     82  3000 ????	       00 c1	   var29      =	$C1
     83  3000 ????	       00 c2	   var30      =	$C2
     84  3000 ????	       00 c3	   var31      =	$C3
     85  3000 ????	       00 c4	   var32      =	$C4
     86  3000 ????	       00 c5	   var33      =	$C5
     87  3000 ????	       00 c6	   var34      =	$C6
     88  3000 ????	       00 c7	   var35      =	$C7
     89  3000 ????	       00 c8	   var36      =	$C8
     90  3000 ????	       00 c9	   var37      =	$C9
     91  3000 ????	       00 ca	   var38      =	$CA
     92  3000 ????	       00 cb	   var39      =	$CB
     93  3000 ????	       00 cc	   var40      =	$CC
     94  3000 ????	       00 cd	   var41      =	$CD
     95  3000 ????	       00 ce	   var42      =	$CE
     96  3000 ????	       00 cf	   var43      =	$CF
     97  3000 ????	       00 d0	   var44      =	$D0
     98  3000 ????	       00 d1	   var45      =	$D1
     99  3000 ????	       00 d2	   var46      =	$D2
    100  3000 ????	       00 d3	   var47      =	$D3
    101  3000 ????
    102  3000 ????	       00 d4	   A	      =	$d4
    103  3000 ????	       00 d4	   a	      =	$d4
    104  3000 ????	       00 d5	   B	      =	$d5
    105  3000 ????	       00 d5	   b	      =	$d5
    106  3000 ????	       00 d6	   C	      =	$d6
    107  3000 ????	       00 d6	   c	      =	$d6
    108  3000 ????	       00 d7	   D	      =	$d7
    109  3000 ????	       00 d7	   d	      =	$d7
    110  3000 ????	       00 d8	   E	      =	$d8
    111  3000 ????	       00 d8	   e	      =	$d8
    112  3000 ????	       00 d9	   F	      =	$d9
    113  3000 ????	       00 d9	   f	      =	$d9
    114  3000 ????	       00 da	   G	      =	$da
    115  3000 ????	       00 da	   g	      =	$da
    116  3000 ????	       00 db	   H	      =	$db
    117  3000 ????	       00 db	   h	      =	$db
    118  3000 ????	       00 dc	   I	      =	$dc
    119  3000 ????	       00 dc	   i	      =	$dc
    120  3000 ????	       00 dd	   J	      =	$dd
    121  3000 ????	       00 dd	   j	      =	$dd
    122  3000 ????	       00 de	   K	      =	$de
    123  3000 ????	       00 de	   k	      =	$de
    124  3000 ????	       00 df	   L	      =	$df
    125  3000 ????	       00 df	   l	      =	$df
    126  3000 ????	       00 e0	   M	      =	$e0
    127  3000 ????	       00 e0	   m	      =	$e0
    128  3000 ????	       00 e1	   N	      =	$e1
    129  3000 ????	       00 e1	   n	      =	$e1
    130  3000 ????	       00 e2	   O	      =	$e2
    131  3000 ????	       00 e2	   o	      =	$e2
    132  3000 ????	       00 e3	   P	      =	$e3
    133  3000 ????	       00 e3	   p	      =	$e3
    134  3000 ????	       00 e4	   Q	      =	$e4
    135  3000 ????	       00 e4	   q	      =	$e4
    136  3000 ????	       00 e5	   R	      =	$e5
    137  3000 ????	       00 e5	   r	      =	$e5
    138  3000 ????	       00 e6	   S	      =	$e6
    139  3000 ????	       00 e6	   s	      =	$e6
    140  3000 ????	       00 e7	   T	      =	$e7
    141  3000 ????	       00 e7	   t	      =	$e7
    142  3000 ????	       00 e8	   U	      =	$e8
    143  3000 ????	       00 e8	   u	      =	$e8
    144  3000 ????	       00 e9	   V	      =	$e9
    145  3000 ????	       00 e9	   v	      =	$e9
    146  3000 ????	       00 ea	   W	      =	$ea
    147  3000 ????	       00 ea	   w	      =	$ea
    148  3000 ????	       00 eb	   X	      =	$eb
    149  3000 ????	       00 eb	   x	      =	$eb
    150  3000 ????	       00 ec	   Y	      =	$ec
    151  3000 ????	       00 ec	   y	      =	$ec
    152  3000 ????	       00 ed	   Z	      =	$ed
    153  3000 ????	       00 ed	   z	      =	$ed
    154  3000 ????
    155  3000 ????	       00 ee	   temp7      =	$ee	; This is used to aid in bankswitching
    156  3000 ????	       00 ef	   playfieldpos =	$ef
    157  3000 ????
    158  3000 ????						; available for other uses, or if unused, provide more stack space
    159  3000 ????
    160  3000 ????	       00 f0	   aux1       =	$f0
    161  3000 ????	       00 f1	   aux2       =	$f1
    162  3000 ????	       00 f2	   aux3       =	$f2
    163  3000 ????	       00 f3	   aux4       =	$f3
    164  3000 ????	       00 f4	   aux5       =	$f4
    165  3000 ????	       00 f5	   aux6       =	$f5
    166  3000 ????
    167  3000 ????						; playfield color/height pointers
    168  3000 ????	       00 f0	   pfcolortable =	$f0	; and $d5
    169  3000 ????	       00 f0	   pfheighttable =	$f0	; and $d5
    170  3000 ????						; the above pointers are the same because if color and height are both used together,
    171  3000 ????						; they must used absolute indexed and cannot use pointers
    172  3000 ????
    173  3000 ????	       00 f2	   lifepointer =	$f2	; pointer to "lives" shape
    174  3000 ????						; upper 3 bits of $f2 contain the number of lives
    175  3000 ????	       00 f4	   lifecolor  =	$f4
    176  3000 ????	       00 f3	   lives      =	$f3	; # lives >> 5
    177  3000 ????	       00 f5	   statusbarlength =	$f5	; only uses upper 5 bits; other bits free
    178  3000 ????
    179  3000 ????	       00 f2	   pfscore1   =	$f2	; optional playfield bytes in score
    180  3000 ????	       00 f3	   pfscore2   =	$f3
    181  3000 ????	       00 f4	   pfscorecolor =	$f4
    182  3000 ????
    183  3000 ????	       00 f6	   stack1     =	$f6
    184  3000 ????	       00 f7	   stack2     =	$f7
    185  3000 ????	       00 f8	   stack3     =	$f8
    186  3000 ????	       00 f9	   stack4     =	$f9
    187  3000 ????						; the stack bytes above may be used in the kernel
    188  3000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    189  3000 ????
    190  3000 ????				      MAC	return
    191  3000 ????				      ifnconst	bankswitch
    192  3000 ????				      rts
    193  3000 ????				      else
    194  3000 ????				      jmp	BS_return
    195  3000 ????				      endif
    196  3000 ????				      ENDM		; auto-return from either a regular or bankswitched module
    197  3000 ????
    198  3000 ????			  -	      ifconst	superchip
    199  3000 ????			  -playfieldbase =	$10D0
    200  3000 ????			  -	      include	superchip.h
    201  3000 ????				      else
    202  3000 ????	       00 a4	   playfieldbase =	$A4
    203  3000 ????				      endif
    204  3000 ????
    205  3000 ????				      ifnconst	pfhalfwidth
    206  3000 ????	       00 04	   pfwidth    =	4
    207  3000 ????	       00 0e	   PF1L       =	PF1
    208  3000 ????	       00 0f	   PF2L       =	PF2
    209  3000 ????	       00 0e	   PF1R       =	PF1
    210  3000 ????	       00 0f	   PF2R       =	PF2
    211  3000 ????	       00 00	   pfadjust   =	0
    212  3000 ????			  -	      else
    213  3000 ????			  -pfwidth    =	2
    214  3000 ????			  -	      ifconst	pfcenter
    215  3000 ????			  -PF1L       =	$3F	; no effect
    216  3000 ????			  -PF2L       =	PF2
    217  3000 ????			  -PF1R       =	$3F
    218  3000 ????			  -PF2R       =	PF2	; no effect
    219  3000 ????			  -pfadjust   =	1
    220  3000 ????			  -	      else
    221  3000 ????			  -PF1L       =	PF1
    222  3000 ????			  -PF2L       =	PF2
    223  3000 ????			  -PF1R       =	$3F	; no effect
    224  3000 ????			  -PF2R       =	$3F	; no effect
    225  3000 ????			  -pfadjust   =	0
    226  3000 ????			  -	      endif
    227  3000 ????				      endif
    228  3000 ????
    229  3000 ????						; define playfield start based on height
    230  3000 ????				      ifnconst	pfres
    231  3000 ????	       00 a4	   playfield  =	playfieldbase
    232  3000 ????			  -	      else
    233  3000 ????			  -playfield  =	playfieldbase-(pfres-12*(4/pfwidth))*pfwidth
    234  3000 ????				      endif
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\Atari-2600-Game\Atari2600.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  3000 ????				      include	"2600basic_variable_redefs.h"
      1  3000 ????						; This file contains variable mapping and other information for the current project.
      2  3000 ????
      3  3000 ????	       00 20	   bscode_length =	32
      4  3000 ????	       00 01	   bs_mask    =	1
      5  3000 ????	       00 08	   bankswitch =	8
      6  3000 ????	       1f f8	   bankswitch_hotspot =	$1FF8
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\Atari-2600-Game\Atari2600.bas.asm
      8  3000 ????				      ifconst	bankswitch
      9  3000 ????				      if	bankswitch == 8
     10  1000					      ORG	$1000
     11  1000					      RORG	$D000
     12  1000					      endif
     13  1000				  -	      if	bankswitch == 16
     14  1000				  -	      ORG	$1000
     15  1000				  -	      RORG	$9000
     16  1000					      endif
     17  1000				  -	      if	bankswitch == 32
     18  1000				  -	      ORG	$1000
     19  1000				  -	      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000
     29  1000					      ifconst	bankswitch_hotspot
     30  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  1000				  -	      .byte	0	; stop unexpected bankswitches
     32  1000					      endif
     33  1000					      endif
     34  1000				   game
     35  1000				   .L00 		;  set romsize 8k
     36  1000
     37  1000				   .
     38  1000							; 
     39  1000
     40  1000				   .L01 		;  
     41  1000					      if	ECHO1
      4052 bytes of ROM space left in bank 1
     42  1000					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
     43  1000					      endif
     44  1000		       00 01	   ECHO1      =	1
     45  1fd4					      ORG	$1FF4-bscode_length
     46  1fd4					      RORG	$DFF4-bscode_length
     47  1fd4		       a2 ff	   start_bank1 ldx	#$ff
     48  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
     49  1fd6				  -	      stx	FASTFETCH
     50  1fd6					      endif
     51  1fd6		       9a		      txs
     52  1fd7				  -	      if	bankswitch == 64
     53  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
     54  1fd7					      else
     55  1fd7		       a9 f2		      lda	#>(start-1)
     56  1fd9					      endif
     57  1fd9		       48		      pha
     58  1fda		       a9 4f		      lda	#<(start-1)
     59  1fdc		       48		      pha
     60  1fdd		       48		      pha
     61  1fde		       8a		      txa
     62  1fdf		       48		      pha
     63  1fe0		       ba		      tsx
     64  1fe1					      if	bankswitch != 64
     65  1fe1		       b5 04		      lda	4,x	; get high byte of return address
     66  1fe3		       2a		      rol
     67  1fe4		       2a		      rol
     68  1fe5		       2a		      rol
     69  1fe6		       2a		      rol
     70  1fe7		       29 01		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
     71  1fe9		       aa		      tax
     72  1fea		       e8		      inx
     73  1feb				  -	      else
     74  1feb				  -	      lda	4,x	; get high byte of return address
     75  1feb				  -	      tay
     76  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
     77  1feb				  -	      sta	4,x
     78  1feb				  -	      tya
     79  1feb				  -	      lsr
     80  1feb				  -	      lsr
     81  1feb				  -	      lsr
     82  1feb				  -	      lsr
     83  1feb				  -	      tax
     84  1feb				  -	      inx
     85  1feb					      endif
     86  1feb		       bd f7 1f 	      lda	bankswitch_hotspot-1,x
     87  1fee		       68		      pla
     88  1fef		       aa		      tax
     89  1ff0		       68		      pla
     90  1ff1		       60		      rts
     91  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
     92  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
     93  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
     94  1ff2					      endif
     95  1ffc					      ORG	$1FFC
     96  1ffc					      RORG	$DFFC
     97  1ffc		       d4 df		      .word.w	(start_bank1 & $ffff)
     98  1ffe		       d4 df		      .word.w	(start_bank1 & $ffff)
     99  2000					      ORG	$2000
    100  2000					      RORG	$F000
    101  2000							; Provided under the CC0 license. See the included LICENSE.txt for details.
    102  2000
    103  2000							; This is a 2-line kernel!
    104  2000					      ifnconst	vertical_reflect
    105  2000				   kernel
    106  2000					      endif
    107  2000		       85 02		      sta	WSYNC
    108  2002		       a9 ff		      lda	#255
    109  2004		       8d 96 02 	      sta	TIM64T
    110  2007
    111  2007		       a9 01		      lda	#1
    112  2009		       85 27		      sta	VDELBL
    113  200b		       85 25		      sta	VDELP0
    114  200d		       a6 92		      ldx	ballheight
    115  200f		       e8		      inx
    116  2010		       e8		      inx
    117  2011		       86 9f		      stx	temp4
    118  2013		       a5 86		      lda	player1y
    119  2015		       85 9e		      sta	temp3
    120  2017
    121  2017				  -	      ifconst	shakescreen
    122  2017				  -	      jsr	doshakescreen
    123  2017					      else
    124  2017		       a6 90		      ldx	missile0height
    125  2019		       e8		      inx
    126  201a					      endif
    127  201a
    128  201a		       e8		      inx
    129  201b		       86 f6		      stx	stack1
    130  201d
    131  201d		       a5 89		      lda	bally
    132  201f		       85 f7		      sta	stack2
    133  2021
    134  2021		       a5 85		      lda	player0y
    135  2023		       a2 00		      ldx	#0
    136  2025		       85 02		      sta	WSYNC
    137  2027		       86 1b		      stx	GRP0
    138  2029		       86 1c		      stx	GRP1
    139  202b		       86 0e		      stx	PF1L
    140  202d		       86 0f		      stx	PF2
    141  202f		       86 2c		      stx	CXCLR
    142  2031				  -	      ifconst	readpaddle
    143  2031				  -	      stx	paddle
    144  2031					      else
      0  2031					      sleep	3
      1  2031				   .CYCLES    SET	3
      2  2031
      3  2031				  -	      IF	.CYCLES < 2
      4  2031				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2031				  -	      ERR
      6  2031					      ENDIF
      7  2031
      8  2031					      IF	.CYCLES & 1
      9  2031					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2031		       04 00		      nop	0
     11  2033				  -	      ELSE
     12  2033				  -	      bit	VSYNC
     13  2033					      ENDIF
     14  2033				   .CYCLES    SET	.CYCLES - 3
     15  2033					      ENDIF
     16  2033
     17  2033				  -	      REPEAT	.CYCLES / 2
     18  2033				  -	      nop
     19  2033					      REPEND
    146  2033					      endif
    147  2033
    148  2033		       95 9d		      sta	temp2,x
    149  2035
    150  2035							;store these so they can be retrieved later
    151  2035					      ifnconst	pfres
    152  2035		       a2 54		      ldx	#128-44+(4-pfwidth)*12
    153  2037				  -	      else
    154  2037				  -	      ldx	#132-pfres*pfwidth
    155  2037					      endif
    156  2037
    157  2037		       c6 85		      dec	player0y
    158  2039
    159  2039		       a5 91		      lda	missile0y
    160  203b		       85 a0		      sta	temp5
    161  203d		       a5 88		      lda	missile1y
    162  203f		       85 a1		      sta	temp6
    163  2041
    164  2041		       a5 ef		      lda	playfieldpos
    165  2043		       85 9c		      sta	temp1
    166  2045
    167  2045				  -	      ifconst	pfrowheight
    168  2045				  -	      lda	#pfrowheight+2
    169  2045					      else
    170  2045					      ifnconst	pfres
    171  2045		       a9 0a		      lda	#10
    172  2047				  -	      else
    173  2047				  -	      lda	#(96/pfres)+2	; try to come close to the real size
    174  2047					      endif
    175  2047					      endif
    176  2047		       18		      clc
    177  2048		       e5 ef		      sbc	playfieldpos
    178  204a		       85 ef		      sta	playfieldpos
    179  204c		       4c 74 f0 	      jmp	.startkernel
    180  204f
    181  204f				   .skipDrawP0
    182  204f		       a9 00		      lda	#0
    183  2051		       a8		      tay
    184  2052		       4c a2 f0 	      jmp	.continueP0
    185  2055
    186  2055				   .skipDrawP1
    187  2055		       a9 00		      lda	#0
    188  2057		       a8		      tay
    189  2058		       4c 7e f0 	      jmp	.continueP1
    190  205b
    191  205b				   .kerloop		; enter at cycle 59??
    192  205b
    193  205b				   continuekernel
      0  205b					      sleep	2
      1  205b				   .CYCLES    SET	2
      2  205b
      3  205b				  -	      IF	.CYCLES < 2
      4  205b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  205b				  -	      ERR
      6  205b					      ENDIF
      7  205b
      8  205b				  -	      IF	.CYCLES & 1
      9  205b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  205b				  -	      nop	0
     11  205b				  -	      ELSE
     12  205b				  -	      bit	VSYNC
     13  205b				  -	      ENDIF
     14  205b				  -.CYCLES    SET	.CYCLES - 3
     15  205b					      ENDIF
     16  205b
     17  205b					      REPEAT	.CYCLES / 2
     18  205b		       ea		      nop
     19  205c					      REPEND
    195  205c				   continuekernel2
    196  205c		       a5 92		      lda	ballheight
    197  205e
    198  205e				  -	      ifconst	pfres
    199  205e				  -	      ldy	playfield+pfres*pfwidth-132,x
    200  205e				  -	      sty	PF1L	;3
    201  205e				  -	      ldy	playfield+pfres*pfwidth-131-pfadjust,x
    202  205e				  -	      sty	PF2L	;3
    203  205e				  -	      ldy	playfield+pfres*pfwidth-129,x
    204  205e				  -	      sty	PF1R	; 3 too early?
    205  205e				  -	      ldy	playfield+pfres*pfwidth-130-pfadjust,x
    206  205e				  -	      sty	PF2R	;3
    207  205e					      else
    208  205e		       b4 50		      ldy	playfield-48+pfwidth*12+44-128,x
    209  2060		       84 0e		      sty	PF1L	;3
    210  2062		       b4 51		      ldy	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
    211  2064		       84 0f		      sty	PF2L	;3
    212  2066		       b4 53		      ldy	playfield-48+pfwidth*12+47-128,x	;4
    213  2068		       84 0e		      sty	PF1R	; 3 too early?
    214  206a		       b4 52		      ldy	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
    215  206c		       84 0f		      sty	PF2R	;3
    216  206e					      endif
    217  206e
    218  206e							; should be playfield+$38 for width=2
    219  206e
    220  206e		       c7 89		      dcp	bally
    221  2070		       2a		      rol
    222  2071		       2a		      rol
    223  2072							; rol
    224  2072							; rol
    225  2072				   goback
    226  2072		       85 1f		      sta	ENABL
    227  2074				   .startkernel
    228  2074		       a5 8f		      lda	player1height	;3
    229  2076		       c7 86		      dcp	player1y	;5
    230  2078		       90 db		      bcc	.skipDrawP1	;2
    231  207a		       a4 86		      ldy	player1y	;3
    232  207c		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
    233  207e							; so it doesn't cross a page boundary!
    234  207e
    235  207e				   .continueP1
    236  207e		       85 1c		      sta	GRP1	;3
    237  2080
    238  2080					      ifnconst	player1colors
    239  2080		       a5 87		      lda	missile1height	;3
    240  2082		       c7 88		      dcp	missile1y	;5
    241  2084		       2a		      rol		;2
    242  2085		       2a		      rol		;2
    243  2086		       85 1e		      sta	ENAM1	;3
    244  2088				  -	      else
    245  2088				  -	      lda	(player1color),y
    246  2088				  -	      sta	COLUP1
    247  2088				  -	      ifnconst	playercolors
    248  2088				  -	      sleep	7
    249  2088				  -	      else
    250  2088				  -	      lda.w	player0colorstore
    251  2088				  -	      sta	COLUP0
    252  2088				  -	      endif
    253  2088					      endif
    254  2088
    255  2088				  -	      ifconst	pfres
    256  2088				  -	      lda	playfield+pfres*pfwidth-132,x
    257  2088				  -	      sta	PF1L	;3
    258  2088				  -	      lda	playfield+pfres*pfwidth-131-pfadjust,x
    259  2088				  -	      sta	PF2L	;3
    260  2088				  -	      lda	playfield+pfres*pfwidth-129,x
    261  2088				  -	      sta	PF1R	; 3 too early?
    262  2088				  -	      lda	playfield+pfres*pfwidth-130-pfadjust,x
    263  2088				  -	      sta	PF2R	;3
    264  2088					      else
    265  2088		       b5 50		      lda	playfield-48+pfwidth*12+44-128,x	;4
    266  208a		       85 0e		      sta	PF1L	;3
    267  208c		       b5 51		      lda	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
    268  208e		       85 0f		      sta	PF2L	;3
    269  2090		       b5 53		      lda	playfield-48+pfwidth*12+47-128,x	;4
    270  2092		       85 0e		      sta	PF1R	; 3 too early?
    271  2094		       b5 52		      lda	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
    272  2096		       85 0f		      sta	PF2R	;3
    273  2098					      endif
    274  2098							; sleep 3
    275  2098
    276  2098		       a5 8e		      lda	player0height
    277  209a		       c7 85		      dcp	player0y
    278  209c		       90 b1		      bcc	.skipDrawP0
    279  209e		       a4 85		      ldy	player0y
    280  20a0		       b1 8a		      lda	(player0pointer),y
    281  20a2				   .continueP0
    282  20a2		       85 1b		      sta	GRP0
    283  20a4
    284  20a4					      ifnconst	no_blank_lines
    285  20a4					      ifnconst	playercolors
    286  20a4		       a5 90		      lda	missile0height	;3
    287  20a6		       c7 91		      dcp	missile0y	;5
    288  20a8		       e5 f6		      sbc	stack1
    289  20aa		       85 1d		      sta	ENAM0	;3
    290  20ac				  -	      else
    291  20ac				  -	      lda	(player0color),y
    292  20ac				  -	      sta	player0colorstore
    293  20ac				  -	      sleep	6
    294  20ac					      endif
    295  20ac		       c6 9c		      dec	temp1
    296  20ae		       d0 ab		      bne	continuekernel
    297  20b0				  -	      else
    298  20b0				  -	      dec	temp1
    299  20b0				  -	      beq	altkernel2
    300  20b0				  -	      ifconst	readpaddle
    301  20b0				  -	      ldy	currentpaddle
    302  20b0				  -	      lda	INPT0,y
    303  20b0				  -	      bpl	noreadpaddle
    304  20b0				  -	      inc	paddle
    305  20b0				  -	      jmp	continuekernel2
    306  20b0				  -noreadpaddle
    307  20b0				  -	      sleep	2
    308  20b0				  -	      jmp	continuekernel
    309  20b0				  -	      else
    310  20b0				  -	      ifnconst	playercolors
    311  20b0				  -	      ifconst	PFcolors
    312  20b0				  -	      txa
    313  20b0				  -	      tay
    314  20b0				  -	      lda	(pfcolortable),y
    315  20b0				  -	      ifnconst	backgroundchange
    316  20b0				  -	      sta	COLUPF
    317  20b0				  -	      else
    318  20b0				  -	      sta	COLUBK
    319  20b0				  -	      endif
    320  20b0				  -	      jmp	continuekernel
    321  20b0				  -	      else
    322  20b0				  -	      ifconst	kernelmacrodef
    323  20b0				  -	      kernelmacro
    324  20b0				  -	      else
    325  20b0				  -	      sleep	12
    326  20b0				  -	      endif
    327  20b0				  -	      endif
    328  20b0				  -	      else
    329  20b0				  -	      lda	(player0color),y
    330  20b0				  -	      sta	player0colorstore
    331  20b0				  -	      sleep	4
    332  20b0				  -	      endif
    333  20b0				  -	      jmp	continuekernel
    334  20b0				  -	      endif
    335  20b0				  -altkernel2
    336  20b0				  -	      txa
    337  20b0				  -	      ifnconst	vertical_reflect
    338  20b0				  -	      sbx	#256-pfwidth
    339  20b0				  -	      else
    340  20b0				  -	      sbx	#256-pfwidth/2
    341  20b0				  -	      endif
    342  20b0				  -	      bmi	lastkernelline
    343  20b0				  -	      ifconst	pfrowheight
    344  20b0				  -	      lda	#pfrowheight
    345  20b0				  -	      else
    346  20b0				  -	      ifnconst	pfres
    347  20b0				  -	      lda	#8
    348  20b0				  -	      else
    349  20b0				  -	      lda	#(96/pfres)	; try to come close to the real size
    350  20b0				  -	      endif
    351  20b0				  -	      endif
    352  20b0				  -	      sta	temp1
    353  20b0				  -	      jmp	continuekernel
    354  20b0					      endif
    355  20b0
    356  20b0				   altkernel
    357  20b0
    358  20b0				  -	      ifconst	PFmaskvalue
    359  20b0				  -	      lda	#PFmaskvalue
    360  20b0					      else
    361  20b0		       a9 00		      lda	#0
    362  20b2					      endif
    363  20b2		       85 0e		      sta	PF1L
    364  20b4		       85 0f		      sta	PF2
    365  20b6
    366  20b6
    367  20b6							;sleep 3
    368  20b6
    369  20b6							;28 cycles to fix things
    370  20b6							;minus 11=17
    371  20b6
    372  20b6							; lax temp4
    373  20b6							; clc
    374  20b6		       8a		      txa
    375  20b7					      ifnconst	vertical_reflect
    376  20b7		       cb fc		      sbx	#256-pfwidth
    377  20b9				  -	      else
    378  20b9				  -	      sbx	#256-pfwidth/2
    379  20b9					      endif
    380  20b9
    381  20b9		       30 12		      bmi	lastkernelline
    382  20bb
    383  20bb				  -	      ifconst	PFcolorandheight
    384  20bb				  -	      ifconst	pfres
    385  20bb				  -	      ldy	playfieldcolorandheight-131+pfres*pfwidth,x
    386  20bb				  -	      else
    387  20bb				  -	      ldy	playfieldcolorandheight-87,x
    388  20bb				  -	      endif
    389  20bb				  -	      ifnconst	backgroundchange
    390  20bb				  -	      sty	COLUPF
    391  20bb				  -	      else
    392  20bb				  -	      sty	COLUBK
    393  20bb				  -	      endif
    394  20bb				  -	      ifconst	pfres
    395  20bb				  -	      lda	playfieldcolorandheight-132+pfres*pfwidth,x
    396  20bb				  -	      else
    397  20bb				  -	      lda	playfieldcolorandheight-88,x
    398  20bb				  -	      endif
    399  20bb				  -	      sta.w	temp1
    400  20bb					      endif
    401  20bb				  -	      ifconst	PFheights
    402  20bb				  -	      lsr
    403  20bb				  -	      lsr
    404  20bb				  -	      tay
    405  20bb				  -	      lda	(pfheighttable),y
    406  20bb				  -	      sta.w	temp1
    407  20bb					      endif
    408  20bb				  -	      ifconst	PFcolors
    409  20bb				  -	      tay
    410  20bb				  -	      lda	(pfcolortable),y
    411  20bb				  -	      ifnconst	backgroundchange
    412  20bb				  -	      sta	COLUPF
    413  20bb				  -	      else
    414  20bb				  -	      sta	COLUBK
    415  20bb				  -	      endif
    416  20bb				  -	      ifconst	pfrowheight
    417  20bb				  -	      lda	#pfrowheight
    418  20bb				  -	      else
    419  20bb				  -	      ifnconst	pfres
    420  20bb				  -	      lda	#8
    421  20bb				  -	      else
    422  20bb				  -	      lda	#(96/pfres)	; try to come close to the real size
    423  20bb				  -	      endif
    424  20bb				  -	      endif
    425  20bb				  -	      sta	temp1
    426  20bb					      endif
    427  20bb					      ifnconst	PFcolorandheight
    428  20bb					      ifnconst	PFcolors
    429  20bb					      ifnconst	PFheights
    430  20bb					      ifnconst	no_blank_lines
    431  20bb							; read paddle 0
    432  20bb							; lo-res paddle read
    433  20bb							; bit INPT0
    434  20bb							; bmi paddleskipread
    435  20bb							; inc paddle0
    436  20bb							;donepaddleskip
      0  20bb					      sleep	10
      1  20bb				   .CYCLES    SET	10
      2  20bb
      3  20bb				  -	      IF	.CYCLES < 2
      4  20bb				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20bb				  -	      ERR
      6  20bb					      ENDIF
      7  20bb
      8  20bb				  -	      IF	.CYCLES & 1
      9  20bb				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  20bb				  -	      nop	0
     11  20bb				  -	      ELSE
     12  20bb				  -	      bit	VSYNC
     13  20bb				  -	      ENDIF
     14  20bb				  -.CYCLES    SET	.CYCLES - 3
     15  20bb					      ENDIF
     16  20bb
     17  20bb					      REPEAT	.CYCLES / 2
     18  20bb		       ea		      nop
     17  20bb					      REPEND
     18  20bc		       ea		      nop
     17  20bc					      REPEND
     18  20bd		       ea		      nop
     17  20bd					      REPEND
     18  20be		       ea		      nop
     17  20be					      REPEND
     18  20bf		       ea		      nop
     19  20c0					      REPEND
    438  20c0				  -	      ifconst	pfrowheight
    439  20c0				  -	      lda	#pfrowheight
    440  20c0					      else
    441  20c0					      ifnconst	pfres
    442  20c0		       a9 08		      lda	#8
    443  20c2				  -	      else
    444  20c2				  -	      lda	#(96/pfres)	; try to come close to the real size
    445  20c2					      endif
    446  20c2					      endif
    447  20c2		       85 9c		      sta	temp1
    448  20c4					      endif
    449  20c4					      endif
    450  20c4					      endif
    451  20c4					      endif
    452  20c4
    453  20c4
    454  20c4		       a5 92		      lda	ballheight
    455  20c6		       c7 89		      dcp	bally
    456  20c8		       e5 9f		      sbc	temp4
    457  20ca
    458  20ca
    459  20ca		       4c 72 f0 	      jmp	goback
    460  20cd
    461  20cd
    462  20cd					      ifnconst	no_blank_lines
    463  20cd				   lastkernelline
    464  20cd					      ifnconst	PFcolors
      0  20cd					      sleep	10
      1  20cd				   .CYCLES    SET	10
      2  20cd
      3  20cd				  -	      IF	.CYCLES < 2
      4  20cd				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20cd				  -	      ERR
      6  20cd					      ENDIF
      7  20cd
      8  20cd				  -	      IF	.CYCLES & 1
      9  20cd				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  20cd				  -	      nop	0
     11  20cd				  -	      ELSE
     12  20cd				  -	      bit	VSYNC
     13  20cd				  -	      ENDIF
     14  20cd				  -.CYCLES    SET	.CYCLES - 3
     15  20cd					      ENDIF
     16  20cd
     17  20cd					      REPEAT	.CYCLES / 2
     18  20cd		       ea		      nop
     17  20cd					      REPEND
     18  20ce		       ea		      nop
     17  20ce					      REPEND
     18  20cf		       ea		      nop
     17  20cf					      REPEND
     18  20d0		       ea		      nop
     17  20d0					      REPEND
     18  20d1		       ea		      nop
     19  20d2					      REPEND
    466  20d2				  -	      else
    467  20d2				  -	      ldy	#124
    468  20d2				  -	      lda	(pfcolortable),y
    469  20d2				  -	      sta	COLUPF
    470  20d2					      endif
    471  20d2
    472  20d2				  -	      ifconst	PFheights
    473  20d2				  -	      ldx	#1
    474  20d2				  -			;sleep 4
    475  20d2				  -	      sleep	3	; this was over 1 cycle
    476  20d2					      else
    477  20d2		       a6 ef		      ldx	playfieldpos
    478  20d4							;sleep 3
      0  20d4					      sleep	2	; this was over 1 cycle
      1  20d4				   .CYCLES    SET	2
      2  20d4
      3  20d4				  -	      IF	.CYCLES < 2
      4  20d4				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20d4				  -	      ERR
      6  20d4					      ENDIF
      7  20d4
      8  20d4				  -	      IF	.CYCLES & 1
      9  20d4				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  20d4				  -	      nop	0
     11  20d4				  -	      ELSE
     12  20d4				  -	      bit	VSYNC
     13  20d4				  -	      ENDIF
     14  20d4				  -.CYCLES    SET	.CYCLES - 3
     15  20d4					      ENDIF
     16  20d4
     17  20d4					      REPEAT	.CYCLES / 2
     18  20d4		       ea		      nop
     19  20d5					      REPEND
    480  20d5					      endif
    481  20d5
    482  20d5		       4c 1b f1 	      jmp	enterlastkernel
    483  20d8
    484  20d8				  -	      else
    485  20d8				  -lastkernelline
    486  20d8				  -
    487  20d8				  -	      ifconst	PFheights
    488  20d8				  -	      ldx	#1
    489  20d8				  -			;sleep 5
    490  20d8				  -	      sleep	4	; this was over 1 cycle
    491  20d8				  -	      else
    492  20d8				  -	      ldx	playfieldpos
    493  20d8				  -			;sleep 4
    494  20d8				  -	      sleep	3	; this was over 1 cycle
    495  20d8				  -	      endif
    496  20d8				  -
    497  20d8				  -	      cpx	#0
    498  20d8				  -	      bne	.enterfromNBL
    499  20d8				  -	      jmp	no_blank_lines_bailout
    500  20d8					      endif
    501  20d8
    502  20d8					      if	((<*)>$d5)
    503  2100		       00 00 00 00*	      align	256
    504  2100					      endif
    505  2100							; this is a kludge to prevent page wrapping - fix!!!
    506  2100
    507  2100				   .skipDrawlastP1
    508  2100		       a9 00		      lda	#0
    509  2102		       a8		      tay		; added so we don't cross a page
    510  2103		       4c 2d f1 	      jmp	.continuelastP1
    511  2106
    512  2106				   .endkerloop		; enter at cycle 59??
    513  2106
    514  2106		       ea		      nop
    515  2107
    516  2107				   .enterfromNBL
    517  2107				  -	      ifconst	pfres
    518  2107				  -	      ldy.w	playfield+pfres*pfwidth-4
    519  2107				  -	      sty	PF1L	;3
    520  2107				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
    521  2107				  -	      sty	PF2L	;3
    522  2107				  -	      ldy.w	playfield+pfres*pfwidth-1
    523  2107				  -	      sty	PF1R	; possibly too early?
    524  2107				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
    525  2107				  -	      sty	PF2R	;3
    526  2107					      else
    527  2107		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
    528  210a		       84 0e		      sty	PF1L	;3
    529  210c		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
    530  210f		       84 0f		      sty	PF2L	;3
    531  2111		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
    532  2114		       84 0e		      sty	PF1R	; possibly too early?
    533  2116		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
    534  2119		       84 0f		      sty	PF2R	;3
    535  211b					      endif
    536  211b
    537  211b				   enterlastkernel
    538  211b		       a5 92		      lda	ballheight
    539  211d
    540  211d							; tya
    541  211d		       c7 89		      dcp	bally
    542  211f							; sleep 4
    543  211f
    544  211f							; sbc stack3
    545  211f		       2a		      rol
    546  2120		       2a		      rol
    547  2121		       85 1f		      sta	ENABL
    548  2123
    549  2123		       a5 8f		      lda	player1height	;3
    550  2125		       c7 86		      dcp	player1y	;5
    551  2127		       90 d7		      bcc	.skipDrawlastP1
    552  2129		       a4 86		      ldy	player1y	;3
    553  212b		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
    554  212d							; so it doesn't cross a page boundary!
    555  212d
    556  212d				   .continuelastP1
    557  212d		       85 1c		      sta	GRP1	;3
    558  212f
    559  212f					      ifnconst	player1colors
    560  212f		       a5 87		      lda	missile1height	;3
    561  2131		       c7 88		      dcp	missile1y	;5
    562  2133				  -	      else
    563  2133				  -	      lda	(player1color),y
    564  2133				  -	      sta	COLUP1
    565  2133					      endif
    566  2133
    567  2133		       ca		      dex
    568  2134							;dec temp4 ; might try putting this above PF writes
    569  2134		       f0 36		      beq	endkernel
    570  2136
    571  2136
    572  2136				  -	      ifconst	pfres
    573  2136				  -	      ldy.w	playfield+pfres*pfwidth-4
    574  2136				  -	      sty	PF1L	;3
    575  2136				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
    576  2136				  -	      sty	PF2L	;3
    577  2136				  -	      ldy.w	playfield+pfres*pfwidth-1
    578  2136				  -	      sty	PF1R	; possibly too early?
    579  2136				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
    580  2136				  -	      sty	PF2R	;3
    581  2136					      else
    582  2136		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
    583  2139		       84 0e		      sty	PF1L	;3
    584  213b		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
    585  213e		       84 0f		      sty	PF2L	;3
    586  2140		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
    587  2143		       84 0e		      sty	PF1R	; possibly too early?
    588  2145		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
    589  2148		       84 0f		      sty	PF2R	;3
    590  214a					      endif
    591  214a
    592  214a					      ifnconst	player1colors
    593  214a		       2a		      rol		;2
    594  214b		       2a		      rol		;2
    595  214c		       85 1e		      sta	ENAM1	;3
    596  214e				  -	      else
    597  214e				  -	      ifnconst	playercolors
    598  214e				  -	      sleep	7
    599  214e				  -	      else
    600  214e				  -	      lda.w	player0colorstore
    601  214e				  -	      sta	COLUP0
    602  214e				  -	      endif
    603  214e					      endif
    604  214e
    605  214e		       ad 8e 00 	      lda.w	player0height
    606  2151		       c7 85		      dcp	player0y
    607  2153		       90 11		      bcc	.skipDrawlastP0
    608  2155		       a4 85		      ldy	player0y
    609  2157		       b1 8a		      lda	(player0pointer),y
    610  2159				   .continuelastP0
    611  2159		       85 1b		      sta	GRP0
    612  215b
    613  215b
    614  215b
    615  215b					      ifnconst	no_blank_lines
    616  215b		       a5 90		      lda	missile0height	;3
    617  215d		       c7 91		      dcp	missile0y	;5
    618  215f		       e5 f6		      sbc	stack1
    619  2161		       85 1d		      sta	ENAM0	;3
    620  2163		       4c 06 f1 	      jmp	.endkerloop
    621  2166				  -	      else
    622  2166				  -	      ifconst	readpaddle
    623  2166				  -	      ldy	currentpaddle
    624  2166				  -	      lda	INPT0,y
    625  2166				  -	      bpl	noreadpaddle2
    626  2166				  -	      inc	paddle
    627  2166				  -	      jmp	.endkerloop
    628  2166				  -noreadpaddle2
    629  2166				  -	      sleep	4
    630  2166				  -	      jmp	.endkerloop
    631  2166				  -	      else		; no_blank_lines and no paddle reading
    632  2166				  -	      pla
    633  2166				  -	      pha		; 14 cycles in 4 bytes
    634  2166				  -	      pla
    635  2166				  -	      pha
    636  2166				  -			; sleep 14
    637  2166				  -	      jmp	.endkerloop
    638  2166				  -	      endif
    639  2166					      endif
    640  2166
    641  2166
    642  2166							; ifconst donepaddleskip
    643  2166							;paddleskipread
    644  2166							; this is kind of lame, since it requires 4 cycles from a page boundary crossing
    645  2166							; plus we get a lo-res paddle read
    646  2166							; bmi donepaddleskip
    647  2166							; endif
    648  2166
    649  2166				   .skipDrawlastP0
    650  2166		       a9 00		      lda	#0
    651  2168		       a8		      tay
    652  2169		       4c 59 f1 	      jmp	.continuelastP0
    653  216c
    654  216c				  -	      ifconst	no_blank_lines
    655  216c				  -no_blank_lines_bailout
    656  216c				  -	      ldx	#0
    657  216c					      endif
    658  216c
    659  216c				   endkernel
    660  216c							; 6 digit score routine
    661  216c		       86 0e		      stx	PF1
    662  216e		       86 0f		      stx	PF2
    663  2170		       86 0d		      stx	PF0
    664  2172		       18		      clc
    665  2173
    666  2173				  -	      ifconst	pfrowheight
    667  2173				  -	      lda	#pfrowheight+2
    668  2173					      else
    669  2173					      ifnconst	pfres
    670  2173		       a9 0a		      lda	#10
    671  2175				  -	      else
    672  2175				  -	      lda	#(96/pfres)+2	; try to come close to the real size
    673  2175					      endif
    674  2175					      endif
    675  2175
    676  2175		       e5 ef		      sbc	playfieldpos
    677  2177		       85 ef		      sta	playfieldpos
    678  2179		       8a		      txa
    679  217a
    680  217a				  -	      ifconst	shakescreen
    681  217a				  -	      bit	shakescreen
    682  217a				  -	      bmi	noshakescreen2
    683  217a				  -	      ldx	#$3D
    684  217a				  -noshakescreen2
    685  217a					      endif
    686  217a
    687  217a		       95 02		      sta	WSYNC,x
    688  217c
    689  217c							; STA WSYNC ;first one, need one more
    690  217c		       85 0b		      sta	REFP0
    691  217e		       85 0c		      sta	REFP1
    692  2180		       85 1b		      STA	GRP0
    693  2182		       85 1c		      STA	GRP1
    694  2184							; STA PF1
    695  2184							; STA PF2
    696  2184		       85 2b		      sta	HMCLR
    697  2186		       85 1d		      sta	ENAM0
    698  2188		       85 1e		      sta	ENAM1
    699  218a		       85 1f		      sta	ENABL
    700  218c
    701  218c		       a5 9d		      lda	temp2	;restore variables that were obliterated by kernel
    702  218e		       85 85		      sta	player0y
    703  2190		       a5 9e		      lda	temp3
    704  2192		       85 86		      sta	player1y
    705  2194					      ifnconst	player1colors
    706  2194		       a5 a1		      lda	temp6
    707  2196		       85 88		      sta	missile1y
    708  2198					      endif
    709  2198					      ifnconst	playercolors
    710  2198					      ifnconst	readpaddle
    711  2198		       a5 a0		      lda	temp5
    712  219a		       85 91		      sta	missile0y
    713  219c					      endif
    714  219c					      endif
    715  219c		       a5 f7		      lda	stack2
    716  219e		       85 89		      sta	bally
    717  21a0
    718  21a0							; strangely, this isn't required any more. might have
    719  21a0							; resulted from the no_blank_lines score bounce fix
    720  21a0							;ifconst no_blank_lines
    721  21a0							;sta WSYNC
    722  21a0							;endif
    723  21a0
    724  21a0		       ad 84 02 	      lda	INTIM
    725  21a3		       18		      clc
    726  21a4					      ifnconst	vblank_time
    727  21a4		       69 8e		      adc	#43+12+87
    728  21a6				  -	      else
    729  21a6				  -	      adc	#vblank_time+12+87
    730  21a6				  -
    731  21a6					      endif
    732  21a6							; sta WSYNC
    733  21a6		       8d 96 02 	      sta	TIM64T
    734  21a9
    735  21a9				  -	      ifconst	minikernel
    736  21a9				  -	      jsr	minikernel
    737  21a9					      endif
    738  21a9
    739  21a9							; now reassign temp vars for score pointers
    740  21a9
    741  21a9							; score pointers contain:
    742  21a9							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
    743  21a9							; swap lo2->temp1
    744  21a9							; swap lo4->temp3
    745  21a9							; swap lo6->temp5
    746  21a9					      ifnconst	noscore
    747  21a9		       a5 97		      lda	scorepointers+1
    748  21ab							; ldy temp1
    749  21ab		       85 9c		      sta	temp1
    750  21ad							; sty scorepointers+1
    751  21ad
    752  21ad		       a5 99		      lda	scorepointers+3
    753  21af							; ldy temp3
    754  21af		       85 9e		      sta	temp3
    755  21b1							; sty scorepointers+3
    756  21b1
    757  21b1
    758  21b1		       85 2b		      sta	HMCLR
    759  21b3		       ba		      tsx
    760  21b4		       86 f6		      stx	stack1
    761  21b6		       a2 e0		      ldx	#$E0
    762  21b8		       86 20		      stx	HMP0
    763  21ba
    764  21ba		       a5 a3		      LDA	scorecolor
    765  21bc		       85 06		      STA	COLUP0
    766  21be		       85 07		      STA	COLUP1
    767  21c0				  -	      ifconst	scorefade
    768  21c0				  -	      STA	stack2
    769  21c0					      endif
    770  21c0				  -	      ifconst	pfscore
    771  21c0				  -	      lda	pfscorecolor
    772  21c0				  -	      sta	COLUPF
    773  21c0					      endif
    774  21c0		       85 02		      sta	WSYNC
    775  21c2		       a2 00		      ldx	#0
    776  21c4		       86 1b		      STx	GRP0
    777  21c6		       86 1c		      STx	GRP1	; seems to be needed because of vdel
    778  21c8
    779  21c8		       a5 9b		      lda	scorepointers+5
    780  21ca							; ldy temp5
    781  21ca		       95 a0		      sta	temp5,x
    782  21cc							; sty scorepointers+5
    783  21cc		       a9 ff		      lda	#>scoretable
    784  21ce		       85 97		      sta	scorepointers+1
    785  21d0		       85 99		      sta	scorepointers+3
    786  21d2		       85 9b		      sta	scorepointers+5
    787  21d4		       85 9d		      sta	temp2
    788  21d6		       85 9f		      sta	temp4
    789  21d8		       85 a1		      sta	temp6
    790  21da		       a0 07		      LDY	#7
    791  21dc		       84 25		      STY	VDELP0
    792  21de		       85 10		      STA	RESP0
    793  21e0		       85 11		      STA	RESP1
    794  21e2
    795  21e2
    796  21e2		       a9 03		      LDA	#$03
    797  21e4		       85 04		      STA	NUSIZ0
    798  21e6		       85 05		      STA	NUSIZ1
    799  21e8		       85 26		      STA	VDELP1
    800  21ea		       a9 f0		      LDA	#$F0
    801  21ec		       85 21		      STA	HMP1
    802  21ee		       b1 96		      lda	(scorepointers),y
    803  21f0		       85 1b		      sta	GRP0
    804  21f2		       85 2a		      STA	HMOVE	; cycle 73 ?
    805  21f4		       4c 08 f2 	      jmp	beginscore
    806  21f7
    807  21f7
    808  21f7					      if	((<*)>$d4)
    809  2200		       00 00 00 00*	      align	256	; kludge that potentially wastes space! should be fixed!
    810  2200					      endif
    811  2200
    812  2200				   loop2
    813  2200		       b1 96		      lda	(scorepointers),y	;+5 68 204
    814  2202		       85 1b		      sta	GRP0	;+3 71 213 D1 -- -- --
    815  2204				  -	      ifconst	pfscore
    816  2204				  -	      lda.w	pfscore1
    817  2204				  -	      sta	PF1
    818  2204					      else
    819  2204				  -	      ifconst	scorefade
    820  2204				  -	      sleep	2
    821  2204				  -	      dec	stack2	; decrement the temporary scorecolor
    822  2204					      else
      0  2204					      sleep	7
      1  2204				   .CYCLES    SET	7
      2  2204
      3  2204				  -	      IF	.CYCLES < 2
      4  2204				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2204				  -	      ERR
      6  2204					      ENDIF
      7  2204
      8  2204					      IF	.CYCLES & 1
      9  2204					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2204		       04 00		      nop	0
     11  2206				  -	      ELSE
     12  2206				  -	      bit	VSYNC
     13  2206					      ENDIF
     14  2206				   .CYCLES    SET	.CYCLES - 3
     15  2206					      ENDIF
     16  2206
     17  2206					      REPEAT	.CYCLES / 2
     18  2206		       ea		      nop
     17  2206					      REPEND
     18  2207		       ea		      nop
     19  2208					      REPEND
    824  2208					      endif
    825  2208					      endif
    826  2208							; cycle 0
    827  2208				   beginscore
    828  2208		       b1 9e		      lda	(scorepointers+$8),y	;+5 5 15
    829  220a		       85 1c		      sta	GRP1	;+3 8 24 D1 D1 D2 --
    830  220c		       b1 9c		      lda	(scorepointers+$6),y	;+5 13 39
    831  220e		       85 1b		      sta	GRP0	;+3 16 48 D3 D1 D2 D2
    832  2210		       b3 98		      lax	(scorepointers+$2),y	;+5 29 87
    833  2212		       9a		      txs
    834  2213		       b3 9a		      lax	(scorepointers+$4),y	;+5 36 108
    835  2215				  -	      ifconst	scorefade
    836  2215				  -	      lda	stack2
    837  2215					      else
      0  2215					      sleep	3
      1  2215				   .CYCLES    SET	3
      2  2215
      3  2215				  -	      IF	.CYCLES < 2
      4  2215				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2215				  -	      ERR
      6  2215					      ENDIF
      7  2215
      8  2215					      IF	.CYCLES & 1
      9  2215					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2215		       04 00		      nop	0
     11  2217				  -	      ELSE
     12  2217				  -	      bit	VSYNC
     13  2217					      ENDIF
     14  2217				   .CYCLES    SET	.CYCLES - 3
     15  2217					      ENDIF
     16  2217
     17  2217				  -	      REPEAT	.CYCLES / 2
     18  2217				  -	      nop
     19  2217					      REPEND
    839  2217					      endif
    840  2217
    841  2217				  -	      ifconst	pfscore
    842  2217				  -	      lda	pfscore2
    843  2217				  -	      sta	PF1
    844  2217					      else
    845  2217				  -	      ifconst	scorefade
    846  2217				  -	      sta	COLUP0
    847  2217				  -	      sta	COLUP1
    848  2217					      else
      0  2217					      sleep	6
      1  2217				   .CYCLES    SET	6
      2  2217
      3  2217				  -	      IF	.CYCLES < 2
      4  2217				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2217				  -	      ERR
      6  2217					      ENDIF
      7  2217
      8  2217				  -	      IF	.CYCLES & 1
      9  2217				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2217				  -	      nop	0
     11  2217				  -	      ELSE
     12  2217				  -	      bit	VSYNC
     13  2217				  -	      ENDIF
     14  2217				  -.CYCLES    SET	.CYCLES - 3
     15  2217					      ENDIF
     16  2217
     17  2217					      REPEAT	.CYCLES / 2
     18  2217		       ea		      nop
     17  2217					      REPEND
     18  2218		       ea		      nop
     17  2218					      REPEND
     18  2219		       ea		      nop
     19  221a					      REPEND
    850  221a					      endif
    851  221a					      endif
    852  221a
    853  221a		       b1 a0		      lda	(scorepointers+$A),y	;+5 21 63
    854  221c		       86 1c		      stx	GRP1	;+3 44 132 D3 D3 D4 D2!
    855  221e		       ba		      tsx
    856  221f		       86 1b		      stx	GRP0	;+3 47 141 D5 D3! D4 D4
    857  2221		       85 1c		      sta	GRP1	;+3 50 150 D5 D5 D6 D4!
    858  2223		       84 1b		      sty	GRP0	;+3 53 159 D4* D5! D6 D6
    859  2225		       88		      dey
    860  2226		       10 d8		      bpl	loop2	;+2 60 180
    861  2228
    862  2228		       a6 f6		      ldx	stack1
    863  222a		       9a		      txs
    864  222b							; lda scorepointers+1
    865  222b		       a4 9c		      ldy	temp1
    866  222d							; sta temp1
    867  222d		       84 97		      sty	scorepointers+1
    868  222f
    869  222f		       a9 00		      LDA	#0
    870  2231		       85 0e		      sta	PF1
    871  2233		       85 1b		      STA	GRP0
    872  2235		       85 1c		      STA	GRP1
    873  2237		       85 25		      STA	VDELP0
    874  2239		       85 26		      STA	VDELP1	;do we need these
    875  223b		       85 04		      STA	NUSIZ0
    876  223d		       85 05		      STA	NUSIZ1
    877  223f
    878  223f							; lda scorepointers+3
    879  223f		       a4 9e		      ldy	temp3
    880  2241							; sta temp3
    881  2241		       84 99		      sty	scorepointers+3
    882  2243
    883  2243							; lda scorepointers+5
    884  2243		       a4 a0		      ldy	temp5
    885  2245							; sta temp5
    886  2245		       84 9b		      sty	scorepointers+5
    887  2247					      endif		;noscore
    888  2247				  -	      ifconst	readpaddle
    889  2247				  -	      lda	#%11000010
    890  2247					      else
    891  2247				  -	      ifconst	qtcontroller
    892  2247				  -	      lda	qtcontroller
    893  2247				  -	      lsr		; bit 0 in carry
    894  2247				  -	      lda	#4
    895  2247				  -	      ror		; carry into top of A
    896  2247					      else
    897  2247		       a9 02		      lda	#2
    898  2249					      endif		; qtcontroller
    899  2249					      endif		; readpaddle
    900  2249		       85 02		      sta	WSYNC
    901  224b		       85 01		      sta	VBLANK
      0  224d					      RETURN
      1  224d				  -	      ifnconst	bankswitch
      2  224d				  -	      rts
      3  224d					      else
      4  224d		       4c dd ff 	      jmp	BS_return
      5  2250					      endif
    903  2250				  -	      ifconst	shakescreen
    904  2250				  -doshakescreen
    905  2250				  -	      bit	shakescreen
    906  2250				  -	      bmi	noshakescreen
    907  2250				  -	      sta	WSYNC
    908  2250				  -noshakescreen
    909  2250				  -	      ldx	missile0height
    910  2250				  -	      inx
    911  2250				  -	      rts
    912  2250					      endif
    913  2250
    914  2250							; Provided under the CC0 license. See the included LICENSE.txt for details.
    915  2250
    916  2250				   start
    917  2250		       78		      sei
    918  2251		       d8		      cld
    919  2252		       a0 00		      ldy	#0
    920  2254		       a5 d0		      lda	$D0
    921  2256		       c9 2c		      cmp	#$2C	;check RAM location #1
    922  2258		       d0 07		      bne	MachineIs2600
    923  225a		       a5 d1		      lda	$D1
    924  225c		       c9 a9		      cmp	#$A9	;check RAM location #2
    925  225e		       d0 01		      bne	MachineIs2600
    926  2260		       88		      dey
    927  2261				   MachineIs2600
    928  2261		       a2 00		      ldx	#0
    929  2263		       8a		      txa
    930  2264				   clearmem
    931  2264		       e8		      inx
    932  2265		       9a		      txs
    933  2266		       48		      pha
    934  2267		       d0 fb		      bne	clearmem
    935  2269		       84 9c		      sty	temp1
    936  226b					      ifnconst	multisprite
    937  226b				  -	      ifconst	pfrowheight
    938  226b				  -	      lda	#pfrowheight
    939  226b					      else
    940  226b				  -	      ifconst	pfres
    941  226b				  -	      lda	#(96/pfres)
    942  226b					      else
    943  226b		       a9 08		      lda	#8
    944  226d					      endif
    945  226d					      endif
    946  226d		       85 ef		      sta	playfieldpos
    947  226f					      endif
    948  226f		       a2 05		      ldx	#5
    949  2271				   initscore
    950  2271		       a9 74		      lda	#<scoretable
    951  2273		       95 96		      sta	scorepointers,x
    952  2275		       ca		      dex
    953  2276		       10 f9		      bpl	initscore
    954  2278		       a9 01		      lda	#1
    955  227a		       85 0a		      sta	CTRLPF
    956  227c		       0d 84 02 	      ora	INTIM
    957  227f		       85 a2		      sta	rand
    958  2281
    959  2281				  -	      ifconst	multisprite
    960  2281				  -	      jsr	multisprite_setup
    961  2281					      endif
    962  2281
    963  2281				  -	      ifnconst	bankswitch
    964  2281				  -	      jmp	game
    965  2281					      else
    966  2281		       a9 cf		      lda	#>(game-1)
    967  2283		       48		      pha
    968  2284		       a9 ff		      lda	#<(game-1)
    969  2286		       48		      pha
    970  2287		       48		      pha
    971  2288		       48		      pha
    972  2289		       a2 01		      ldx	#1
    973  228b		       4c eb ff 	      jmp	BS_jsr
    974  228e					      endif
    975  228e							; Provided under the CC0 license. See the included LICENSE.txt for details.
    976  228e
    977  228e							; playfield drawing routines
    978  228e							; you get a 32x12 bitmapped display in a single color :)
    979  228e							; 0-31 and 0-11
    980  228e
    981  228e				   pfclear		; clears playfield - or fill with pattern
    982  228e				  -	      ifconst	pfres
    983  228e				  -	      ldx	#pfres*pfwidth-1
    984  228e					      else
    985  228e		       a2 2f		      ldx	#47-(4-pfwidth)*12	; will this work?
    986  2290					      endif
    987  2290				   pfclear_loop
    988  2290					      ifnconst	superchip
    989  2290		       95 a4		      sta	playfield,x
    990  2292				  -	      else
    991  2292				  -	      sta	playfield-128,x
    992  2292					      endif
    993  2292		       ca		      dex
    994  2293		       10 fb		      bpl	pfclear_loop
      0  2295					      RETURN
      1  2295				  -	      ifnconst	bankswitch
      2  2295				  -	      rts
      3  2295					      else
      4  2295		       4c dd ff 	      jmp	BS_return
      5  2298					      endif
    996  2298
    997  2298				   setuppointers
    998  2298		       86 9d		      stx	temp2	; store on.off.flip value
    999  229a		       aa		      tax		; put x-value in x 
   1000  229b		       4a		      lsr
   1001  229c		       4a		      lsr
   1002  229d		       4a		      lsr		; divide x pos by 8 
   1003  229e		       85 9c		      sta	temp1
   1004  22a0		       98		      tya
   1005  22a1		       0a		      asl
   1006  22a2					      if	pfwidth=4
   1007  22a2		       0a		      asl		; multiply y pos by 4
   1008  22a3					      endif		; else multiply by 2
   1009  22a3		       18		      clc
   1010  22a4		       65 9c		      adc	temp1	; add them together to get actual memory location offset
   1011  22a6		       a8		      tay		; put the value in y
   1012  22a7		       a5 9d		      lda	temp2	; restore on.off.flip value
   1013  22a9		       60		      rts
   1014  22aa
   1015  22aa				   pfread
   1016  22aa							;x=xvalue, y=yvalue
   1017  22aa		       20 98 f2 	      jsr	setuppointers
   1018  22ad		       bd 42 f3 	      lda	setbyte,x
   1019  22b0		       39 a4 00 	      and	playfield,y
   1020  22b3		       5d 42 f3 	      eor	setbyte,x
   1021  22b6							; beq readzero
   1022  22b6							; lda #1
   1023  22b6							; readzero
      0  22b6					      RETURN
      1  22b6				  -	      ifnconst	bankswitch
      2  22b6				  -	      rts
      3  22b6					      else
      4  22b6		       4c dd ff 	      jmp	BS_return
      5  22b9					      endif
   1025  22b9
   1026  22b9				   pfpixel
   1027  22b9							;x=xvalue, y=yvalue, a=0,1,2
   1028  22b9		       20 98 f2 	      jsr	setuppointers
   1029  22bc
   1030  22bc					      ifconst	bankswitch
   1031  22bc		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   1032  22be		       f0 0f		      beq	pixelon_r	; if "on" go to on
   1033  22c0		       4a		      lsr
   1034  22c1		       b0 18		      bcs	pixeloff_r	; value is 1 if true
   1035  22c3		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   1036  22c6		       5d 42 f3 	      eor	setbyte,x
   1037  22c9				  -	      ifconst	superchip
   1038  22c9				  -	      sta	playfield-128,y
   1039  22c9					      else
   1040  22c9		       99 a4 00 	      sta	playfield,y
   1041  22cc					      endif
      0  22cc					      RETURN
      1  22cc				  -	      ifnconst	bankswitch
      2  22cc				  -	      rts
      3  22cc					      else
      4  22cc		       4c dd ff 	      jmp	BS_return
      5  22cf					      endif
   1043  22cf				   pixelon_r
   1044  22cf		       b9 a4 00 	      lda	playfield,y
   1045  22d2		       1d 42 f3 	      ora	setbyte,x
   1046  22d5				  -	      ifconst	superchip
   1047  22d5				  -	      sta	playfield-128,y
   1048  22d5					      else
   1049  22d5		       99 a4 00 	      sta	playfield,y
   1050  22d8					      endif
      0  22d8					      RETURN
      1  22d8				  -	      ifnconst	bankswitch
      2  22d8				  -	      rts
      3  22d8					      else
      4  22d8		       4c dd ff 	      jmp	BS_return
      5  22db					      endif
   1052  22db				   pixeloff_r
   1053  22db		       bd 42 f3 	      lda	setbyte,x
   1054  22de		       49 ff		      eor	#$ff
   1055  22e0		       39 a4 00 	      and	playfield,y
   1056  22e3				  -	      ifconst	superchip
   1057  22e3				  -	      sta	playfield-128,y
   1058  22e3					      else
   1059  22e3		       99 a4 00 	      sta	playfield,y
   1060  22e6					      endif
      0  22e6					      RETURN
      1  22e6				  -	      ifnconst	bankswitch
      2  22e6				  -	      rts
      3  22e6					      else
      4  22e6		       4c dd ff 	      jmp	BS_return
      5  22e9					      endif
   1062  22e9
   1063  22e9				  -	      else
   1064  22e9				  -	      jmp	plotpoint
   1065  22e9					      endif
   1066  22e9
   1067  22e9				   pfhline
   1068  22e9							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   1069  22e9		       20 98 f2 	      jsr	setuppointers
   1070  22ec		       4c f6 f2 	      jmp	noinc
   1071  22ef				   keepgoing
   1072  22ef		       e8		      inx
   1073  22f0		       8a		      txa
   1074  22f1		       29 07		      and	#7
   1075  22f3		       d0 01		      bne	noinc
   1076  22f5		       c8		      iny
   1077  22f6				   noinc
   1078  22f6		       20 1b f3 	      jsr	plotpoint
   1079  22f9		       e4 9e		      cpx	temp3
   1080  22fb		       30 f2		      bmi	keepgoing
      0  22fd					      RETURN
      1  22fd				  -	      ifnconst	bankswitch
      2  22fd				  -	      rts
      3  22fd					      else
      4  22fd		       4c dd ff 	      jmp	BS_return
      5  2300					      endif
   1082  2300
   1083  2300				   pfvline
   1084  2300							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   1085  2300		       20 98 f2 	      jsr	setuppointers
   1086  2303		       84 9c		      sty	temp1	; store memory location offset
   1087  2305		       e6 9e		      inc	temp3	; increase final x by 1 
   1088  2307		       a5 9e		      lda	temp3
   1089  2309		       0a		      asl
   1090  230a					      if	pfwidth=4
   1091  230a		       0a		      asl		; multiply by 4
   1092  230b					      endif		; else multiply by 2
   1093  230b		       85 9e		      sta	temp3	; store it
   1094  230d							; Thanks to Michael Rideout for fixing a bug in this code
   1095  230d							; right now, temp1=y=starting memory location, temp3=final
   1096  230d							; x should equal original x value
   1097  230d				   keepgoingy
   1098  230d		       20 1b f3 	      jsr	plotpoint
   1099  2310		       c8		      iny
   1100  2311		       c8		      iny
   1101  2312					      if	pfwidth=4
   1102  2312		       c8		      iny
   1103  2313		       c8		      iny
   1104  2314					      endif
   1105  2314		       c4 9e		      cpy	temp3
   1106  2316		       30 f5		      bmi	keepgoingy
      0  2318					      RETURN
      1  2318				  -	      ifnconst	bankswitch
      2  2318				  -	      rts
      3  2318					      else
      4  2318		       4c dd ff 	      jmp	BS_return
      5  231b					      endif
   1108  231b
   1109  231b				   plotpoint
   1110  231b		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   1111  231d		       f0 0d		      beq	pixelon	; if "on" go to on
   1112  231f		       4a		      lsr
   1113  2320		       b0 14		      bcs	pixeloff	; value is 1 if true
   1114  2322		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   1115  2325		       5d 42 f3 	      eor	setbyte,x
   1116  2328				  -	      ifconst	superchip
   1117  2328				  -	      sta	playfield-128,y
   1118  2328					      else
   1119  2328		       99 a4 00 	      sta	playfield,y
   1120  232b					      endif
   1121  232b		       60		      rts
   1122  232c				   pixelon
   1123  232c		       b9 a4 00 	      lda	playfield,y
   1124  232f		       1d 42 f3 	      ora	setbyte,x
   1125  2332				  -	      ifconst	superchip
   1126  2332				  -	      sta	playfield-128,y
   1127  2332					      else
   1128  2332		       99 a4 00 	      sta	playfield,y
   1129  2335					      endif
   1130  2335		       60		      rts
   1131  2336				   pixeloff
   1132  2336		       bd 42 f3 	      lda	setbyte,x
   1133  2339		       49 ff		      eor	#$ff
   1134  233b		       39 a4 00 	      and	playfield,y
   1135  233e				  -	      ifconst	superchip
   1136  233e				  -	      sta	playfield-128,y
   1137  233e					      else
   1138  233e		       99 a4 00 	      sta	playfield,y
   1139  2341					      endif
   1140  2341		       60		      rts
   1141  2342
   1142  2342				   setbyte
   1143  2342					      ifnconst	pfcenter
   1144  2342		       80		      .byte.b	$80
   1145  2343		       40		      .byte.b	$40
   1146  2344		       20		      .byte.b	$20
   1147  2345		       10		      .byte.b	$10
   1148  2346		       08		      .byte.b	$08
   1149  2347		       04		      .byte.b	$04
   1150  2348		       02		      .byte.b	$02
   1151  2349		       01		      .byte.b	$01
   1152  234a					      endif
   1153  234a		       01		      .byte.b	$01
   1154  234b		       02		      .byte.b	$02
   1155  234c		       04		      .byte.b	$04
   1156  234d		       08		      .byte.b	$08
   1157  234e		       10		      .byte.b	$10
   1158  234f		       20		      .byte.b	$20
   1159  2350		       40		      .byte.b	$40
   1160  2351		       80		      .byte.b	$80
   1161  2352		       80		      .byte.b	$80
   1162  2353		       40		      .byte.b	$40
   1163  2354		       20		      .byte.b	$20
   1164  2355		       10		      .byte.b	$10
   1165  2356		       08		      .byte.b	$08
   1166  2357		       04		      .byte.b	$04
   1167  2358		       02		      .byte.b	$02
   1168  2359		       01		      .byte.b	$01
   1169  235a		       01		      .byte.b	$01
   1170  235b		       02		      .byte.b	$02
   1171  235c		       04		      .byte.b	$04
   1172  235d		       08		      .byte.b	$08
   1173  235e		       10		      .byte.b	$10
   1174  235f		       20		      .byte.b	$20
   1175  2360		       40		      .byte.b	$40
   1176  2361		       80		      .byte.b	$80
   1177  2362							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1178  2362
   1179  2362				   pfscroll		;(a=0 left, 1 right, 2 up, 4 down, 6=upup, 12=downdown)
   1180  2362		       d0 15		      bne	notleft
   1181  2364							;left
   1182  2364				  -	      ifconst	pfres
   1183  2364				  -	      ldx	#pfres*4
   1184  2364					      else
   1185  2364		       a2 30		      ldx	#48
   1186  2366					      endif
   1187  2366				   leftloop
   1188  2366		       b5 a3		      lda	playfield-1,x
   1189  2368		       4a		      lsr
   1190  2369
   1191  2369				  -	      ifconst	superchip
   1192  2369				  -	      lda	playfield-2,x
   1193  2369				  -	      rol
   1194  2369				  -	      sta	playfield-130,x
   1195  2369				  -	      lda	playfield-3,x
   1196  2369				  -	      ror
   1197  2369				  -	      sta	playfield-131,x
   1198  2369				  -	      lda	playfield-4,x
   1199  2369				  -	      rol
   1200  2369				  -	      sta	playfield-132,x
   1201  2369				  -	      lda	playfield-1,x
   1202  2369				  -	      ror
   1203  2369				  -	      sta	playfield-129,x
   1204  2369					      else
   1205  2369		       36 a2		      rol	playfield-2,x
   1206  236b		       76 a1		      ror	playfield-3,x
   1207  236d		       36 a0		      rol	playfield-4,x
   1208  236f		       76 a3		      ror	playfield-1,x
   1209  2371					      endif
   1210  2371
   1211  2371		       8a		      txa
   1212  2372		       cb 04		      sbx	#4
   1213  2374		       d0 f0		      bne	leftloop
      0  2376					      RETURN
      1  2376				  -	      ifnconst	bankswitch
      2  2376				  -	      rts
      3  2376					      else
      4  2376		       4c dd ff 	      jmp	BS_return
      5  2379					      endif
   1215  2379
   1216  2379				   notleft
   1217  2379		       4a		      lsr
   1218  237a		       90 15		      bcc	notright
   1219  237c							;right
   1220  237c
   1221  237c				  -	      ifconst	pfres
   1222  237c				  -	      ldx	#pfres*4
   1223  237c					      else
   1224  237c		       a2 30		      ldx	#48
   1225  237e					      endif
   1226  237e				   rightloop
   1227  237e		       b5 a0		      lda	playfield-4,x
   1228  2380		       4a		      lsr
   1229  2381				  -	      ifconst	superchip
   1230  2381				  -	      lda	playfield-3,x
   1231  2381				  -	      rol
   1232  2381				  -	      sta	playfield-131,x
   1233  2381				  -	      lda	playfield-2,x
   1234  2381				  -	      ror
   1235  2381				  -	      sta	playfield-130,x
   1236  2381				  -	      lda	playfield-1,x
   1237  2381				  -	      rol
   1238  2381				  -	      sta	playfield-129,x
   1239  2381				  -	      lda	playfield-4,x
   1240  2381				  -	      ror
   1241  2381				  -	      sta	playfield-132,x
   1242  2381					      else
   1243  2381		       36 a1		      rol	playfield-3,x
   1244  2383		       76 a2		      ror	playfield-2,x
   1245  2385		       36 a3		      rol	playfield-1,x
   1246  2387		       76 a0		      ror	playfield-4,x
   1247  2389					      endif
   1248  2389		       8a		      txa
   1249  238a		       cb 04		      sbx	#4
   1250  238c		       d0 f0		      bne	rightloop
      0  238e					      RETURN
      1  238e				  -	      ifnconst	bankswitch
      2  238e				  -	      rts
      3  238e					      else
      4  238e		       4c dd ff 	      jmp	BS_return
      5  2391					      endif
   1252  2391
   1253  2391				   notright
   1254  2391		       4a		      lsr
   1255  2392		       90 4b		      bcc	notup
   1256  2394							;up
   1257  2394		       4a		      lsr
   1258  2395		       90 02		      bcc	onedecup
   1259  2397		       c6 ef		      dec	playfieldpos
   1260  2399				   onedecup
   1261  2399		       c6 ef		      dec	playfieldpos
   1262  239b		       f0 02		      beq	shiftdown
   1263  239d		       10 3d		      bpl	noshiftdown2
   1264  239f				   shiftdown
   1265  239f				  -	      ifconst	pfrowheight
   1266  239f				  -	      lda	#pfrowheight
   1267  239f					      else
   1268  239f					      ifnconst	pfres
   1269  239f		       a9 08		      lda	#8
   1270  23a1				  -	      else
   1271  23a1				  -	      lda	#(96/pfres)	; try to come close to the real size
   1272  23a1					      endif
   1273  23a1					      endif
   1274  23a1
   1275  23a1		       85 ef		      sta	playfieldpos
   1276  23a3		       a5 a7		      lda	playfield+3
   1277  23a5		       85 9f		      sta	temp4
   1278  23a7		       a5 a6		      lda	playfield+2
   1279  23a9		       85 9e		      sta	temp3
   1280  23ab		       a5 a5		      lda	playfield+1
   1281  23ad		       85 9d		      sta	temp2
   1282  23af		       a5 a4		      lda	playfield
   1283  23b1		       85 9c		      sta	temp1
   1284  23b3		       a2 00		      ldx	#0
   1285  23b5				   up2
   1286  23b5		       b5 a8		      lda	playfield+4,x
   1287  23b7				  -	      ifconst	superchip
   1288  23b7				  -	      sta	playfield-128,x
   1289  23b7				  -	      lda	playfield+5,x
   1290  23b7				  -	      sta	playfield-127,x
   1291  23b7				  -	      lda	playfield+6,x
   1292  23b7				  -	      sta	playfield-126,x
   1293  23b7				  -	      lda	playfield+7,x
   1294  23b7				  -	      sta	playfield-125,x
   1295  23b7					      else
   1296  23b7		       95 a4		      sta	playfield,x
   1297  23b9		       b5 a9		      lda	playfield+5,x
   1298  23bb		       95 a5		      sta	playfield+1,x
   1299  23bd		       b5 aa		      lda	playfield+6,x
   1300  23bf		       95 a6		      sta	playfield+2,x
   1301  23c1		       b5 ab		      lda	playfield+7,x
   1302  23c3		       95 a7		      sta	playfield+3,x
   1303  23c5					      endif
   1304  23c5		       8a		      txa
   1305  23c6		       cb fc		      sbx	#252
   1306  23c8				  -	      ifconst	pfres
   1307  23c8				  -	      cpx	#(pfres-1)*4
   1308  23c8					      else
   1309  23c8		       e0 2c		      cpx	#44
   1310  23ca					      endif
   1311  23ca		       d0 e9		      bne	up2
   1312  23cc
   1313  23cc		       a5 9f		      lda	temp4
   1314  23ce
   1315  23ce				  -	      ifconst	superchip
   1316  23ce				  -	      ifconst	pfres
   1317  23ce				  -	      sta	playfield+pfres*4-129
   1318  23ce				  -	      lda	temp3
   1319  23ce				  -	      sta	playfield+pfres*4-130
   1320  23ce				  -	      lda	temp2
   1321  23ce				  -	      sta	playfield+pfres*4-131
   1322  23ce				  -	      lda	temp1
   1323  23ce				  -	      sta	playfield+pfres*4-132
   1324  23ce				  -	      else
   1325  23ce				  -	      sta	playfield+47-128
   1326  23ce				  -	      lda	temp3
   1327  23ce				  -	      sta	playfield+46-128
   1328  23ce				  -	      lda	temp2
   1329  23ce				  -	      sta	playfield+45-128
   1330  23ce				  -	      lda	temp1
   1331  23ce				  -	      sta	playfield+44-128
   1332  23ce				  -	      endif
   1333  23ce					      else
   1334  23ce				  -	      ifconst	pfres
   1335  23ce				  -	      sta	playfield+pfres*4-1
   1336  23ce				  -	      lda	temp3
   1337  23ce				  -	      sta	playfield+pfres*4-2
   1338  23ce				  -	      lda	temp2
   1339  23ce				  -	      sta	playfield+pfres*4-3
   1340  23ce				  -	      lda	temp1
   1341  23ce				  -	      sta	playfield+pfres*4-4
   1342  23ce					      else
   1343  23ce		       85 d3		      sta	playfield+47
   1344  23d0		       a5 9e		      lda	temp3
   1345  23d2		       85 d2		      sta	playfield+46
   1346  23d4		       a5 9d		      lda	temp2
   1347  23d6		       85 d1		      sta	playfield+45
   1348  23d8		       a5 9c		      lda	temp1
   1349  23da		       85 d0		      sta	playfield+44
   1350  23dc					      endif
   1351  23dc					      endif
   1352  23dc				   noshiftdown2
      0  23dc					      RETURN
      1  23dc				  -	      ifnconst	bankswitch
      2  23dc				  -	      rts
      3  23dc					      else
      4  23dc		       4c dd ff 	      jmp	BS_return
      5  23df					      endif
   1354  23df
   1355  23df
   1356  23df				   notup
   1357  23df							;down
   1358  23df		       4a		      lsr
   1359  23e0		       b0 02		      bcs	oneincup
   1360  23e2		       e6 ef		      inc	playfieldpos
   1361  23e4				   oneincup
   1362  23e4		       e6 ef		      inc	playfieldpos
   1363  23e6		       a5 ef		      lda	playfieldpos
   1364  23e8
   1365  23e8				  -	      ifconst	pfrowheight
   1366  23e8				  -	      cmp	#pfrowheight+1
   1367  23e8					      else
   1368  23e8					      ifnconst	pfres
   1369  23e8		       c9 09		      cmp	#9
   1370  23ea				  -	      else
   1371  23ea				  -	      cmp	#(96/pfres)+1	; try to come close to the real size
   1372  23ea					      endif
   1373  23ea					      endif
   1374  23ea
   1375  23ea		       90 3b		      bcc	noshiftdown
   1376  23ec		       a9 01		      lda	#1
   1377  23ee		       85 ef		      sta	playfieldpos
   1378  23f0
   1379  23f0				  -	      ifconst	pfres
   1380  23f0				  -	      lda	playfield+pfres*4-1
   1381  23f0				  -	      sta	temp4
   1382  23f0				  -	      lda	playfield+pfres*4-2
   1383  23f0				  -	      sta	temp3
   1384  23f0				  -	      lda	playfield+pfres*4-3
   1385  23f0				  -	      sta	temp2
   1386  23f0				  -	      lda	playfield+pfres*4-4
   1387  23f0					      else
   1388  23f0		       a5 d3		      lda	playfield+47
   1389  23f2		       85 9f		      sta	temp4
   1390  23f4		       a5 d2		      lda	playfield+46
   1391  23f6		       85 9e		      sta	temp3
   1392  23f8		       a5 d1		      lda	playfield+45
   1393  23fa		       85 9d		      sta	temp2
   1394  23fc		       a5 d0		      lda	playfield+44
   1395  23fe					      endif
   1396  23fe
   1397  23fe		       85 9c		      sta	temp1
   1398  2400
   1399  2400				  -	      ifconst	pfres
   1400  2400				  -	      ldx	#(pfres-1)*4
   1401  2400					      else
   1402  2400		       a2 2c		      ldx	#44
   1403  2402					      endif
   1404  2402				   down2
   1405  2402		       b5 a3		      lda	playfield-1,x
   1406  2404				  -	      ifconst	superchip
   1407  2404				  -	      sta	playfield-125,x
   1408  2404				  -	      lda	playfield-2,x
   1409  2404				  -	      sta	playfield-126,x
   1410  2404				  -	      lda	playfield-3,x
   1411  2404				  -	      sta	playfield-127,x
   1412  2404				  -	      lda	playfield-4,x
   1413  2404				  -	      sta	playfield-128,x
   1414  2404					      else
   1415  2404		       95 a7		      sta	playfield+3,x
   1416  2406		       b5 a2		      lda	playfield-2,x
   1417  2408		       95 a6		      sta	playfield+2,x
   1418  240a		       b5 a1		      lda	playfield-3,x
   1419  240c		       95 a5		      sta	playfield+1,x
   1420  240e		       b5 a0		      lda	playfield-4,x
   1421  2410		       95 a4		      sta	playfield,x
   1422  2412					      endif
   1423  2412		       8a		      txa
   1424  2413		       cb 04		      sbx	#4
   1425  2415		       d0 eb		      bne	down2
   1426  2417
   1427  2417		       a5 9f		      lda	temp4
   1428  2419				  -	      ifconst	superchip
   1429  2419				  -	      sta	playfield-125
   1430  2419				  -	      lda	temp3
   1431  2419				  -	      sta	playfield-126
   1432  2419				  -	      lda	temp2
   1433  2419				  -	      sta	playfield-127
   1434  2419				  -	      lda	temp1
   1435  2419				  -	      sta	playfield-128
   1436  2419					      else
   1437  2419		       85 a7		      sta	playfield+3
   1438  241b		       a5 9e		      lda	temp3
   1439  241d		       85 a6		      sta	playfield+2
   1440  241f		       a5 9d		      lda	temp2
   1441  2421		       85 a5		      sta	playfield+1
   1442  2423		       a5 9c		      lda	temp1
   1443  2425		       85 a4		      sta	playfield
   1444  2427					      endif
   1445  2427				   noshiftdown
      0  2427					      RETURN
      1  2427				  -	      ifnconst	bankswitch
      2  2427				  -	      rts
      3  2427					      else
      4  2427		       4c dd ff 	      jmp	BS_return
      5  242a					      endif
   1447  242a							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1448  242a
   1449  242a							;standard routines needed for pretty much all games
   1450  242a							; just the random number generator is left - maybe we should remove this asm file altogether?
   1451  242a							; repositioning code and score pointer setup moved to overscan
   1452  242a							; read switches, joysticks now compiler generated (more efficient)
   1453  242a
   1454  242a				   randomize
   1455  242a		       a5 a2		      lda	rand
   1456  242c		       4a		      lsr
   1457  242d				  -	      ifconst	rand16
   1458  242d				  -	      rol	rand16
   1459  242d					      endif
   1460  242d		       90 02		      bcc	noeor
   1461  242f		       49 b4		      eor	#$B4
   1462  2431				   noeor
   1463  2431		       85 a2		      sta	rand
   1464  2433				  -	      ifconst	rand16
   1465  2433				  -	      eor	rand16
   1466  2433					      endif
      0  2433					      RETURN
      1  2433				  -	      ifnconst	bankswitch
      2  2433				  -	      rts
      3  2433					      else
      4  2433		       4c dd ff 	      jmp	BS_return
      5  2436					      endif
   1468  2436							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1469  2436
   1470  2436				   drawscreen
   1471  2436				  -	      ifconst	debugscore
   1472  2436				  -	      ldx	#14
   1473  2436				  -	      lda	INTIM	; display # cycles left in the score
   1474  2436				  -
   1475  2436				  -	      ifconst	mincycles
   1476  2436				  -	      lda	mincycles
   1477  2436				  -	      cmp	INTIM
   1478  2436				  -	      lda	mincycles
   1479  2436				  -	      bcc	nochange
   1480  2436				  -	      lda	INTIM
   1481  2436				  -	      sta	mincycles
   1482  2436				  -nochange
   1483  2436				  -	      endif
   1484  2436				  -
   1485  2436				  -			; cmp #$2B
   1486  2436				  -			; bcs no_cycles_left
   1487  2436				  -	      bmi	cycles_left
   1488  2436				  -	      ldx	#64
   1489  2436				  -	      eor	#$ff	;make negative
   1490  2436				  -cycles_left
   1491  2436				  -	      stx	scorecolor
   1492  2436				  -	      and	#$7f	; clear sign bit
   1493  2436				  -	      tax
   1494  2436				  -	      lda	scorebcd,x
   1495  2436				  -	      sta	score+2
   1496  2436				  -	      lda	scorebcd1,x
   1497  2436				  -	      sta	score+1
   1498  2436				  -	      jmp	done_debugscore
   1499  2436				  -scorebcd
   1500  2436				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   1501  2436				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   1502  2436				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   1503  2436				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   1504  2436				  -scorebcd1
   1505  2436				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   1506  2436				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   1507  2436				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   1508  2436				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   1509  2436				  -done_debugscore
   1510  2436					      endif
   1511  2436
   1512  2436				  -	      ifconst	debugcycles
   1513  2436				  -	      lda	INTIM	; if we go over, it mucks up the background color
   1514  2436				  -			; cmp #$2B
   1515  2436				  -			; BCC overscan
   1516  2436				  -	      bmi	overscan
   1517  2436				  -	      sta	COLUBK
   1518  2436				  -	      bcs	doneoverscan
   1519  2436					      endif
   1520  2436
   1521  2436				   overscan
   1522  2436				  -	      ifconst	interlaced
   1523  2436				  -	      PHP
   1524  2436				  -	      PLA
   1525  2436				  -	      EOR	#4	; flip interrupt bit
   1526  2436				  -	      PHA
   1527  2436				  -	      PLP
   1528  2436				  -	      AND	#4	; isolate the interrupt bit
   1529  2436				  -	      TAX		; save it for later
   1530  2436					      endif
   1531  2436
   1532  2436				   overscanloop
   1533  2436		       ad 84 02 	      lda	INTIM	;wait for sync
   1534  2439		       30 fb		      bmi	overscanloop
   1535  243b				   doneoverscan
   1536  243b
   1537  243b							;do VSYNC
   1538  243b
   1539  243b				  -	      ifconst	interlaced
   1540  243b				  -	      CPX	#4
   1541  243b				  -	      BNE	oddframevsync
   1542  243b					      endif
   1543  243b
   1544  243b		       a9 02		      lda	#2
   1545  243d		       85 02		      sta	WSYNC
   1546  243f		       85 00		      sta	VSYNC
   1547  2441		       85 02		      STA	WSYNC
   1548  2443		       85 02		      STA	WSYNC
   1549  2445		       4a		      lsr
   1550  2446		       85 02		      STA	WSYNC
   1551  2448		       85 00		      STA	VSYNC
   1552  244a		       85 01		      sta	VBLANK
   1553  244c					      ifnconst	overscan_time
   1554  244c		       a9 a5		      lda	#37+128
   1555  244e				  -	      else
   1556  244e				  -	      lda	#overscan_time+128
   1557  244e					      endif
   1558  244e		       8d 96 02 	      sta	TIM64T
   1559  2451
   1560  2451				  -	      ifconst	interlaced
   1561  2451				  -	      jmp	postsync
   1562  2451				  -
   1563  2451				  -oddframevsync
   1564  2451				  -	      sta	WSYNC
   1565  2451				  -
   1566  2451				  -	      LDA	($80,X)	; 11 waste
   1567  2451				  -	      LDA	($80,X)	; 11 waste
   1568  2451				  -	      LDA	($80,X)	; 11 waste
   1569  2451				  -
   1570  2451				  -	      lda	#2
   1571  2451				  -	      sta	VSYNC
   1572  2451				  -	      sta	WSYNC
   1573  2451				  -	      sta	WSYNC
   1574  2451				  -	      sta	WSYNC
   1575  2451				  -
   1576  2451				  -	      LDA	($80,X)	; 11 waste
   1577  2451				  -	      LDA	($80,X)	; 11 waste
   1578  2451				  -	      LDA	($80,X)	; 11 waste
   1579  2451				  -
   1580  2451				  -	      lda	#0
   1581  2451				  -	      sta	VSYNC
   1582  2451				  -	      sta	VBLANK
   1583  2451				  -	      ifnconst	overscan_time
   1584  2451				  -	      lda	#37+128
   1585  2451				  -	      else
   1586  2451				  -	      lda	#overscan_time+128
   1587  2451				  -	      endif
   1588  2451				  -	      sta	TIM64T
   1589  2451				  -
   1590  2451				  -postsync
   1591  2451					      endif
   1592  2451
   1593  2451				  -	      ifconst	legacy
   1594  2451				  -	      if	legacy < 100
   1595  2451				  -	      ldx	#4
   1596  2451				  -adjustloop
   1597  2451				  -	      lda	player0x,x
   1598  2451				  -	      sec
   1599  2451				  -	      sbc	#14	;?
   1600  2451				  -	      sta	player0x,x
   1601  2451				  -	      dex
   1602  2451				  -	      bpl	adjustloop
   1603  2451				  -	      endif
   1604  2451					      endif
   1605  2451				  -	      if	((<*)>$e9)&&((<*)<$fa)
   1606  2451				  -	      repeat	($fa-(<*))
   1607  2451				  -	      nop
   1608  2451				  -	      repend
   1609  2451					      endif
   1610  2451		       85 02		      sta	WSYNC
   1611  2453		       a2 04		      ldx	#4
      0  2455					      SLEEP	3
      1  2455				   .CYCLES    SET	3
      2  2455
      3  2455				  -	      IF	.CYCLES < 2
      4  2455				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2455				  -	      ERR
      6  2455					      ENDIF
      7  2455
      8  2455					      IF	.CYCLES & 1
      9  2455					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2455		       04 00		      nop	0
     11  2457				  -	      ELSE
     12  2457				  -	      bit	VSYNC
     13  2457					      ENDIF
     14  2457				   .CYCLES    SET	.CYCLES - 3
     15  2457					      ENDIF
     16  2457
     17  2457				  -	      REPEAT	.CYCLES / 2
     18  2457				  -	      nop
     19  2457					      REPEND
   1613  2457				   HorPosLoop		; 5
   1614  2457		       b5 80		      lda	player0x,X	;+4 9
   1615  2459		       38		      sec		;+2 11
   1616  245a				   DivideLoop
   1617  245a		       e9 0f		      sbc	#15
   1618  245c		       b0 fc		      bcs	DivideLoop	;+4 15
   1619  245e		       95 9c		      sta	temp1,X	;+4 19
   1620  2460		       95 10		      sta	RESP0,X	;+4 23
   1621  2462		       85 02		      sta	WSYNC
   1622  2464		       ca		      dex
   1623  2465		       10 f0		      bpl	HorPosLoop	;+5 5
   1624  2467							; 4
   1625  2467
   1626  2467		       a2 04		      ldx	#4
   1627  2469		       b4 9c		      ldy	temp1,X
   1628  246b		       b9 c7 f3 	      lda	repostable-256,Y
   1629  246e		       95 20		      sta	HMP0,X	;+14 18
   1630  2470
   1631  2470		       ca		      dex
   1632  2471		       b4 9c		      ldy	temp1,X
   1633  2473		       b9 c7 f3 	      lda	repostable-256,Y
   1634  2476		       95 20		      sta	HMP0,X	;+14 32
   1635  2478
   1636  2478		       ca		      dex
   1637  2479		       b4 9c		      ldy	temp1,X
   1638  247b		       b9 c7 f3 	      lda	repostable-256,Y
   1639  247e		       95 20		      sta	HMP0,X	;+14 46
   1640  2480
   1641  2480		       ca		      dex
   1642  2481		       b4 9c		      ldy	temp1,X
   1643  2483		       b9 c7 f3 	      lda	repostable-256,Y
   1644  2486		       95 20		      sta	HMP0,X	;+14 60
   1645  2488
   1646  2488		       ca		      dex
   1647  2489		       b4 9c		      ldy	temp1,X
   1648  248b		       b9 c7 f3 	      lda	repostable-256,Y
   1649  248e		       95 20		      sta	HMP0,X	;+14 74
   1650  2490
   1651  2490		       85 02		      sta	WSYNC
   1652  2492
   1653  2492		       85 2a		      sta	HMOVE	;+3 3
   1654  2494
   1655  2494
   1656  2494				  -	      ifconst	legacy
   1657  2494				  -	      if	legacy < 100
   1658  2494				  -	      ldx	#4
   1659  2494				  -adjustloop2
   1660  2494				  -	      lda	player0x,x
   1661  2494				  -	      clc
   1662  2494				  -	      adc	#14	;?
   1663  2494				  -	      sta	player0x,x
   1664  2494				  -	      dex
   1665  2494				  -	      bpl	adjustloop2
   1666  2494				  -	      endif
   1667  2494					      endif
   1668  2494
   1669  2494
   1670  2494
   1671  2494
   1672  2494							;set score pointers
   1673  2494		       a7 95		      lax	score+2
   1674  2496		       20 c7 f4 	      jsr	scorepointerset
   1675  2499		       84 9b		      sty	scorepointers+5
   1676  249b		       86 98		      stx	scorepointers+2
   1677  249d		       a7 94		      lax	score+1
   1678  249f		       20 c7 f4 	      jsr	scorepointerset
   1679  24a2		       84 9a		      sty	scorepointers+4
   1680  24a4		       86 97		      stx	scorepointers+1
   1681  24a6		       a7 93		      lax	score
   1682  24a8		       20 c7 f4 	      jsr	scorepointerset
   1683  24ab		       84 99		      sty	scorepointers+3
   1684  24ad		       86 96		      stx	scorepointers
   1685  24af
   1686  24af				   vblk
   1687  24af							; run possible vblank bB code
   1688  24af				  -	      ifconst	vblank_bB_code
   1689  24af				  -	      jsr	vblank_bB_code
   1690  24af					      endif
   1691  24af				   vblk2
   1692  24af		       ad 84 02 	      LDA	INTIM
   1693  24b2		       30 fb		      bmi	vblk2
   1694  24b4		       4c 00 f0 	      jmp	kernel
   1695  24b7
   1696  24b7
   1697  24b7		       80 70 60 50*	      .byte.b	$80,$70,$60,$50,$40,$30,$20,$10,$00
   1698  24c0		       f0 e0 d0 c0*	      .byte.b	$F0,$E0,$D0,$C0,$B0,$A0,$90
   1699  24c7				   repostable
   1700  24c7
   1701  24c7				   scorepointerset
   1702  24c7		       29 0f		      and	#$0F
   1703  24c9		       0a		      asl
   1704  24ca		       0a		      asl
   1705  24cb		       0a		      asl
   1706  24cc		       69 74		      adc	#<scoretable
   1707  24ce		       a8		      tay
   1708  24cf		       8a		      txa
   1709  24d0							; and #$F0
   1710  24d0							; lsr
   1711  24d0		       4b f0		      asr	#$F0
   1712  24d2		       69 74		      adc	#<scoretable
   1713  24d4		       aa		      tax
   1714  24d5		       60		      rts
   1715  24d6							;bB.asm
   1716  24d6							; bB.asm file is split here
   1717  24d6					      if	ECHOFIRST
      2718 bytes of ROM space left in bank 2
   1718  24d6					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 2")
   1719  24d6					      endif
   1720  24d6		       00 01	   ECHOFIRST  =	1
   1721  24d6
   1722  24d6
   1723  24d6							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1724  24d6
   1725  24d6							; feel free to modify the score graphics - just keep each digit 8 high
   1726  24d6							; and keep the conditional compilation stuff intact
   1727  24d6				  -	      ifconst	ROM2k
   1728  24d6				  -	      ORG	$F7AC-8
   1729  24d6					      else
   1730  24d6					      ifconst	bankswitch
   1731  24d6					      if	bankswitch == 8
   1732  2f74					      ORG	$2F94-bscode_length
   1733  2f74					      RORG	$FF94-bscode_length
   1734  2f74					      endif
   1735  2f74				  -	      if	bankswitch == 16
   1736  2f74				  -	      ORG	$4F94-bscode_length
   1737  2f74				  -	      RORG	$FF94-bscode_length
   1738  2f74					      endif
   1739  2f74				  -	      if	bankswitch == 32
   1740  2f74				  -	      ORG	$8F94-bscode_length
   1741  2f74				  -	      RORG	$FF94-bscode_length
   1742  2f74					      endif
   1743  2f74				  -	      if	bankswitch == 64
   1744  2f74				  -	      ORG	$10F80-bscode_length
   1745  2f74				  -	      RORG	$1FF80-bscode_length
   1746  2f74					      endif
   1747  2f74				  -	      else
   1748  2f74				  -	      ORG	$FF9C
   1749  2f74					      endif
   1750  2f74					      endif
   1751  2f74
   1752  2f74							; font equates
   1753  2f74		       00 01	   .21stcentury =	1
   1754  2f74		       00 02	   alarmclock =	2
   1755  2f74		       00 03	   handwritten =	3
   1756  2f74		       00 04	   interrupted =	4
   1757  2f74		       00 05	   retroputer =	5
   1758  2f74		       00 06	   whimsey    =	6
   1759  2f74		       00 07	   tiny       =	7
   1760  2f74		       00 08	   hex	      =	8
   1761  2f74
   1762  2f74				  -	      ifconst	font
   1763  2f74				  -	      if	font == hex
   1764  2f74				  -	      ORG	. - 48
   1765  2f74				  -	      endif
   1766  2f74					      endif
   1767  2f74
   1768  2f74				   scoretable
   1769  2f74
   1770  2f74				  -	      ifconst	font
   1771  2f74				  -	      if	font == .21stcentury
   1772  2f74				  -	      include	"score_graphics.asm.21stcentury"
   1773  2f74				  -	      endif
   1774  2f74				  -	      if	font == alarmclock
   1775  2f74				  -	      include	"score_graphics.asm.alarmclock"
   1776  2f74				  -	      endif
   1777  2f74				  -	      if	font == handwritten
   1778  2f74				  -	      include	"score_graphics.asm.handwritten"
   1779  2f74				  -	      endif
   1780  2f74				  -	      if	font == interrupted
   1781  2f74				  -	      include	"score_graphics.asm.interrupted"
   1782  2f74				  -	      endif
   1783  2f74				  -	      if	font == retroputer
   1784  2f74				  -	      include	"score_graphics.asm.retroputer"
   1785  2f74				  -	      endif
   1786  2f74				  -	      if	font == whimsey
   1787  2f74				  -	      include	"score_graphics.asm.whimsey"
   1788  2f74				  -	      endif
   1789  2f74				  -	      if	font == tiny
   1790  2f74				  -	      include	"score_graphics.asm.tiny"
   1791  2f74				  -	      endif
   1792  2f74				  -	      if	font == hex
   1793  2f74				  -	      include	"score_graphics.asm.hex"
   1794  2f74				  -	      endif
   1795  2f74					      else		; default font
   1796  2f74
   1797  2f74		       3c		      .byte.b	%00111100
   1798  2f75		       66		      .byte.b	%01100110
   1799  2f76		       66		      .byte.b	%01100110
   1800  2f77		       66		      .byte.b	%01100110
   1801  2f78		       66		      .byte.b	%01100110
   1802  2f79		       66		      .byte.b	%01100110
   1803  2f7a		       66		      .byte.b	%01100110
   1804  2f7b		       3c		      .byte.b	%00111100
   1805  2f7c
   1806  2f7c		       7e		      .byte.b	%01111110
   1807  2f7d		       18		      .byte.b	%00011000
   1808  2f7e		       18		      .byte.b	%00011000
   1809  2f7f		       18		      .byte.b	%00011000
   1810  2f80		       18		      .byte.b	%00011000
   1811  2f81		       38		      .byte.b	%00111000
   1812  2f82		       18		      .byte.b	%00011000
   1813  2f83		       08		      .byte.b	%00001000
   1814  2f84
   1815  2f84		       7e		      .byte.b	%01111110
   1816  2f85		       60		      .byte.b	%01100000
   1817  2f86		       60		      .byte.b	%01100000
   1818  2f87		       3c		      .byte.b	%00111100
   1819  2f88		       06		      .byte.b	%00000110
   1820  2f89		       06		      .byte.b	%00000110
   1821  2f8a		       46		      .byte.b	%01000110
   1822  2f8b		       3c		      .byte.b	%00111100
   1823  2f8c
   1824  2f8c		       3c		      .byte.b	%00111100
   1825  2f8d		       46		      .byte.b	%01000110
   1826  2f8e		       06		      .byte.b	%00000110
   1827  2f8f		       06		      .byte.b	%00000110
   1828  2f90		       1c		      .byte.b	%00011100
   1829  2f91		       06		      .byte.b	%00000110
   1830  2f92		       46		      .byte.b	%01000110
   1831  2f93		       3c		      .byte.b	%00111100
   1832  2f94
   1833  2f94		       0c		      .byte.b	%00001100
   1834  2f95		       0c		      .byte.b	%00001100
   1835  2f96		       7e		      .byte.b	%01111110
   1836  2f97		       4c		      .byte.b	%01001100
   1837  2f98		       4c		      .byte.b	%01001100
   1838  2f99		       2c		      .byte.b	%00101100
   1839  2f9a		       1c		      .byte.b	%00011100
   1840  2f9b		       0c		      .byte.b	%00001100
   1841  2f9c
   1842  2f9c		       3c		      .byte.b	%00111100
   1843  2f9d		       46		      .byte.b	%01000110
   1844  2f9e		       06		      .byte.b	%00000110
   1845  2f9f		       06		      .byte.b	%00000110
   1846  2fa0		       3c		      .byte.b	%00111100
   1847  2fa1		       60		      .byte.b	%01100000
   1848  2fa2		       60		      .byte.b	%01100000
   1849  2fa3		       7e		      .byte.b	%01111110
   1850  2fa4
   1851  2fa4		       3c		      .byte.b	%00111100
   1852  2fa5		       66		      .byte.b	%01100110
   1853  2fa6		       66		      .byte.b	%01100110
   1854  2fa7		       66		      .byte.b	%01100110
   1855  2fa8		       7c		      .byte.b	%01111100
   1856  2fa9		       60		      .byte.b	%01100000
   1857  2faa		       62		      .byte.b	%01100010
   1858  2fab		       3c		      .byte.b	%00111100
   1859  2fac
   1860  2fac		       30		      .byte.b	%00110000
   1861  2fad		       30		      .byte.b	%00110000
   1862  2fae		       30		      .byte.b	%00110000
   1863  2faf		       18		      .byte.b	%00011000
   1864  2fb0		       0c		      .byte.b	%00001100
   1865  2fb1		       06		      .byte.b	%00000110
   1866  2fb2		       42		      .byte.b	%01000010
   1867  2fb3		       3e		      .byte.b	%00111110
   1868  2fb4
   1869  2fb4		       3c		      .byte.b	%00111100
   1870  2fb5		       66		      .byte.b	%01100110
   1871  2fb6		       66		      .byte.b	%01100110
   1872  2fb7		       66		      .byte.b	%01100110
   1873  2fb8		       3c		      .byte.b	%00111100
   1874  2fb9		       66		      .byte.b	%01100110
   1875  2fba		       66		      .byte.b	%01100110
   1876  2fbb		       3c		      .byte.b	%00111100
   1877  2fbc
   1878  2fbc		       3c		      .byte.b	%00111100
   1879  2fbd		       46		      .byte.b	%01000110
   1880  2fbe		       06		      .byte.b	%00000110
   1881  2fbf		       3e		      .byte.b	%00111110
   1882  2fc0		       66		      .byte.b	%01100110
   1883  2fc1		       66		      .byte.b	%01100110
   1884  2fc2		       66		      .byte.b	%01100110
   1885  2fc3		       3c		      .byte.b	%00111100
   1886  2fc4
   1887  2fc4					      ifnconst	DPC_kernel_options
   1888  2fc4
   1889  2fc4		       00		      .byte.b	%00000000
   1890  2fc5		       00		      .byte.b	%00000000
   1891  2fc6		       00		      .byte.b	%00000000
   1892  2fc7		       00		      .byte.b	%00000000
   1893  2fc8		       00		      .byte.b	%00000000
   1894  2fc9		       00		      .byte.b	%00000000
   1895  2fca		       00		      .byte.b	%00000000
   1896  2fcb		       00		      .byte.b	%00000000
   1897  2fcc
   1898  2fcc					      endif
   1899  2fcc
   1900  2fcc					      endif
   1901  2fcc
   1902  2fcc				  -	      ifconst	ROM2k
   1903  2fcc				  -	      ORG	$F7FC
   1904  2fcc					      else
   1905  2fcc					      ifconst	bankswitch
   1906  2fcc					      if	bankswitch == 8
   1907  2fd4					      ORG	$2FF4-bscode_length
   1908  2fd4					      RORG	$FFF4-bscode_length
   1909  2fd4					      endif
   1910  2fd4				  -	      if	bankswitch == 16
   1911  2fd4				  -	      ORG	$4FF4-bscode_length
   1912  2fd4				  -	      RORG	$FFF4-bscode_length
   1913  2fd4					      endif
   1914  2fd4				  -	      if	bankswitch == 32
   1915  2fd4				  -	      ORG	$8FF4-bscode_length
   1916  2fd4				  -	      RORG	$FFF4-bscode_length
   1917  2fd4					      endif
   1918  2fd4				  -	      if	bankswitch == 64
   1919  2fd4				  -	      ORG	$10FE0-bscode_length
   1920  2fd4				  -	      RORG	$1FFE0-bscode_length
   1921  2fd4					      endif
   1922  2fd4				  -	      else
   1923  2fd4				  -	      ORG	$FFFC
   1924  2fd4					      endif
   1925  2fd4					      endif
   1926  2fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1927  2fd4
   1928  2fd4							; every bank has this stuff at the same place
   1929  2fd4							; this code can switch to/from any bank at any entry point
   1930  2fd4							; and can preserve register values
   1931  2fd4							; note: lines not starting with a space are not placed in all banks
   1932  2fd4							;
   1933  2fd4							; line below tells the compiler how long this is - do not remove
   1934  2fd4							;size=32
   1935  2fd4
   1936  2fd4				   begin_bscode
   1937  2fd4		       a2 ff		      ldx	#$ff
   1938  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1939  2fd6				  -	      stx	FASTFETCH
   1940  2fd6					      endif
   1941  2fd6		       9a		      txs
   1942  2fd7				  -	      if	bankswitch == 64
   1943  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1944  2fd7					      else
   1945  2fd7		       a9 f2		      lda	#>(start-1)
   1946  2fd9					      endif
   1947  2fd9		       48		      pha
   1948  2fda		       a9 4f		      lda	#<(start-1)
   1949  2fdc		       48		      pha
   1950  2fdd
   1951  2fdd				   BS_return
   1952  2fdd		       48		      pha
   1953  2fde		       8a		      txa
   1954  2fdf		       48		      pha
   1955  2fe0		       ba		      tsx
   1956  2fe1
   1957  2fe1					      if	bankswitch != 64
   1958  2fe1		       b5 04		      lda	4,x	; get high byte of return address
   1959  2fe3
   1960  2fe3		       2a		      rol
   1961  2fe4		       2a		      rol
   1962  2fe5		       2a		      rol
   1963  2fe6		       2a		      rol
   1964  2fe7		       29 01		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1965  2fe9		       aa		      tax
   1966  2fea		       e8		      inx
   1967  2feb				  -	      else
   1968  2feb				  -	      lda	4,x	; get high byte of return address
   1969  2feb				  -	      tay
   1970  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1971  2feb				  -	      sta	4,x
   1972  2feb				  -	      tya
   1973  2feb				  -	      lsr
   1974  2feb				  -	      lsr
   1975  2feb				  -	      lsr
   1976  2feb				  -	      lsr
   1977  2feb				  -	      tax
   1978  2feb				  -	      inx
   1979  2feb					      endif
   1980  2feb
   1981  2feb				   BS_jsr
   1982  2feb		       bd f7 1f 	      lda	bankswitch_hotspot-1,x
   1983  2fee		       68		      pla
   1984  2fef		       aa		      tax
   1985  2ff0		       68		      pla
   1986  2ff1		       60		      rts
   1987  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1988  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1989  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1990  2ff2					      endif
   1991  2ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1992  2ff2
   1993  2ff2					      ifconst	bankswitch
   1994  2ff2					      if	bankswitch == 8
   1995  2ffc					      ORG	$2FFC
   1996  2ffc					      RORG	$FFFC
   1997  2ffc					      endif
   1998  2ffc				  -	      if	bankswitch == 16
   1999  2ffc				  -	      ORG	$4FFC
   2000  2ffc				  -	      RORG	$FFFC
   2001  2ffc					      endif
   2002  2ffc				  -	      if	bankswitch == 32
   2003  2ffc				  -	      ORG	$8FFC
   2004  2ffc				  -	      RORG	$FFFC
   2005  2ffc					      endif
   2006  2ffc				  -	      if	bankswitch == 64
   2007  2ffc				  -	      ORG	$10FF0
   2008  2ffc				  -	      RORG	$1FFF0
   2009  2ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   2010  2ffc				  -	      ORG	$10FF8
   2011  2ffc				  -	      RORG	$1FFF8
   2012  2ffc				  -	      ifconst	superchip
   2013  2ffc				  -	      .byte	"E","F","S","C"
   2014  2ffc				  -	      else
   2015  2ffc				  -	      .byte	"E","F","E","F"
   2016  2ffc				  -	      endif
   2017  2ffc				  -	      ORG	$10FFC
   2018  2ffc				  -	      RORG	$1FFFC
   2019  2ffc					      endif
   2020  2ffc				  -	      else
   2021  2ffc				  -	      ifconst	ROM2k
   2022  2ffc				  -	      ORG	$F7FC
   2023  2ffc				  -	      else
   2024  2ffc				  -	      ORG	$FFFC
   2025  2ffc				  -	      endif
   2026  2ffc					      endif
   2027  2ffc		       50 f2		      .word.w	(start & $ffff)
   2028  2ffe		       50 f2		      .word.w	(start & $ffff)
