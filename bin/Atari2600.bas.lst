------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\Atari-2600-Game\Atari2600.bas.asm LEVEL 1 PASS 2
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  3000 ????				      include	"vcs.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; VCS.H
      4  3000 ????						; Version 1.05, 13/November/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_VCS =	105
      7  3000 ????
      8  3000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines hardware registers and memory mapping for the
     13  3000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  3000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  3000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  3000 ????						; with your views.  Please contribute, if you think you can improve this
     21  3000 ????						; file!
     22  3000 ????						;
     23  3000 ????						; Latest Revisions...
     24  3000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  3000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  3000 ????						;			    This will allow conditional code to verify VCS.H being
     27  3000 ????						;			    used for code assembly.
     28  3000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  3000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  3000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  3000 ????						;			 readability issue, and binary compatibility with disassembled
     32  3000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  3000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  3000 ????						;			 which was broken by the use of segments in this file, as
     35  3000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  3000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  3000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  3000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  3000 ????						;						   it is safe to leave it undefined, and the base address will
     40  3000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  3000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  3000 ????						;			  - register definitions are now generated through assignment
     43  3000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  3000 ????						;			    address architecture.
     45  3000 ????						; 1.0	22/MAR/2003		Initial release
     46  3000 ????
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????
     50  3000 ????						; TIA_BASE_ADDRESS
     51  3000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  3000 ????						; Normally 0, the base address should (externally, before including this file)
     53  3000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  3000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  3000 ????						; < $40 as a bankswitch.
     56  3000 ????
     57  3000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  3000 ????			  -TIA_BASE_ADDRESS =	0
     59  3000 ????				      ENDIF
     60  3000 ????
     61  3000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  3000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  3000 ????						; *OR* by declaring the label before including this file, eg:
     64  3000 ????						; TIA_BASE_ADDRESS = $40
     65  3000 ????						;   include "vcs.h"
     66  3000 ????
     67  3000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  3000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  3000 ????						; for the mirrored ROM hardware registers.
     70  3000 ????
     71  3000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  3000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  3000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  3000 ????
     75  3000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  3000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  3000 ????				      ENDIF
     78  3000 ????
     79  3000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  3000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  3000 ????				      ENDIF
     82  3000 ????
     83  3000 ????						;-------------------------------------------------------------------------------
     84  3000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  3000 ????				      SEG
    201  3000 ????
    202  3000 ????						; EOF
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\Atari-2600-Game\Atari2600.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  3000 ????				      include	"macro.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; MACRO.H
      4  3000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_MACRO =	105
      7  3000 ????
      8  3000 ????						;
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  3000 ????						; It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  3000 ????						; contents, or would like to add something, please write to me
     19  3000 ????						; (atari2600@taswegian.com) with your contribution.
     20  3000 ????						;
     21  3000 ????						; Latest Revisions...
     22  3000 ????						;
     23  3000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  3000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  3000 ????						;			    used for code assembly.
     26  3000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  3000 ????						;
     28  3000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  3000 ????						;
     30  3000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  3000 ????						;			   (standardised macro for vertical synch code)
     32  3000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  3000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  3000 ????						; 1.0	22/MAR/2003		Initial release
     35  3000 ????
     36  3000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  3000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  3000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  3000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  3000 ????						;   registers and require them to be defined first).
     41  3000 ????
     42  3000 ????						; Available macros...
     43  3000 ????						;   SLEEP n		 - sleep for n cycles
     44  3000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  3000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  3000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????						; SLEEP duration
     50  3000 ????						; Original author: Thomas Jentzsch
     51  3000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  3000 ????						; useful for code where precise timing is required.
     53  3000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  3000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  3000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  3000 ????
     57  3000 ????				      MAC	sleep
     58  3000 ????			   .CYCLES    SET	{1}
     59  3000 ????
     60  3000 ????				      IF	.CYCLES < 2
     61  3000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  3000 ????				      ERR
     63  3000 ????				      ENDIF
     64  3000 ????
     65  3000 ????				      IF	.CYCLES & 1
     66  3000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  3000 ????				      nop	0
     68  3000 ????				      ELSE
     69  3000 ????				      bit	VSYNC
     70  3000 ????				      ENDIF
     71  3000 ????			   .CYCLES    SET	.CYCLES - 3
     72  3000 ????				      ENDIF
     73  3000 ????
     74  3000 ????				      REPEAT	.CYCLES / 2
     75  3000 ????				      nop
     76  3000 ????				      REPEND
     77  3000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  3000 ????
     79  3000 ????						;-------------------------------------------------------------------------------
     80  3000 ????						; VERTICAL_SYNC
     81  3000 ????						; Original author: Manuel Polik
     82  3000 ????						; Inserts the code required for a proper 3 scannline 
     83  3000 ????						; vertical sync sequence
     84  3000 ????						;
     85  3000 ????						; Note: Alters the accumulator
     86  3000 ????						;
     87  3000 ????						; IN:
     88  3000 ????						; OUT: A = 1
     89  3000 ????
     90  3000 ????				      MAC	vertical_sync
     91  3000 ????				      LDA	#$02	; A = VSYNC enable
     92  3000 ????				      STA	WSYNC	; Finish current line
     93  3000 ????				      STA	VSYNC	; Start vertical sync
     94  3000 ????				      STA	WSYNC	; 1st line vertical sync
     95  3000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  3000 ????				      LSR		; A = VSYNC disable
     97  3000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  3000 ????				      STA	VSYNC	; Stop vertical sync
     99  3000 ????				      ENDM
    100  3000 ????
    101  3000 ????						;-------------------------------------------------------------------------------
    102  3000 ????						; CLEAN_START
    103  3000 ????						; Original author: Andrew Davie
    104  3000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  3000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  3000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  3000 ????						; Use as very first section of code on boot (ie: at reset)
    108  3000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  3000 ????
    110  3000 ????				      MAC	clean_start
    111  3000 ????				      sei
    112  3000 ????				      cld
    113  3000 ????
    114  3000 ????				      ldx	#0
    115  3000 ????				      txa
    116  3000 ????				      tay
    117  3000 ????			   .CLEAR_STACK dex
    118  3000 ????				      txs
    119  3000 ????				      pha
    120  3000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  3000 ????
    122  3000 ????				      ENDM
    123  3000 ????
    124  3000 ????						;-------------------------------------------------------
    125  3000 ????						; SET_POINTER
    126  3000 ????						; Original author: Manuel Rotschkar
    127  3000 ????						;
    128  3000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  3000 ????						;
    130  3000 ????						; Usage: SET_POINTER pointer, address
    131  3000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  3000 ????						;
    133  3000 ????						; Note: Alters the accumulator, NZ flags
    134  3000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  3000 ????						; IN 2: absolute address
    136  3000 ????
    137  3000 ????				      MAC	set_pointer
    138  3000 ????			   .POINTER   SET	{1}
    139  3000 ????			   .ADDRESS   SET	{2}
    140  3000 ????
    141  3000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  3000 ????				      STA	.POINTER	; Store in pointer
    143  3000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  3000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  3000 ????
    146  3000 ????				      ENDM
    147  3000 ????
    148  3000 ????						; EOF
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\Atari-2600-Game\Atari2600.bas.asm
------- FILE 2600basic.h LEVEL 2 PASS 2
      0  3000 ????				      include	"2600basic.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????				      processor	6502
------- FILE vcs.h LEVEL 3 PASS 2
      0  3000 ????				      include	"vcs.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; VCS.H
      4  3000 ????						; Version 1.05, 13/November/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_VCS =	105
      7  3000 ????
      8  3000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines hardware registers and memory mapping for the
     13  3000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  3000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  3000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  3000 ????						; with your views.  Please contribute, if you think you can improve this
     21  3000 ????						; file!
     22  3000 ????						;
     23  3000 ????						; Latest Revisions...
     24  3000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  3000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  3000 ????						;			    This will allow conditional code to verify VCS.H being
     27  3000 ????						;			    used for code assembly.
     28  3000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  3000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  3000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  3000 ????						;			 readability issue, and binary compatibility with disassembled
     32  3000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  3000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  3000 ????						;			 which was broken by the use of segments in this file, as
     35  3000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  3000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  3000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  3000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  3000 ????						;						   it is safe to leave it undefined, and the base address will
     40  3000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  3000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  3000 ????						;			  - register definitions are now generated through assignment
     43  3000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  3000 ????						;			    address architecture.
     45  3000 ????						; 1.0	22/MAR/2003		Initial release
     46  3000 ????
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????
     50  3000 ????						; TIA_BASE_ADDRESS
     51  3000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  3000 ????						; Normally 0, the base address should (externally, before including this file)
     53  3000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  3000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  3000 ????						; < $40 as a bankswitch.
     56  3000 ????
     57  3000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  3000 ????			  -TIA_BASE_ADDRESS =	0
     59  3000 ????				      ENDIF
     60  3000 ????
     61  3000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  3000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  3000 ????						; *OR* by declaring the label before including this file, eg:
     64  3000 ????						; TIA_BASE_ADDRESS = $40
     65  3000 ????						;   include "vcs.h"
     66  3000 ????
     67  3000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  3000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  3000 ????						; for the mirrored ROM hardware registers.
     70  3000 ????
     71  3000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  3000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  3000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  3000 ????
     75  3000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  3000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  3000 ????				      ENDIF
     78  3000 ????
     79  3000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  3000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  3000 ????				      ENDIF
     82  3000 ????
     83  3000 ????						;-------------------------------------------------------------------------------
     84  3000 ????
     85 U002d					      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e					      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298					      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  3000 ????				      SEG
    201  3000 ????
    202  3000 ????						; EOF
------- FILE 2600basic.h
------- FILE macro.h LEVEL 3 PASS 2
      0  3000 ????				      include	"macro.h"
      1  3000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  3000 ????
      3  3000 ????						; MACRO.H
      4  3000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  3000 ????
      6  3000 ????	       00 69	   VERSION_MACRO =	105
      7  3000 ????
      8  3000 ????						;
      9  3000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  3000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  3000 ????						;
     12  3000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  3000 ????						; It is distributed as a companion machine-specific support package
     14  3000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  3000 ????						; available at at http://www.atari2600.org/dasm
     16  3000 ????						;
     17  3000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  3000 ????						; contents, or would like to add something, please write to me
     19  3000 ????						; (atari2600@taswegian.com) with your contribution.
     20  3000 ????						;
     21  3000 ????						; Latest Revisions...
     22  3000 ????						;
     23  3000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  3000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  3000 ????						;			    used for code assembly.
     26  3000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  3000 ????						;
     28  3000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  3000 ????						;
     30  3000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  3000 ????						;			   (standardised macro for vertical synch code)
     32  3000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  3000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  3000 ????						; 1.0	22/MAR/2003		Initial release
     35  3000 ????
     36  3000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  3000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  3000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  3000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  3000 ????						;   registers and require them to be defined first).
     41  3000 ????
     42  3000 ????						; Available macros...
     43  3000 ????						;   SLEEP n		 - sleep for n cycles
     44  3000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  3000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  3000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  3000 ????
     48  3000 ????						;-------------------------------------------------------------------------------
     49  3000 ????						; SLEEP duration
     50  3000 ????						; Original author: Thomas Jentzsch
     51  3000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  3000 ????						; useful for code where precise timing is required.
     53  3000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  3000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  3000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  3000 ????
     57  3000 ????				      MAC	sleep
     58  3000 ????			   .CYCLES    SET	{1}
     59  3000 ????
     60  3000 ????				      IF	.CYCLES < 2
     61  3000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  3000 ????				      ERR
     63  3000 ????				      ENDIF
     64  3000 ????
     65  3000 ????				      IF	.CYCLES & 1
     66  3000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  3000 ????				      nop	0
     68  3000 ????				      ELSE
     69  3000 ????				      bit	VSYNC
     70  3000 ????				      ENDIF
     71  3000 ????			   .CYCLES    SET	.CYCLES - 3
     72  3000 ????				      ENDIF
     73  3000 ????
     74  3000 ????				      REPEAT	.CYCLES / 2
     75  3000 ????				      nop
     76  3000 ????				      REPEND
     77  3000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  3000 ????
     79  3000 ????						;-------------------------------------------------------------------------------
     80  3000 ????						; VERTICAL_SYNC
     81  3000 ????						; Original author: Manuel Polik
     82  3000 ????						; Inserts the code required for a proper 3 scannline 
     83  3000 ????						; vertical sync sequence
     84  3000 ????						;
     85  3000 ????						; Note: Alters the accumulator
     86  3000 ????						;
     87  3000 ????						; IN:
     88  3000 ????						; OUT: A = 1
     89  3000 ????
     90  3000 ????				      MAC	vertical_sync
     91  3000 ????				      LDA	#$02	; A = VSYNC enable
     92  3000 ????				      STA	WSYNC	; Finish current line
     93  3000 ????				      STA	VSYNC	; Start vertical sync
     94  3000 ????				      STA	WSYNC	; 1st line vertical sync
     95  3000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  3000 ????				      LSR		; A = VSYNC disable
     97  3000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  3000 ????				      STA	VSYNC	; Stop vertical sync
     99  3000 ????				      ENDM
    100  3000 ????
    101  3000 ????						;-------------------------------------------------------------------------------
    102  3000 ????						; CLEAN_START
    103  3000 ????						; Original author: Andrew Davie
    104  3000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  3000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  3000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  3000 ????						; Use as very first section of code on boot (ie: at reset)
    108  3000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  3000 ????
    110  3000 ????				      MAC	clean_start
    111  3000 ????				      sei
    112  3000 ????				      cld
    113  3000 ????
    114  3000 ????				      ldx	#0
    115  3000 ????				      txa
    116  3000 ????				      tay
    117  3000 ????			   .CLEAR_STACK dex
    118  3000 ????				      txs
    119  3000 ????				      pha
    120  3000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  3000 ????
    122  3000 ????				      ENDM
    123  3000 ????
    124  3000 ????						;-------------------------------------------------------
    125  3000 ????						; SET_POINTER
    126  3000 ????						; Original author: Manuel Rotschkar
    127  3000 ????						;
    128  3000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  3000 ????						;
    130  3000 ????						; Usage: SET_POINTER pointer, address
    131  3000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  3000 ????						;
    133  3000 ????						; Note: Alters the accumulator, NZ flags
    134  3000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  3000 ????						; IN 2: absolute address
    136  3000 ????
    137  3000 ????				      MAC	set_pointer
    138  3000 ????			   .POINTER   SET	{1}
    139  3000 ????			   .ADDRESS   SET	{2}
    140  3000 ????
    141  3000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  3000 ????				      STA	.POINTER	; Store in pointer
    143  3000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  3000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  3000 ????
    146  3000 ????				      ENDM
    147  3000 ????
    148  3000 ????						; EOF
------- FILE 2600basic.h
------- FILE 2600basic_variable_redefs.h LEVEL 3 PASS 2
      0  3000 ????				      include	"2600basic_variable_redefs.h"
      1  3000 ????						; This file contains variable mapping and other information for the current project.
      2  3000 ????
      3  3000 ????	       00 01	   no_blank_lines =	1
      4  3000 ????	       00 20	   bscode_length =	32
      5  3000 ????	       00 01	   bs_mask    =	1
      6  3000 ????	       00 08	   bankswitch =	8
      7  3000 ????	       1f f8	   bankswitch_hotspot =	$1FF8
------- FILE 2600basic.h
      7  3000 ????
      8  3000 ????	       00 80	   player0x   =	$80
      9  3000 ????	       00 81	   player1x   =	$81
     10  3000 ????	       00 82	   missile0x  =	$82
     11  3000 ????	       00 83	   missile1x  =	$83
     12  3000 ????	       00 84	   ballx      =	$84
     13  3000 ????
     14  3000 ????	       00 85	   objecty    =	$85
     15  3000 ????	       00 85	   player0y   =	$85
     16  3000 ????	       00 86	   player1y   =	$86
     17  3000 ????	       00 87	   missile1height =	$87
     18  3000 ????	       00 88	   missile1y  =	$88
     19  3000 ????	       00 89	   bally      =	$89
     20  3000 ????
     21  3000 ????	       00 87	   player1color =	$87	; replaces missile 1
     22  3000 ????
     23  3000 ????	       00 8a	   player0pointer =	$8A	;uses $8A-$8B
     24  3000 ????	       00 8a	   player0pointerlo =	$8A
     25  3000 ????	       00 8b	   player0pointerhi =	$8B
     26  3000 ????	       00 8c	   player1pointer =	$8C	; $8C-$8D
     27  3000 ????	       00 8c	   player1pointerlo =	$8C
     28  3000 ????	       00 8d	   player1pointerhi =	$8D
     29  3000 ????
     30  3000 ????	       00 8e	   player0height =	$8E
     31  3000 ????	       00 8f	   player1height =	$8F
     32  3000 ????	       00 90	   missile0height =	$90
     33  3000 ????	       00 91	   missile0y  =	$91
     34  3000 ????	       00 92	   ballheight =	$92
     35  3000 ????
     36  3000 ????	       00 90	   currentpaddle =	$90	; replaces missile 0 (and can't be used with playercolor)
     37  3000 ????	       00 91	   paddle     =	$91	; replaces missile 0
     38  3000 ????	       00 82	   player0colorstore =	$82	; replaces missile 0
     39  3000 ????	       00 90	   player0color =	$90	; replaces missile 0
     40  3000 ????
     41  3000 ????	       00 93	   score      =	$93	; $93-$95
     42  3000 ????	       00 96	   scorepointers =	$96	; $96-$9B = 6 bytes
     43  3000 ????	       00 9c	   temp1      =	$9C	;used by kernel.  can be used in program too, but
     44  3000 ????	       00 9d	   temp2      =	$9D	;are obliterated when drawscreen is called.
     45  3000 ????	       00 9e	   temp3      =	$9E
     46  3000 ????	       00 9f	   temp4      =	$9F
     47  3000 ????	       00 a0	   temp5      =	$A0
     48  3000 ????	       00 a1	   temp6      =	$A1
     49  3000 ????
     50  3000 ????	       00 a2	   rand       =	$A2
     51  3000 ????	       00 a3	   scorecolor =	$A3
     52  3000 ????
     53  3000 ????	       00 a4	   var0       =	$A4
     54  3000 ????	       00 a5	   var1       =	$A5
     55  3000 ????	       00 a6	   var2       =	$A6
     56  3000 ????	       00 a7	   var3       =	$A7
     57  3000 ????	       00 a8	   var4       =	$A8
     58  3000 ????	       00 a9	   var5       =	$A9
     59  3000 ????	       00 aa	   var6       =	$AA
     60  3000 ????	       00 ab	   var7       =	$AB
     61  3000 ????	       00 ac	   var8       =	$AC
     62  3000 ????	       00 ad	   var9       =	$AD
     63  3000 ????	       00 ae	   var10      =	$AE
     64  3000 ????	       00 af	   var11      =	$AF
     65  3000 ????	       00 b0	   var12      =	$B0
     66  3000 ????	       00 b1	   var13      =	$B1
     67  3000 ????	       00 b2	   var14      =	$B2
     68  3000 ????	       00 b3	   var15      =	$B3
     69  3000 ????	       00 b4	   var16      =	$B4
     70  3000 ????	       00 b5	   var17      =	$B5
     71  3000 ????	       00 b6	   var18      =	$B6
     72  3000 ????	       00 b7	   var19      =	$B7
     73  3000 ????	       00 b8	   var20      =	$B8
     74  3000 ????	       00 b9	   var21      =	$B9
     75  3000 ????	       00 ba	   var22      =	$BA
     76  3000 ????	       00 bb	   var23      =	$BB
     77  3000 ????	       00 bc	   var24      =	$BC
     78  3000 ????	       00 bd	   var25      =	$BD
     79  3000 ????	       00 be	   var26      =	$BE
     80  3000 ????	       00 bf	   var27      =	$BF
     81  3000 ????	       00 c0	   var28      =	$C0
     82  3000 ????	       00 c1	   var29      =	$C1
     83  3000 ????	       00 c2	   var30      =	$C2
     84  3000 ????	       00 c3	   var31      =	$C3
     85  3000 ????	       00 c4	   var32      =	$C4
     86  3000 ????	       00 c5	   var33      =	$C5
     87  3000 ????	       00 c6	   var34      =	$C6
     88  3000 ????	       00 c7	   var35      =	$C7
     89  3000 ????	       00 c8	   var36      =	$C8
     90  3000 ????	       00 c9	   var37      =	$C9
     91  3000 ????	       00 ca	   var38      =	$CA
     92  3000 ????	       00 cb	   var39      =	$CB
     93  3000 ????	       00 cc	   var40      =	$CC
     94  3000 ????	       00 cd	   var41      =	$CD
     95  3000 ????	       00 ce	   var42      =	$CE
     96  3000 ????	       00 cf	   var43      =	$CF
     97  3000 ????	       00 d0	   var44      =	$D0
     98  3000 ????	       00 d1	   var45      =	$D1
     99  3000 ????	       00 d2	   var46      =	$D2
    100  3000 ????	       00 d3	   var47      =	$D3
    101  3000 ????
    102  3000 ????	       00 d4	   A	      =	$d4
    103  3000 ????	       00 d4	   a	      =	$d4
    104  3000 ????	       00 d5	   B	      =	$d5
    105  3000 ????	       00 d5	   b	      =	$d5
    106  3000 ????	       00 d6	   C	      =	$d6
    107  3000 ????	       00 d6	   c	      =	$d6
    108  3000 ????	       00 d7	   D	      =	$d7
    109  3000 ????	       00 d7	   d	      =	$d7
    110  3000 ????	       00 d8	   E	      =	$d8
    111  3000 ????	       00 d8	   e	      =	$d8
    112  3000 ????	       00 d9	   F	      =	$d9
    113  3000 ????	       00 d9	   f	      =	$d9
    114  3000 ????	       00 da	   G	      =	$da
    115  3000 ????	       00 da	   g	      =	$da
    116  3000 ????	       00 db	   H	      =	$db
    117  3000 ????	       00 db	   h	      =	$db
    118  3000 ????	       00 dc	   I	      =	$dc
    119  3000 ????	       00 dc	   i	      =	$dc
    120  3000 ????	       00 dd	   J	      =	$dd
    121  3000 ????	       00 dd	   j	      =	$dd
    122  3000 ????	       00 de	   K	      =	$de
    123  3000 ????	       00 de	   k	      =	$de
    124  3000 ????	       00 df	   L	      =	$df
    125  3000 ????	       00 df	   l	      =	$df
    126  3000 ????	       00 e0	   M	      =	$e0
    127  3000 ????	       00 e0	   m	      =	$e0
    128  3000 ????	       00 e1	   N	      =	$e1
    129  3000 ????	       00 e1	   n	      =	$e1
    130  3000 ????	       00 e2	   O	      =	$e2
    131  3000 ????	       00 e2	   o	      =	$e2
    132  3000 ????	       00 e3	   P	      =	$e3
    133  3000 ????	       00 e3	   p	      =	$e3
    134  3000 ????	       00 e4	   Q	      =	$e4
    135  3000 ????	       00 e4	   q	      =	$e4
    136  3000 ????	       00 e5	   R	      =	$e5
    137  3000 ????	       00 e5	   r	      =	$e5
    138  3000 ????	       00 e6	   S	      =	$e6
    139  3000 ????	       00 e6	   s	      =	$e6
    140  3000 ????	       00 e7	   T	      =	$e7
    141  3000 ????	       00 e7	   t	      =	$e7
    142  3000 ????	       00 e8	   U	      =	$e8
    143  3000 ????	       00 e8	   u	      =	$e8
    144  3000 ????	       00 e9	   V	      =	$e9
    145  3000 ????	       00 e9	   v	      =	$e9
    146  3000 ????	       00 ea	   W	      =	$ea
    147  3000 ????	       00 ea	   w	      =	$ea
    148  3000 ????	       00 eb	   X	      =	$eb
    149  3000 ????	       00 eb	   x	      =	$eb
    150  3000 ????	       00 ec	   Y	      =	$ec
    151  3000 ????	       00 ec	   y	      =	$ec
    152  3000 ????	       00 ed	   Z	      =	$ed
    153  3000 ????	       00 ed	   z	      =	$ed
    154  3000 ????
    155  3000 ????	       00 ee	   temp7      =	$ee	; This is used to aid in bankswitching
    156  3000 ????	       00 ef	   playfieldpos =	$ef
    157  3000 ????
    158  3000 ????						; available for other uses, or if unused, provide more stack space
    159  3000 ????
    160  3000 ????	       00 f0	   aux1       =	$f0
    161  3000 ????	       00 f1	   aux2       =	$f1
    162  3000 ????	       00 f2	   aux3       =	$f2
    163  3000 ????	       00 f3	   aux4       =	$f3
    164  3000 ????	       00 f4	   aux5       =	$f4
    165  3000 ????	       00 f5	   aux6       =	$f5
    166  3000 ????
    167  3000 ????						; playfield color/height pointers
    168  3000 ????	       00 f0	   pfcolortable =	$f0	; and $d5
    169  3000 ????	       00 f0	   pfheighttable =	$f0	; and $d5
    170  3000 ????						; the above pointers are the same because if color and height are both used together,
    171  3000 ????						; they must used absolute indexed and cannot use pointers
    172  3000 ????
    173  3000 ????	       00 f2	   lifepointer =	$f2	; pointer to "lives" shape
    174  3000 ????						; upper 3 bits of $f2 contain the number of lives
    175  3000 ????	       00 f4	   lifecolor  =	$f4
    176  3000 ????	       00 f3	   lives      =	$f3	; # lives >> 5
    177  3000 ????	       00 f5	   statusbarlength =	$f5	; only uses upper 5 bits; other bits free
    178  3000 ????
    179  3000 ????	       00 f2	   pfscore1   =	$f2	; optional playfield bytes in score
    180  3000 ????	       00 f3	   pfscore2   =	$f3
    181  3000 ????	       00 f4	   pfscorecolor =	$f4
    182  3000 ????
    183  3000 ????	       00 f6	   stack1     =	$f6
    184  3000 ????	       00 f7	   stack2     =	$f7
    185  3000 ????	       00 f8	   stack3     =	$f8
    186  3000 ????	       00 f9	   stack4     =	$f9
    187  3000 ????						; the stack bytes above may be used in the kernel
    188  3000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    189  3000 ????
    190  3000 ????				      MAC	return
    191  3000 ????				      ifnconst	bankswitch
    192  3000 ????				      rts
    193  3000 ????				      else
    194  3000 ????				      jmp	BS_return
    195  3000 ????				      endif
    196  3000 ????				      ENDM		; auto-return from either a regular or bankswitched module
    197  3000 ????
    198  3000 ????			  -	      ifconst	superchip
    199  3000 ????			  -playfieldbase =	$10D0
    200  3000 ????			  -	      include	superchip.h
    201  3000 ????				      else
    202  3000 ????	       00 a4	   playfieldbase =	$A4
    203  3000 ????				      endif
    204  3000 ????
    205  3000 ????				      ifnconst	pfhalfwidth
    206  3000 ????	       00 04	   pfwidth    =	4
    207  3000 ????	       00 0e	   PF1L       =	PF1
    208  3000 ????	       00 0f	   PF2L       =	PF2
    209  3000 ????	       00 0e	   PF1R       =	PF1
    210  3000 ????	       00 0f	   PF2R       =	PF2
    211  3000 ????	       00 00	   pfadjust   =	0
    212  3000 ????			  -	      else
    213  3000 ????			  -pfwidth    =	2
    214  3000 ????			  -	      ifconst	pfcenter
    215  3000 ????			  -PF1L       =	$3F	; no effect
    216  3000 ????			  -PF2L       =	PF2
    217  3000 ????			  -PF1R       =	$3F
    218  3000 ????			  -PF2R       =	PF2	; no effect
    219  3000 ????			  -pfadjust   =	1
    220  3000 ????			  -	      else
    221  3000 ????			  -PF1L       =	PF1
    222  3000 ????			  -PF2L       =	PF2
    223  3000 ????			  -PF1R       =	$3F	; no effect
    224  3000 ????			  -PF2R       =	$3F	; no effect
    225  3000 ????			  -pfadjust   =	0
    226  3000 ????			  -	      endif
    227  3000 ????				      endif
    228  3000 ????
    229  3000 ????						; define playfield start based on height
    230  3000 ????				      ifnconst	pfres
    231  3000 ????	       00 a4	   playfield  =	playfieldbase
    232  3000 ????			  -	      else
    233  3000 ????			  -playfield  =	playfieldbase-(pfres-12*(4/pfwidth))*pfwidth
    234  3000 ????				      endif
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\Atari-2600-Game\Atari2600.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  3000 ????				      include	"2600basic_variable_redefs.h"
      1  3000 ????						; This file contains variable mapping and other information for the current project.
      2  3000 ????
      3  3000 ????	       00 01	   no_blank_lines =	1
      4  3000 ????	       00 20	   bscode_length =	32
      5  3000 ????	       00 01	   bs_mask    =	1
      6  3000 ????	       00 08	   bankswitch =	8
      7  3000 ????	       1f f8	   bankswitch_hotspot =	$1FF8
------- FILE c:\Users\start\OneDrive\Documents\Visual Code Workspace\Atari-2600-Game\Atari2600.bas.asm
      8  3000 ????				      ifconst	bankswitch
      9  3000 ????				      if	bankswitch == 8
     10  1000					      ORG	$1000
     11  1000					      RORG	$D000
     12  1000					      endif
     13  1000				  -	      if	bankswitch == 16
     14  1000				  -	      ORG	$1000
     15  1000				  -	      RORG	$9000
     16  1000					      endif
     17  1000				  -	      if	bankswitch == 32
     18  1000				  -	      ORG	$1000
     19  1000				  -	      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000
     29  1000					      ifconst	bankswitch_hotspot
     30  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  1000				  -	      .byte	0	; stop unexpected bankswitches
     32  1000					      endif
     33  1000					      endif
     34  1000				   game
     35  1000				   .L00 		;  set romsize 8k
     36  1000
     37  1000				   .L01 		;  bank 2
     38  1000
     39  1000					      if	ECHO1
      4052 bytes of ROM space left in bank 1
     40  1000					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
     41  1000					      endif
     42  1000		       00 01	   ECHO1      =	1
     43  1fd4					      ORG	$1FF4-bscode_length
     44  1fd4					      RORG	$DFF4-bscode_length
     45  1fd4		       a2 ff	   start_bank1 ldx	#$ff
     46  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
     47  1fd6				  -	      stx	FASTFETCH
     48  1fd6					      endif
     49  1fd6		       9a		      txs
     50  1fd7				  -	      if	bankswitch == 64
     51  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
     52  1fd7					      else
     53  1fd7		       a9 f2		      lda	#>(start-1)
     54  1fd9					      endif
     55  1fd9		       48		      pha
     56  1fda		       a9 4f		      lda	#<(start-1)
     57  1fdc		       48		      pha
     58  1fdd		       48		      pha
     59  1fde		       8a		      txa
     60  1fdf		       48		      pha
     61  1fe0		       ba		      tsx
     62  1fe1					      if	bankswitch != 64
     63  1fe1		       b5 04		      lda	4,x	; get high byte of return address
     64  1fe3		       2a		      rol
     65  1fe4		       2a		      rol
     66  1fe5		       2a		      rol
     67  1fe6		       2a		      rol
     68  1fe7		       29 01		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
     69  1fe9		       aa		      tax
     70  1fea		       e8		      inx
     71  1feb				  -	      else
     72  1feb				  -	      lda	4,x	; get high byte of return address
     73  1feb				  -	      tay
     74  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
     75  1feb				  -	      sta	4,x
     76  1feb				  -	      tya
     77  1feb				  -	      lsr
     78  1feb				  -	      lsr
     79  1feb				  -	      lsr
     80  1feb				  -	      lsr
     81  1feb				  -	      tax
     82  1feb				  -	      inx
     83  1feb					      endif
     84  1feb		       bd f7 1f 	      lda	bankswitch_hotspot-1,x
     85  1fee		       68		      pla
     86  1fef		       aa		      tax
     87  1ff0		       68		      pla
     88  1ff1		       60		      rts
     89  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
     90  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
     91  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
     92  1ff2					      endif
     93  1ffc					      ORG	$1FFC
     94  1ffc					      RORG	$DFFC
     95  1ffc		       d4 df		      .word.w	(start_bank1 & $ffff)
     96  1ffe		       d4 df		      .word.w	(start_bank1 & $ffff)
     97  2000					      ORG	$2000
     98  2000					      RORG	$F000
     99  2000							; Provided under the CC0 license. See the included LICENSE.txt for details.
    100  2000
    101  2000							; This is a 2-line kernel!
    102  2000					      ifnconst	vertical_reflect
    103  2000				   kernel
    104  2000					      endif
    105  2000		       85 02		      sta	WSYNC
    106  2002		       a9 ff		      lda	#255
    107  2004		       8d 96 02 	      sta	TIM64T
    108  2007
    109  2007		       a9 01		      lda	#1
    110  2009		       85 27		      sta	VDELBL
    111  200b		       85 25		      sta	VDELP0
    112  200d		       a6 92		      ldx	ballheight
    113  200f		       e8		      inx
    114  2010		       e8		      inx
    115  2011		       86 9f		      stx	temp4
    116  2013		       a5 86		      lda	player1y
    117  2015		       85 9e		      sta	temp3
    118  2017
    119  2017				  -	      ifconst	shakescreen
    120  2017				  -	      jsr	doshakescreen
    121  2017					      else
    122  2017		       a6 90		      ldx	missile0height
    123  2019		       e8		      inx
    124  201a					      endif
    125  201a
    126  201a		       e8		      inx
    127  201b		       86 f6		      stx	stack1
    128  201d
    129  201d		       a5 89		      lda	bally
    130  201f		       85 f7		      sta	stack2
    131  2021
    132  2021		       a5 85		      lda	player0y
    133  2023		       a2 00		      ldx	#0
    134  2025		       85 02		      sta	WSYNC
    135  2027		       86 1b		      stx	GRP0
    136  2029		       86 1c		      stx	GRP1
    137  202b		       86 0e		      stx	PF1L
    138  202d		       86 0f		      stx	PF2
    139  202f		       86 2c		      stx	CXCLR
    140  2031				  -	      ifconst	readpaddle
    141  2031				  -	      stx	paddle
    142  2031					      else
      0  2031					      sleep	3
      1  2031				   .CYCLES    SET	3
      2  2031
      3  2031				  -	      IF	.CYCLES < 2
      4  2031				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2031				  -	      ERR
      6  2031					      ENDIF
      7  2031
      8  2031					      IF	.CYCLES & 1
      9  2031					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2031		       04 00		      nop	0
     11  2033				  -	      ELSE
     12  2033				  -	      bit	VSYNC
     13  2033					      ENDIF
     14  2033				   .CYCLES    SET	.CYCLES - 3
     15  2033					      ENDIF
     16  2033
     17  2033				  -	      REPEAT	.CYCLES / 2
     18  2033				  -	      nop
     19  2033					      REPEND
    144  2033					      endif
    145  2033
    146  2033		       95 9d		      sta	temp2,x
    147  2035
    148  2035							;store these so they can be retrieved later
    149  2035					      ifnconst	pfres
    150  2035		       a2 54		      ldx	#128-44+(4-pfwidth)*12
    151  2037				  -	      else
    152  2037				  -	      ldx	#132-pfres*pfwidth
    153  2037					      endif
    154  2037
    155  2037		       c6 85		      dec	player0y
    156  2039
    157  2039		       a5 91		      lda	missile0y
    158  203b		       85 a0		      sta	temp5
    159  203d		       a5 88		      lda	missile1y
    160  203f		       85 a1		      sta	temp6
    161  2041
    162  2041		       a5 ef		      lda	playfieldpos
    163  2043		       85 9c		      sta	temp1
    164  2045
    165  2045				  -	      ifconst	pfrowheight
    166  2045				  -	      lda	#pfrowheight+2
    167  2045					      else
    168  2045					      ifnconst	pfres
    169  2045		       a9 0a		      lda	#10
    170  2047				  -	      else
    171  2047				  -	      lda	#(96/pfres)+2	; try to come close to the real size
    172  2047					      endif
    173  2047					      endif
    174  2047		       18		      clc
    175  2048		       e5 ef		      sbc	playfieldpos
    176  204a		       85 ef		      sta	playfieldpos
    177  204c		       4c 74 f0 	      jmp	.startkernel
    178  204f
    179  204f				   .skipDrawP0
    180  204f		       a9 00		      lda	#0
    181  2051		       a8		      tay
    182  2052		       4c a2 f0 	      jmp	.continueP0
    183  2055
    184  2055				   .skipDrawP1
    185  2055		       a9 00		      lda	#0
    186  2057		       a8		      tay
    187  2058		       4c 7e f0 	      jmp	.continueP1
    188  205b
    189  205b				   .kerloop		; enter at cycle 59??
    190  205b
    191  205b				   continuekernel
      0  205b					      sleep	2
      1  205b				   .CYCLES    SET	2
      2  205b
      3  205b				  -	      IF	.CYCLES < 2
      4  205b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  205b				  -	      ERR
      6  205b					      ENDIF
      7  205b
      8  205b				  -	      IF	.CYCLES & 1
      9  205b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  205b				  -	      nop	0
     11  205b				  -	      ELSE
     12  205b				  -	      bit	VSYNC
     13  205b				  -	      ENDIF
     14  205b				  -.CYCLES    SET	.CYCLES - 3
     15  205b					      ENDIF
     16  205b
     17  205b					      REPEAT	.CYCLES / 2
     18  205b		       ea		      nop
     19  205c					      REPEND
    193  205c				   continuekernel2
    194  205c		       a5 92		      lda	ballheight
    195  205e
    196  205e				  -	      ifconst	pfres
    197  205e				  -	      ldy	playfield+pfres*pfwidth-132,x
    198  205e				  -	      sty	PF1L	;3
    199  205e				  -	      ldy	playfield+pfres*pfwidth-131-pfadjust,x
    200  205e				  -	      sty	PF2L	;3
    201  205e				  -	      ldy	playfield+pfres*pfwidth-129,x
    202  205e				  -	      sty	PF1R	; 3 too early?
    203  205e				  -	      ldy	playfield+pfres*pfwidth-130-pfadjust,x
    204  205e				  -	      sty	PF2R	;3
    205  205e					      else
    206  205e		       b4 50		      ldy	playfield-48+pfwidth*12+44-128,x
    207  2060		       84 0e		      sty	PF1L	;3
    208  2062		       b4 51		      ldy	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
    209  2064		       84 0f		      sty	PF2L	;3
    210  2066		       b4 53		      ldy	playfield-48+pfwidth*12+47-128,x	;4
    211  2068		       84 0e		      sty	PF1R	; 3 too early?
    212  206a		       b4 52		      ldy	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
    213  206c		       84 0f		      sty	PF2R	;3
    214  206e					      endif
    215  206e
    216  206e							; should be playfield+$38 for width=2
    217  206e
    218  206e		       c7 89		      dcp	bally
    219  2070		       2a		      rol
    220  2071		       2a		      rol
    221  2072							; rol
    222  2072							; rol
    223  2072				   goback
    224  2072		       85 1f		      sta	ENABL
    225  2074				   .startkernel
    226  2074		       a5 8f		      lda	player1height	;3
    227  2076		       c7 86		      dcp	player1y	;5
    228  2078		       90 db		      bcc	.skipDrawP1	;2
    229  207a		       a4 86		      ldy	player1y	;3
    230  207c		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
    231  207e							; so it doesn't cross a page boundary!
    232  207e
    233  207e				   .continueP1
    234  207e		       85 1c		      sta	GRP1	;3
    235  2080
    236  2080					      ifnconst	player1colors
    237  2080		       a5 87		      lda	missile1height	;3
    238  2082		       c7 88		      dcp	missile1y	;5
    239  2084		       2a		      rol		;2
    240  2085		       2a		      rol		;2
    241  2086		       85 1e		      sta	ENAM1	;3
    242  2088				  -	      else
    243  2088				  -	      lda	(player1color),y
    244  2088				  -	      sta	COLUP1
    245  2088				  -	      ifnconst	playercolors
    246  2088				  -	      sleep	7
    247  2088				  -	      else
    248  2088				  -	      lda.w	player0colorstore
    249  2088				  -	      sta	COLUP0
    250  2088				  -	      endif
    251  2088					      endif
    252  2088
    253  2088				  -	      ifconst	pfres
    254  2088				  -	      lda	playfield+pfres*pfwidth-132,x
    255  2088				  -	      sta	PF1L	;3
    256  2088				  -	      lda	playfield+pfres*pfwidth-131-pfadjust,x
    257  2088				  -	      sta	PF2L	;3
    258  2088				  -	      lda	playfield+pfres*pfwidth-129,x
    259  2088				  -	      sta	PF1R	; 3 too early?
    260  2088				  -	      lda	playfield+pfres*pfwidth-130-pfadjust,x
    261  2088				  -	      sta	PF2R	;3
    262  2088					      else
    263  2088		       b5 50		      lda	playfield-48+pfwidth*12+44-128,x	;4
    264  208a		       85 0e		      sta	PF1L	;3
    265  208c		       b5 51		      lda	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
    266  208e		       85 0f		      sta	PF2L	;3
    267  2090		       b5 53		      lda	playfield-48+pfwidth*12+47-128,x	;4
    268  2092		       85 0e		      sta	PF1R	; 3 too early?
    269  2094		       b5 52		      lda	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
    270  2096		       85 0f		      sta	PF2R	;3
    271  2098					      endif
    272  2098							; sleep 3
    273  2098
    274  2098		       a5 8e		      lda	player0height
    275  209a		       c7 85		      dcp	player0y
    276  209c		       90 b1		      bcc	.skipDrawP0
    277  209e		       a4 85		      ldy	player0y
    278  20a0		       b1 8a		      lda	(player0pointer),y
    279  20a2				   .continueP0
    280  20a2		       85 1b		      sta	GRP0
    281  20a4
    282  20a4				  -	      ifnconst	no_blank_lines
    283  20a4				  -	      ifnconst	playercolors
    284  20a4				  -	      lda	missile0height	;3
    285  20a4				  -	      dcp	missile0y	;5
    286  20a4				  -	      sbc	stack1
    287  20a4				  -	      sta	ENAM0	;3
    288  20a4				  -	      else
    289  20a4				  -	      lda	(player0color),y
    290  20a4				  -	      sta	player0colorstore
    291  20a4				  -	      sleep	6
    292  20a4				  -	      endif
    293  20a4				  -	      dec	temp1
    294  20a4				  -	      bne	continuekernel
    295  20a4					      else
    296  20a4		       c6 9c		      dec	temp1
    297  20a6		       f0 09		      beq	altkernel2
    298  20a8				  -	      ifconst	readpaddle
    299  20a8				  -	      ldy	currentpaddle
    300  20a8				  -	      lda	INPT0,y
    301  20a8				  -	      bpl	noreadpaddle
    302  20a8				  -	      inc	paddle
    303  20a8				  -	      jmp	continuekernel2
    304  20a8				  -noreadpaddle
    305  20a8				  -	      sleep	2
    306  20a8				  -	      jmp	continuekernel
    307  20a8					      else
    308  20a8					      ifnconst	playercolors
    309  20a8				  -	      ifconst	PFcolors
    310  20a8				  -	      txa
    311  20a8				  -	      tay
    312  20a8				  -	      lda	(pfcolortable),y
    313  20a8				  -	      ifnconst	backgroundchange
    314  20a8				  -	      sta	COLUPF
    315  20a8				  -	      else
    316  20a8				  -	      sta	COLUBK
    317  20a8				  -	      endif
    318  20a8				  -	      jmp	continuekernel
    319  20a8					      else
    320  20a8				  -	      ifconst	kernelmacrodef
    321  20a8				  -	      kernelmacro
    322  20a8					      else
      0  20a8					      sleep	12
      1  20a8				   .CYCLES    SET	12
      2  20a8
      3  20a8				  -	      IF	.CYCLES < 2
      4  20a8				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20a8				  -	      ERR
      6  20a8					      ENDIF
      7  20a8
      8  20a8				  -	      IF	.CYCLES & 1
      9  20a8				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  20a8				  -	      nop	0
     11  20a8				  -	      ELSE
     12  20a8				  -	      bit	VSYNC
     13  20a8				  -	      ENDIF
     14  20a8				  -.CYCLES    SET	.CYCLES - 3
     15  20a8					      ENDIF
     16  20a8
     17  20a8					      REPEAT	.CYCLES / 2
     18  20a8		       ea		      nop
     17  20a8					      REPEND
     18  20a9		       ea		      nop
     17  20a9					      REPEND
     18  20aa		       ea		      nop
     17  20aa					      REPEND
     18  20ab		       ea		      nop
     17  20ab					      REPEND
     18  20ac		       ea		      nop
     17  20ac					      REPEND
     18  20ad		       ea		      nop
     19  20ae					      REPEND
    324  20ae					      endif
    325  20ae					      endif
    326  20ae				  -	      else
    327  20ae				  -	      lda	(player0color),y
    328  20ae				  -	      sta	player0colorstore
    329  20ae				  -	      sleep	4
    330  20ae					      endif
    331  20ae		       4c 5b f0 	      jmp	continuekernel
    332  20b1					      endif
    333  20b1				   altkernel2
    334  20b1		       8a		      txa
    335  20b2					      ifnconst	vertical_reflect
    336  20b2		       cb fc		      sbx	#256-pfwidth
    337  20b4				  -	      else
    338  20b4				  -	      sbx	#256-pfwidth/2
    339  20b4					      endif
    340  20b4		       30 1b		      bmi	lastkernelline
    341  20b6				  -	      ifconst	pfrowheight
    342  20b6				  -	      lda	#pfrowheight
    343  20b6					      else
    344  20b6					      ifnconst	pfres
    345  20b6		       a9 08		      lda	#8
    346  20b8				  -	      else
    347  20b8				  -	      lda	#(96/pfres)	; try to come close to the real size
    348  20b8					      endif
    349  20b8					      endif
    350  20b8		       85 9c		      sta	temp1
    351  20ba		       4c 5b f0 	      jmp	continuekernel
    352  20bd					      endif
    353  20bd
    354  20bd				   altkernel
    355  20bd
    356  20bd				  -	      ifconst	PFmaskvalue
    357  20bd				  -	      lda	#PFmaskvalue
    358  20bd					      else
    359  20bd		       a9 00		      lda	#0
    360  20bf					      endif
    361  20bf		       85 0e		      sta	PF1L
    362  20c1		       85 0f		      sta	PF2
    363  20c3
    364  20c3
    365  20c3							;sleep 3
    366  20c3
    367  20c3							;28 cycles to fix things
    368  20c3							;minus 11=17
    369  20c3
    370  20c3							; lax temp4
    371  20c3							; clc
    372  20c3		       8a		      txa
    373  20c4					      ifnconst	vertical_reflect
    374  20c4		       cb fc		      sbx	#256-pfwidth
    375  20c6				  -	      else
    376  20c6				  -	      sbx	#256-pfwidth/2
    377  20c6					      endif
    378  20c6
    379  20c6		       30 09		      bmi	lastkernelline
    380  20c8
    381  20c8				  -	      ifconst	PFcolorandheight
    382  20c8				  -	      ifconst	pfres
    383  20c8				  -	      ldy	playfieldcolorandheight-131+pfres*pfwidth,x
    384  20c8				  -	      else
    385  20c8				  -	      ldy	playfieldcolorandheight-87,x
    386  20c8				  -	      endif
    387  20c8				  -	      ifnconst	backgroundchange
    388  20c8				  -	      sty	COLUPF
    389  20c8				  -	      else
    390  20c8				  -	      sty	COLUBK
    391  20c8				  -	      endif
    392  20c8				  -	      ifconst	pfres
    393  20c8				  -	      lda	playfieldcolorandheight-132+pfres*pfwidth,x
    394  20c8				  -	      else
    395  20c8				  -	      lda	playfieldcolorandheight-88,x
    396  20c8				  -	      endif
    397  20c8				  -	      sta.w	temp1
    398  20c8					      endif
    399  20c8				  -	      ifconst	PFheights
    400  20c8				  -	      lsr
    401  20c8				  -	      lsr
    402  20c8				  -	      tay
    403  20c8				  -	      lda	(pfheighttable),y
    404  20c8				  -	      sta.w	temp1
    405  20c8					      endif
    406  20c8				  -	      ifconst	PFcolors
    407  20c8				  -	      tay
    408  20c8				  -	      lda	(pfcolortable),y
    409  20c8				  -	      ifnconst	backgroundchange
    410  20c8				  -	      sta	COLUPF
    411  20c8				  -	      else
    412  20c8				  -	      sta	COLUBK
    413  20c8				  -	      endif
    414  20c8				  -	      ifconst	pfrowheight
    415  20c8				  -	      lda	#pfrowheight
    416  20c8				  -	      else
    417  20c8				  -	      ifnconst	pfres
    418  20c8				  -	      lda	#8
    419  20c8				  -	      else
    420  20c8				  -	      lda	#(96/pfres)	; try to come close to the real size
    421  20c8				  -	      endif
    422  20c8				  -	      endif
    423  20c8				  -	      sta	temp1
    424  20c8					      endif
    425  20c8					      ifnconst	PFcolorandheight
    426  20c8					      ifnconst	PFcolors
    427  20c8					      ifnconst	PFheights
    428  20c8				  -	      ifnconst	no_blank_lines
    429  20c8				  -			; read paddle 0
    430  20c8				  -			; lo-res paddle read
    431  20c8				  -			; bit INPT0
    432  20c8				  -			; bmi paddleskipread
    433  20c8				  -			; inc paddle0
    434  20c8				  -			;donepaddleskip
    435  20c8				  -	      sleep	10
    436  20c8				  -	      ifconst	pfrowheight
    437  20c8				  -	      lda	#pfrowheight
    438  20c8				  -	      else
    439  20c8				  -	      ifnconst	pfres
    440  20c8				  -	      lda	#8
    441  20c8				  -	      else
    442  20c8				  -	      lda	#(96/pfres)	; try to come close to the real size
    443  20c8				  -	      endif
    444  20c8				  -	      endif
    445  20c8				  -	      sta	temp1
    446  20c8					      endif
    447  20c8					      endif
    448  20c8					      endif
    449  20c8					      endif
    450  20c8
    451  20c8
    452  20c8		       a5 92		      lda	ballheight
    453  20ca		       c7 89		      dcp	bally
    454  20cc		       e5 9f		      sbc	temp4
    455  20ce
    456  20ce
    457  20ce		       4c 72 f0 	      jmp	goback
    458  20d1
    459  20d1
    460  20d1				  -	      ifnconst	no_blank_lines
    461  20d1				  -lastkernelline
    462  20d1				  -	      ifnconst	PFcolors
    463  20d1				  -	      sleep	10
    464  20d1				  -	      else
    465  20d1				  -	      ldy	#124
    466  20d1				  -	      lda	(pfcolortable),y
    467  20d1				  -	      sta	COLUPF
    468  20d1				  -	      endif
    469  20d1				  -
    470  20d1				  -	      ifconst	PFheights
    471  20d1				  -	      ldx	#1
    472  20d1				  -			;sleep 4
    473  20d1				  -	      sleep	3	; this was over 1 cycle
    474  20d1				  -	      else
    475  20d1				  -	      ldx	playfieldpos
    476  20d1				  -			;sleep 3
    477  20d1				  -	      sleep	2	; this was over 1 cycle
    478  20d1				  -	      endif
    479  20d1				  -
    480  20d1				  -	      jmp	enterlastkernel
    481  20d1				  -
    482  20d1					      else
    483  20d1				   lastkernelline
    484  20d1
    485  20d1				  -	      ifconst	PFheights
    486  20d1				  -	      ldx	#1
    487  20d1				  -			;sleep 5
    488  20d1				  -	      sleep	4	; this was over 1 cycle
    489  20d1					      else
    490  20d1		       a6 ef		      ldx	playfieldpos
    491  20d3							;sleep 4
      0  20d3					      sleep	3	; this was over 1 cycle
      1  20d3				   .CYCLES    SET	3
      2  20d3
      3  20d3				  -	      IF	.CYCLES < 2
      4  20d3				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20d3				  -	      ERR
      6  20d3					      ENDIF
      7  20d3
      8  20d3					      IF	.CYCLES & 1
      9  20d3					      IFNCONST	NO_ILLEGAL_OPCODES
     10  20d3		       04 00		      nop	0
     11  20d5				  -	      ELSE
     12  20d5				  -	      bit	VSYNC
     13  20d5					      ENDIF
     14  20d5				   .CYCLES    SET	.CYCLES - 3
     15  20d5					      ENDIF
     16  20d5
     17  20d5				  -	      REPEAT	.CYCLES / 2
     18  20d5				  -	      nop
     19  20d5					      REPEND
    493  20d5					      endif
    494  20d5
    495  20d5		       e0 00		      cpx	#0
    496  20d7		       d0 2e		      bne	.enterfromNBL
    497  20d9		       4c 68 f1 	      jmp	no_blank_lines_bailout
    498  20dc					      endif
    499  20dc
    500  20dc					      if	((<*)>$d5)
    501  2100		       00 00 00 00*	      align	256
    502  2100					      endif
    503  2100							; this is a kludge to prevent page wrapping - fix!!!
    504  2100
    505  2100				   .skipDrawlastP1
    506  2100		       a9 00		      lda	#0
    507  2102		       a8		      tay		; added so we don't cross a page
    508  2103		       4c 2d f1 	      jmp	.continuelastP1
    509  2106
    510  2106				   .endkerloop		; enter at cycle 59??
    511  2106
    512  2106		       ea		      nop
    513  2107
    514  2107				   .enterfromNBL
    515  2107				  -	      ifconst	pfres
    516  2107				  -	      ldy.w	playfield+pfres*pfwidth-4
    517  2107				  -	      sty	PF1L	;3
    518  2107				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
    519  2107				  -	      sty	PF2L	;3
    520  2107				  -	      ldy.w	playfield+pfres*pfwidth-1
    521  2107				  -	      sty	PF1R	; possibly too early?
    522  2107				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
    523  2107				  -	      sty	PF2R	;3
    524  2107					      else
    525  2107		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
    526  210a		       84 0e		      sty	PF1L	;3
    527  210c		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
    528  210f		       84 0f		      sty	PF2L	;3
    529  2111		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
    530  2114		       84 0e		      sty	PF1R	; possibly too early?
    531  2116		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
    532  2119		       84 0f		      sty	PF2R	;3
    533  211b					      endif
    534  211b
    535  211b				   enterlastkernel
    536  211b		       a5 92		      lda	ballheight
    537  211d
    538  211d							; tya
    539  211d		       c7 89		      dcp	bally
    540  211f							; sleep 4
    541  211f
    542  211f							; sbc stack3
    543  211f		       2a		      rol
    544  2120		       2a		      rol
    545  2121		       85 1f		      sta	ENABL
    546  2123
    547  2123		       a5 8f		      lda	player1height	;3
    548  2125		       c7 86		      dcp	player1y	;5
    549  2127		       90 d7		      bcc	.skipDrawlastP1
    550  2129		       a4 86		      ldy	player1y	;3
    551  212b		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
    552  212d							; so it doesn't cross a page boundary!
    553  212d
    554  212d				   .continuelastP1
    555  212d		       85 1c		      sta	GRP1	;3
    556  212f
    557  212f					      ifnconst	player1colors
    558  212f		       a5 87		      lda	missile1height	;3
    559  2131		       c7 88		      dcp	missile1y	;5
    560  2133				  -	      else
    561  2133				  -	      lda	(player1color),y
    562  2133				  -	      sta	COLUP1
    563  2133					      endif
    564  2133
    565  2133		       ca		      dex
    566  2134							;dec temp4 ; might try putting this above PF writes
    567  2134		       f0 34		      beq	endkernel
    568  2136
    569  2136
    570  2136				  -	      ifconst	pfres
    571  2136				  -	      ldy.w	playfield+pfres*pfwidth-4
    572  2136				  -	      sty	PF1L	;3
    573  2136				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
    574  2136				  -	      sty	PF2L	;3
    575  2136				  -	      ldy.w	playfield+pfres*pfwidth-1
    576  2136				  -	      sty	PF1R	; possibly too early?
    577  2136				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
    578  2136				  -	      sty	PF2R	;3
    579  2136					      else
    580  2136		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
    581  2139		       84 0e		      sty	PF1L	;3
    582  213b		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
    583  213e		       84 0f		      sty	PF2L	;3
    584  2140		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
    585  2143		       84 0e		      sty	PF1R	; possibly too early?
    586  2145		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
    587  2148		       84 0f		      sty	PF2R	;3
    588  214a					      endif
    589  214a
    590  214a					      ifnconst	player1colors
    591  214a		       2a		      rol		;2
    592  214b		       2a		      rol		;2
    593  214c		       85 1e		      sta	ENAM1	;3
    594  214e				  -	      else
    595  214e				  -	      ifnconst	playercolors
    596  214e				  -	      sleep	7
    597  214e				  -	      else
    598  214e				  -	      lda.w	player0colorstore
    599  214e				  -	      sta	COLUP0
    600  214e				  -	      endif
    601  214e					      endif
    602  214e
    603  214e		       ad 8e 00 	      lda.w	player0height
    604  2151		       c7 85		      dcp	player0y
    605  2153		       90 0d		      bcc	.skipDrawlastP0
    606  2155		       a4 85		      ldy	player0y
    607  2157		       b1 8a		      lda	(player0pointer),y
    608  2159				   .continuelastP0
    609  2159		       85 1b		      sta	GRP0
    610  215b
    611  215b
    612  215b
    613  215b				  -	      ifnconst	no_blank_lines
    614  215b				  -	      lda	missile0height	;3
    615  215b				  -	      dcp	missile0y	;5
    616  215b				  -	      sbc	stack1
    617  215b				  -	      sta	ENAM0	;3
    618  215b				  -	      jmp	.endkerloop
    619  215b					      else
    620  215b				  -	      ifconst	readpaddle
    621  215b				  -	      ldy	currentpaddle
    622  215b				  -	      lda	INPT0,y
    623  215b				  -	      bpl	noreadpaddle2
    624  215b				  -	      inc	paddle
    625  215b				  -	      jmp	.endkerloop
    626  215b				  -noreadpaddle2
    627  215b				  -	      sleep	4
    628  215b				  -	      jmp	.endkerloop
    629  215b					      else		; no_blank_lines and no paddle reading
    630  215b		       68		      pla
    631  215c		       48		      pha		; 14 cycles in 4 bytes
    632  215d		       68		      pla
    633  215e		       48		      pha
    634  215f							; sleep 14
    635  215f		       4c 06 f1 	      jmp	.endkerloop
    636  2162					      endif
    637  2162					      endif
    638  2162
    639  2162
    640  2162							; ifconst donepaddleskip
    641  2162							;paddleskipread
    642  2162							; this is kind of lame, since it requires 4 cycles from a page boundary crossing
    643  2162							; plus we get a lo-res paddle read
    644  2162							; bmi donepaddleskip
    645  2162							; endif
    646  2162
    647  2162				   .skipDrawlastP0
    648  2162		       a9 00		      lda	#0
    649  2164		       a8		      tay
    650  2165		       4c 59 f1 	      jmp	.continuelastP0
    651  2168
    652  2168					      ifconst	no_blank_lines
    653  2168				   no_blank_lines_bailout
    654  2168		       a2 00		      ldx	#0
    655  216a					      endif
    656  216a
    657  216a				   endkernel
    658  216a							; 6 digit score routine
    659  216a		       86 0e		      stx	PF1
    660  216c		       86 0f		      stx	PF2
    661  216e		       86 0d		      stx	PF0
    662  2170		       18		      clc
    663  2171
    664  2171				  -	      ifconst	pfrowheight
    665  2171				  -	      lda	#pfrowheight+2
    666  2171					      else
    667  2171					      ifnconst	pfres
    668  2171		       a9 0a		      lda	#10
    669  2173				  -	      else
    670  2173				  -	      lda	#(96/pfres)+2	; try to come close to the real size
    671  2173					      endif
    672  2173					      endif
    673  2173
    674  2173		       e5 ef		      sbc	playfieldpos
    675  2175		       85 ef		      sta	playfieldpos
    676  2177		       8a		      txa
    677  2178
    678  2178				  -	      ifconst	shakescreen
    679  2178				  -	      bit	shakescreen
    680  2178				  -	      bmi	noshakescreen2
    681  2178				  -	      ldx	#$3D
    682  2178				  -noshakescreen2
    683  2178					      endif
    684  2178
    685  2178		       95 02		      sta	WSYNC,x
    686  217a
    687  217a							; STA WSYNC ;first one, need one more
    688  217a		       85 0b		      sta	REFP0
    689  217c		       85 0c		      sta	REFP1
    690  217e		       85 1b		      STA	GRP0
    691  2180		       85 1c		      STA	GRP1
    692  2182							; STA PF1
    693  2182							; STA PF2
    694  2182		       85 2b		      sta	HMCLR
    695  2184		       85 1d		      sta	ENAM0
    696  2186		       85 1e		      sta	ENAM1
    697  2188		       85 1f		      sta	ENABL
    698  218a
    699  218a		       a5 9d		      lda	temp2	;restore variables that were obliterated by kernel
    700  218c		       85 85		      sta	player0y
    701  218e		       a5 9e		      lda	temp3
    702  2190		       85 86		      sta	player1y
    703  2192					      ifnconst	player1colors
    704  2192		       a5 a1		      lda	temp6
    705  2194		       85 88		      sta	missile1y
    706  2196					      endif
    707  2196					      ifnconst	playercolors
    708  2196					      ifnconst	readpaddle
    709  2196		       a5 a0		      lda	temp5
    710  2198		       85 91		      sta	missile0y
    711  219a					      endif
    712  219a					      endif
    713  219a		       a5 f7		      lda	stack2
    714  219c		       85 89		      sta	bally
    715  219e
    716  219e							; strangely, this isn't required any more. might have
    717  219e							; resulted from the no_blank_lines score bounce fix
    718  219e							;ifconst no_blank_lines
    719  219e							;sta WSYNC
    720  219e							;endif
    721  219e
    722  219e		       ad 84 02 	      lda	INTIM
    723  21a1		       18		      clc
    724  21a2					      ifnconst	vblank_time
    725  21a2		       69 8e		      adc	#43+12+87
    726  21a4				  -	      else
    727  21a4				  -	      adc	#vblank_time+12+87
    728  21a4				  -
    729  21a4					      endif
    730  21a4							; sta WSYNC
    731  21a4		       8d 96 02 	      sta	TIM64T
    732  21a7
    733  21a7				  -	      ifconst	minikernel
    734  21a7				  -	      jsr	minikernel
    735  21a7					      endif
    736  21a7
    737  21a7							; now reassign temp vars for score pointers
    738  21a7
    739  21a7							; score pointers contain:
    740  21a7							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
    741  21a7							; swap lo2->temp1
    742  21a7							; swap lo4->temp3
    743  21a7							; swap lo6->temp5
    744  21a7					      ifnconst	noscore
    745  21a7		       a5 97		      lda	scorepointers+1
    746  21a9							; ldy temp1
    747  21a9		       85 9c		      sta	temp1
    748  21ab							; sty scorepointers+1
    749  21ab
    750  21ab		       a5 99		      lda	scorepointers+3
    751  21ad							; ldy temp3
    752  21ad		       85 9e		      sta	temp3
    753  21af							; sty scorepointers+3
    754  21af
    755  21af
    756  21af		       85 2b		      sta	HMCLR
    757  21b1		       ba		      tsx
    758  21b2		       86 f6		      stx	stack1
    759  21b4		       a2 e0		      ldx	#$E0
    760  21b6		       86 20		      stx	HMP0
    761  21b8
    762  21b8		       a5 a3		      LDA	scorecolor
    763  21ba		       85 06		      STA	COLUP0
    764  21bc		       85 07		      STA	COLUP1
    765  21be				  -	      ifconst	scorefade
    766  21be				  -	      STA	stack2
    767  21be					      endif
    768  21be				  -	      ifconst	pfscore
    769  21be				  -	      lda	pfscorecolor
    770  21be				  -	      sta	COLUPF
    771  21be					      endif
    772  21be		       85 02		      sta	WSYNC
    773  21c0		       a2 00		      ldx	#0
    774  21c2		       86 1b		      STx	GRP0
    775  21c4		       86 1c		      STx	GRP1	; seems to be needed because of vdel
    776  21c6
    777  21c6		       a5 9b		      lda	scorepointers+5
    778  21c8							; ldy temp5
    779  21c8		       95 a0		      sta	temp5,x
    780  21ca							; sty scorepointers+5
    781  21ca		       a9 ff		      lda	#>scoretable
    782  21cc		       85 97		      sta	scorepointers+1
    783  21ce		       85 99		      sta	scorepointers+3
    784  21d0		       85 9b		      sta	scorepointers+5
    785  21d2		       85 9d		      sta	temp2
    786  21d4		       85 9f		      sta	temp4
    787  21d6		       85 a1		      sta	temp6
    788  21d8		       a0 07		      LDY	#7
    789  21da		       84 25		      STY	VDELP0
    790  21dc		       85 10		      STA	RESP0
    791  21de		       85 11		      STA	RESP1
    792  21e0
    793  21e0
    794  21e0		       a9 03		      LDA	#$03
    795  21e2		       85 04		      STA	NUSIZ0
    796  21e4		       85 05		      STA	NUSIZ1
    797  21e6		       85 26		      STA	VDELP1
    798  21e8		       a9 f0		      LDA	#$F0
    799  21ea		       85 21		      STA	HMP1
    800  21ec		       b1 96		      lda	(scorepointers),y
    801  21ee		       85 1b		      sta	GRP0
    802  21f0		       85 2a		      STA	HMOVE	; cycle 73 ?
    803  21f2		       4c 08 f2 	      jmp	beginscore
    804  21f5
    805  21f5
    806  21f5					      if	((<*)>$d4)
    807  2200		       00 00 00 00*	      align	256	; kludge that potentially wastes space! should be fixed!
    808  2200					      endif
    809  2200
    810  2200				   loop2
    811  2200		       b1 96		      lda	(scorepointers),y	;+5 68 204
    812  2202		       85 1b		      sta	GRP0	;+3 71 213 D1 -- -- --
    813  2204				  -	      ifconst	pfscore
    814  2204				  -	      lda.w	pfscore1
    815  2204				  -	      sta	PF1
    816  2204					      else
    817  2204				  -	      ifconst	scorefade
    818  2204				  -	      sleep	2
    819  2204				  -	      dec	stack2	; decrement the temporary scorecolor
    820  2204					      else
      0  2204					      sleep	7
      1  2204				   .CYCLES    SET	7
      2  2204
      3  2204				  -	      IF	.CYCLES < 2
      4  2204				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2204				  -	      ERR
      6  2204					      ENDIF
      7  2204
      8  2204					      IF	.CYCLES & 1
      9  2204					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2204		       04 00		      nop	0
     11  2206				  -	      ELSE
     12  2206				  -	      bit	VSYNC
     13  2206					      ENDIF
     14  2206				   .CYCLES    SET	.CYCLES - 3
     15  2206					      ENDIF
     16  2206
     17  2206					      REPEAT	.CYCLES / 2
     18  2206		       ea		      nop
     17  2206					      REPEND
     18  2207		       ea		      nop
     19  2208					      REPEND
    822  2208					      endif
    823  2208					      endif
    824  2208							; cycle 0
    825  2208				   beginscore
    826  2208		       b1 9e		      lda	(scorepointers+$8),y	;+5 5 15
    827  220a		       85 1c		      sta	GRP1	;+3 8 24 D1 D1 D2 --
    828  220c		       b1 9c		      lda	(scorepointers+$6),y	;+5 13 39
    829  220e		       85 1b		      sta	GRP0	;+3 16 48 D3 D1 D2 D2
    830  2210		       b3 98		      lax	(scorepointers+$2),y	;+5 29 87
    831  2212		       9a		      txs
    832  2213		       b3 9a		      lax	(scorepointers+$4),y	;+5 36 108
    833  2215				  -	      ifconst	scorefade
    834  2215				  -	      lda	stack2
    835  2215					      else
      0  2215					      sleep	3
      1  2215				   .CYCLES    SET	3
      2  2215
      3  2215				  -	      IF	.CYCLES < 2
      4  2215				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2215				  -	      ERR
      6  2215					      ENDIF
      7  2215
      8  2215					      IF	.CYCLES & 1
      9  2215					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2215		       04 00		      nop	0
     11  2217				  -	      ELSE
     12  2217				  -	      bit	VSYNC
     13  2217					      ENDIF
     14  2217				   .CYCLES    SET	.CYCLES - 3
     15  2217					      ENDIF
     16  2217
     17  2217				  -	      REPEAT	.CYCLES / 2
     18  2217				  -	      nop
     19  2217					      REPEND
    837  2217					      endif
    838  2217
    839  2217				  -	      ifconst	pfscore
    840  2217				  -	      lda	pfscore2
    841  2217				  -	      sta	PF1
    842  2217					      else
    843  2217				  -	      ifconst	scorefade
    844  2217				  -	      sta	COLUP0
    845  2217				  -	      sta	COLUP1
    846  2217					      else
      0  2217					      sleep	6
      1  2217				   .CYCLES    SET	6
      2  2217
      3  2217				  -	      IF	.CYCLES < 2
      4  2217				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2217				  -	      ERR
      6  2217					      ENDIF
      7  2217
      8  2217				  -	      IF	.CYCLES & 1
      9  2217				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2217				  -	      nop	0
     11  2217				  -	      ELSE
     12  2217				  -	      bit	VSYNC
     13  2217				  -	      ENDIF
     14  2217				  -.CYCLES    SET	.CYCLES - 3
     15  2217					      ENDIF
     16  2217
     17  2217					      REPEAT	.CYCLES / 2
     18  2217		       ea		      nop
     17  2217					      REPEND
     18  2218		       ea		      nop
     17  2218					      REPEND
     18  2219		       ea		      nop
     19  221a					      REPEND
    848  221a					      endif
    849  221a					      endif
    850  221a
    851  221a		       b1 a0		      lda	(scorepointers+$A),y	;+5 21 63
    852  221c		       86 1c		      stx	GRP1	;+3 44 132 D3 D3 D4 D2!
    853  221e		       ba		      tsx
    854  221f		       86 1b		      stx	GRP0	;+3 47 141 D5 D3! D4 D4
    855  2221		       85 1c		      sta	GRP1	;+3 50 150 D5 D5 D6 D4!
    856  2223		       84 1b		      sty	GRP0	;+3 53 159 D4* D5! D6 D6
    857  2225		       88		      dey
    858  2226		       10 d8		      bpl	loop2	;+2 60 180
    859  2228
    860  2228		       a6 f6		      ldx	stack1
    861  222a		       9a		      txs
    862  222b							; lda scorepointers+1
    863  222b		       a4 9c		      ldy	temp1
    864  222d							; sta temp1
    865  222d		       84 97		      sty	scorepointers+1
    866  222f
    867  222f		       a9 00		      LDA	#0
    868  2231		       85 0e		      sta	PF1
    869  2233		       85 1b		      STA	GRP0
    870  2235		       85 1c		      STA	GRP1
    871  2237		       85 25		      STA	VDELP0
    872  2239		       85 26		      STA	VDELP1	;do we need these
    873  223b		       85 04		      STA	NUSIZ0
    874  223d		       85 05		      STA	NUSIZ1
    875  223f
    876  223f							; lda scorepointers+3
    877  223f		       a4 9e		      ldy	temp3
    878  2241							; sta temp3
    879  2241		       84 99		      sty	scorepointers+3
    880  2243
    881  2243							; lda scorepointers+5
    882  2243		       a4 a0		      ldy	temp5
    883  2245							; sta temp5
    884  2245		       84 9b		      sty	scorepointers+5
    885  2247					      endif		;noscore
    886  2247				  -	      ifconst	readpaddle
    887  2247				  -	      lda	#%11000010
    888  2247					      else
    889  2247				  -	      ifconst	qtcontroller
    890  2247				  -	      lda	qtcontroller
    891  2247				  -	      lsr		; bit 0 in carry
    892  2247				  -	      lda	#4
    893  2247				  -	      ror		; carry into top of A
    894  2247					      else
    895  2247		       a9 02		      lda	#2
    896  2249					      endif		; qtcontroller
    897  2249					      endif		; readpaddle
    898  2249		       85 02		      sta	WSYNC
    899  224b		       85 01		      sta	VBLANK
      0  224d					      RETURN
      1  224d				  -	      ifnconst	bankswitch
      2  224d				  -	      rts
      3  224d					      else
      4  224d		       4c dd ff 	      jmp	BS_return
      5  2250					      endif
    901  2250				  -	      ifconst	shakescreen
    902  2250				  -doshakescreen
    903  2250				  -	      bit	shakescreen
    904  2250				  -	      bmi	noshakescreen
    905  2250				  -	      sta	WSYNC
    906  2250				  -noshakescreen
    907  2250				  -	      ldx	missile0height
    908  2250				  -	      inx
    909  2250				  -	      rts
    910  2250					      endif
    911  2250
    912  2250							; Provided under the CC0 license. See the included LICENSE.txt for details.
    913  2250
    914  2250				   start
    915  2250		       78		      sei
    916  2251		       d8		      cld
    917  2252		       a0 00		      ldy	#0
    918  2254		       a5 d0		      lda	$D0
    919  2256		       c9 2c		      cmp	#$2C	;check RAM location #1
    920  2258		       d0 07		      bne	MachineIs2600
    921  225a		       a5 d1		      lda	$D1
    922  225c		       c9 a9		      cmp	#$A9	;check RAM location #2
    923  225e		       d0 01		      bne	MachineIs2600
    924  2260		       88		      dey
    925  2261				   MachineIs2600
    926  2261		       a2 00		      ldx	#0
    927  2263		       8a		      txa
    928  2264				   clearmem
    929  2264		       e8		      inx
    930  2265		       9a		      txs
    931  2266		       48		      pha
    932  2267		       d0 fb		      bne	clearmem
    933  2269		       84 9c		      sty	temp1
    934  226b					      ifnconst	multisprite
    935  226b				  -	      ifconst	pfrowheight
    936  226b				  -	      lda	#pfrowheight
    937  226b					      else
    938  226b				  -	      ifconst	pfres
    939  226b				  -	      lda	#(96/pfres)
    940  226b					      else
    941  226b		       a9 08		      lda	#8
    942  226d					      endif
    943  226d					      endif
    944  226d		       85 ef		      sta	playfieldpos
    945  226f					      endif
    946  226f		       a2 05		      ldx	#5
    947  2271				   initscore
    948  2271		       a9 74		      lda	#<scoretable
    949  2273		       95 96		      sta	scorepointers,x
    950  2275		       ca		      dex
    951  2276		       10 f9		      bpl	initscore
    952  2278		       a9 01		      lda	#1
    953  227a		       85 0a		      sta	CTRLPF
    954  227c		       0d 84 02 	      ora	INTIM
    955  227f		       85 a2		      sta	rand
    956  2281
    957  2281				  -	      ifconst	multisprite
    958  2281				  -	      jsr	multisprite_setup
    959  2281					      endif
    960  2281
    961  2281				  -	      ifnconst	bankswitch
    962  2281				  -	      jmp	game
    963  2281					      else
    964  2281		       a9 cf		      lda	#>(game-1)
    965  2283		       48		      pha
    966  2284		       a9 ff		      lda	#<(game-1)
    967  2286		       48		      pha
    968  2287		       48		      pha
    969  2288		       48		      pha
    970  2289		       a2 01		      ldx	#1
    971  228b		       4c eb ff 	      jmp	BS_jsr
    972  228e					      endif
    973  228e							; Provided under the CC0 license. See the included LICENSE.txt for details.
    974  228e
    975  228e							; playfield drawing routines
    976  228e							; you get a 32x12 bitmapped display in a single color :)
    977  228e							; 0-31 and 0-11
    978  228e
    979  228e				   pfclear		; clears playfield - or fill with pattern
    980  228e				  -	      ifconst	pfres
    981  228e				  -	      ldx	#pfres*pfwidth-1
    982  228e					      else
    983  228e		       a2 2f		      ldx	#47-(4-pfwidth)*12	; will this work?
    984  2290					      endif
    985  2290				   pfclear_loop
    986  2290					      ifnconst	superchip
    987  2290		       95 a4		      sta	playfield,x
    988  2292				  -	      else
    989  2292				  -	      sta	playfield-128,x
    990  2292					      endif
    991  2292		       ca		      dex
    992  2293		       10 fb		      bpl	pfclear_loop
      0  2295					      RETURN
      1  2295				  -	      ifnconst	bankswitch
      2  2295				  -	      rts
      3  2295					      else
      4  2295		       4c dd ff 	      jmp	BS_return
      5  2298					      endif
    994  2298
    995  2298				   setuppointers
    996  2298		       86 9d		      stx	temp2	; store on.off.flip value
    997  229a		       aa		      tax		; put x-value in x 
    998  229b		       4a		      lsr
    999  229c		       4a		      lsr
   1000  229d		       4a		      lsr		; divide x pos by 8 
   1001  229e		       85 9c		      sta	temp1
   1002  22a0		       98		      tya
   1003  22a1		       0a		      asl
   1004  22a2					      if	pfwidth=4
   1005  22a2		       0a		      asl		; multiply y pos by 4
   1006  22a3					      endif		; else multiply by 2
   1007  22a3		       18		      clc
   1008  22a4		       65 9c		      adc	temp1	; add them together to get actual memory location offset
   1009  22a6		       a8		      tay		; put the value in y
   1010  22a7		       a5 9d		      lda	temp2	; restore on.off.flip value
   1011  22a9		       60		      rts
   1012  22aa
   1013  22aa				   pfread
   1014  22aa							;x=xvalue, y=yvalue
   1015  22aa		       20 98 f2 	      jsr	setuppointers
   1016  22ad		       bd 42 f3 	      lda	setbyte,x
   1017  22b0		       39 a4 00 	      and	playfield,y
   1018  22b3		       5d 42 f3 	      eor	setbyte,x
   1019  22b6							; beq readzero
   1020  22b6							; lda #1
   1021  22b6							; readzero
      0  22b6					      RETURN
      1  22b6				  -	      ifnconst	bankswitch
      2  22b6				  -	      rts
      3  22b6					      else
      4  22b6		       4c dd ff 	      jmp	BS_return
      5  22b9					      endif
   1023  22b9
   1024  22b9				   pfpixel
   1025  22b9							;x=xvalue, y=yvalue, a=0,1,2
   1026  22b9		       20 98 f2 	      jsr	setuppointers
   1027  22bc
   1028  22bc					      ifconst	bankswitch
   1029  22bc		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   1030  22be		       f0 0f		      beq	pixelon_r	; if "on" go to on
   1031  22c0		       4a		      lsr
   1032  22c1		       b0 18		      bcs	pixeloff_r	; value is 1 if true
   1033  22c3		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   1034  22c6		       5d 42 f3 	      eor	setbyte,x
   1035  22c9				  -	      ifconst	superchip
   1036  22c9				  -	      sta	playfield-128,y
   1037  22c9					      else
   1038  22c9		       99 a4 00 	      sta	playfield,y
   1039  22cc					      endif
      0  22cc					      RETURN
      1  22cc				  -	      ifnconst	bankswitch
      2  22cc				  -	      rts
      3  22cc					      else
      4  22cc		       4c dd ff 	      jmp	BS_return
      5  22cf					      endif
   1041  22cf				   pixelon_r
   1042  22cf		       b9 a4 00 	      lda	playfield,y
   1043  22d2		       1d 42 f3 	      ora	setbyte,x
   1044  22d5				  -	      ifconst	superchip
   1045  22d5				  -	      sta	playfield-128,y
   1046  22d5					      else
   1047  22d5		       99 a4 00 	      sta	playfield,y
   1048  22d8					      endif
      0  22d8					      RETURN
      1  22d8				  -	      ifnconst	bankswitch
      2  22d8				  -	      rts
      3  22d8					      else
      4  22d8		       4c dd ff 	      jmp	BS_return
      5  22db					      endif
   1050  22db				   pixeloff_r
   1051  22db		       bd 42 f3 	      lda	setbyte,x
   1052  22de		       49 ff		      eor	#$ff
   1053  22e0		       39 a4 00 	      and	playfield,y
   1054  22e3				  -	      ifconst	superchip
   1055  22e3				  -	      sta	playfield-128,y
   1056  22e3					      else
   1057  22e3		       99 a4 00 	      sta	playfield,y
   1058  22e6					      endif
      0  22e6					      RETURN
      1  22e6				  -	      ifnconst	bankswitch
      2  22e6				  -	      rts
      3  22e6					      else
      4  22e6		       4c dd ff 	      jmp	BS_return
      5  22e9					      endif
   1060  22e9
   1061  22e9				  -	      else
   1062  22e9				  -	      jmp	plotpoint
   1063  22e9					      endif
   1064  22e9
   1065  22e9				   pfhline
   1066  22e9							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   1067  22e9		       20 98 f2 	      jsr	setuppointers
   1068  22ec		       4c f6 f2 	      jmp	noinc
   1069  22ef				   keepgoing
   1070  22ef		       e8		      inx
   1071  22f0		       8a		      txa
   1072  22f1		       29 07		      and	#7
   1073  22f3		       d0 01		      bne	noinc
   1074  22f5		       c8		      iny
   1075  22f6				   noinc
   1076  22f6		       20 1b f3 	      jsr	plotpoint
   1077  22f9		       e4 9e		      cpx	temp3
   1078  22fb		       30 f2		      bmi	keepgoing
      0  22fd					      RETURN
      1  22fd				  -	      ifnconst	bankswitch
      2  22fd				  -	      rts
      3  22fd					      else
      4  22fd		       4c dd ff 	      jmp	BS_return
      5  2300					      endif
   1080  2300
   1081  2300				   pfvline
   1082  2300							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   1083  2300		       20 98 f2 	      jsr	setuppointers
   1084  2303		       84 9c		      sty	temp1	; store memory location offset
   1085  2305		       e6 9e		      inc	temp3	; increase final x by 1 
   1086  2307		       a5 9e		      lda	temp3
   1087  2309		       0a		      asl
   1088  230a					      if	pfwidth=4
   1089  230a		       0a		      asl		; multiply by 4
   1090  230b					      endif		; else multiply by 2
   1091  230b		       85 9e		      sta	temp3	; store it
   1092  230d							; Thanks to Michael Rideout for fixing a bug in this code
   1093  230d							; right now, temp1=y=starting memory location, temp3=final
   1094  230d							; x should equal original x value
   1095  230d				   keepgoingy
   1096  230d		       20 1b f3 	      jsr	plotpoint
   1097  2310		       c8		      iny
   1098  2311		       c8		      iny
   1099  2312					      if	pfwidth=4
   1100  2312		       c8		      iny
   1101  2313		       c8		      iny
   1102  2314					      endif
   1103  2314		       c4 9e		      cpy	temp3
   1104  2316		       30 f5		      bmi	keepgoingy
      0  2318					      RETURN
      1  2318				  -	      ifnconst	bankswitch
      2  2318				  -	      rts
      3  2318					      else
      4  2318		       4c dd ff 	      jmp	BS_return
      5  231b					      endif
   1106  231b
   1107  231b				   plotpoint
   1108  231b		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   1109  231d		       f0 0d		      beq	pixelon	; if "on" go to on
   1110  231f		       4a		      lsr
   1111  2320		       b0 14		      bcs	pixeloff	; value is 1 if true
   1112  2322		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   1113  2325		       5d 42 f3 	      eor	setbyte,x
   1114  2328				  -	      ifconst	superchip
   1115  2328				  -	      sta	playfield-128,y
   1116  2328					      else
   1117  2328		       99 a4 00 	      sta	playfield,y
   1118  232b					      endif
   1119  232b		       60		      rts
   1120  232c				   pixelon
   1121  232c		       b9 a4 00 	      lda	playfield,y
   1122  232f		       1d 42 f3 	      ora	setbyte,x
   1123  2332				  -	      ifconst	superchip
   1124  2332				  -	      sta	playfield-128,y
   1125  2332					      else
   1126  2332		       99 a4 00 	      sta	playfield,y
   1127  2335					      endif
   1128  2335		       60		      rts
   1129  2336				   pixeloff
   1130  2336		       bd 42 f3 	      lda	setbyte,x
   1131  2339		       49 ff		      eor	#$ff
   1132  233b		       39 a4 00 	      and	playfield,y
   1133  233e				  -	      ifconst	superchip
   1134  233e				  -	      sta	playfield-128,y
   1135  233e					      else
   1136  233e		       99 a4 00 	      sta	playfield,y
   1137  2341					      endif
   1138  2341		       60		      rts
   1139  2342
   1140  2342				   setbyte
   1141  2342					      ifnconst	pfcenter
   1142  2342		       80		      .byte.b	$80
   1143  2343		       40		      .byte.b	$40
   1144  2344		       20		      .byte.b	$20
   1145  2345		       10		      .byte.b	$10
   1146  2346		       08		      .byte.b	$08
   1147  2347		       04		      .byte.b	$04
   1148  2348		       02		      .byte.b	$02
   1149  2349		       01		      .byte.b	$01
   1150  234a					      endif
   1151  234a		       01		      .byte.b	$01
   1152  234b		       02		      .byte.b	$02
   1153  234c		       04		      .byte.b	$04
   1154  234d		       08		      .byte.b	$08
   1155  234e		       10		      .byte.b	$10
   1156  234f		       20		      .byte.b	$20
   1157  2350		       40		      .byte.b	$40
   1158  2351		       80		      .byte.b	$80
   1159  2352		       80		      .byte.b	$80
   1160  2353		       40		      .byte.b	$40
   1161  2354		       20		      .byte.b	$20
   1162  2355		       10		      .byte.b	$10
   1163  2356		       08		      .byte.b	$08
   1164  2357		       04		      .byte.b	$04
   1165  2358		       02		      .byte.b	$02
   1166  2359		       01		      .byte.b	$01
   1167  235a		       01		      .byte.b	$01
   1168  235b		       02		      .byte.b	$02
   1169  235c		       04		      .byte.b	$04
   1170  235d		       08		      .byte.b	$08
   1171  235e		       10		      .byte.b	$10
   1172  235f		       20		      .byte.b	$20
   1173  2360		       40		      .byte.b	$40
   1174  2361		       80		      .byte.b	$80
   1175  2362							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1176  2362
   1177  2362				   pfscroll		;(a=0 left, 1 right, 2 up, 4 down, 6=upup, 12=downdown)
   1178  2362		       d0 15		      bne	notleft
   1179  2364							;left
   1180  2364				  -	      ifconst	pfres
   1181  2364				  -	      ldx	#pfres*4
   1182  2364					      else
   1183  2364		       a2 30		      ldx	#48
   1184  2366					      endif
   1185  2366				   leftloop
   1186  2366		       b5 a3		      lda	playfield-1,x
   1187  2368		       4a		      lsr
   1188  2369
   1189  2369				  -	      ifconst	superchip
   1190  2369				  -	      lda	playfield-2,x
   1191  2369				  -	      rol
   1192  2369				  -	      sta	playfield-130,x
   1193  2369				  -	      lda	playfield-3,x
   1194  2369				  -	      ror
   1195  2369				  -	      sta	playfield-131,x
   1196  2369				  -	      lda	playfield-4,x
   1197  2369				  -	      rol
   1198  2369				  -	      sta	playfield-132,x
   1199  2369				  -	      lda	playfield-1,x
   1200  2369				  -	      ror
   1201  2369				  -	      sta	playfield-129,x
   1202  2369					      else
   1203  2369		       36 a2		      rol	playfield-2,x
   1204  236b		       76 a1		      ror	playfield-3,x
   1205  236d		       36 a0		      rol	playfield-4,x
   1206  236f		       76 a3		      ror	playfield-1,x
   1207  2371					      endif
   1208  2371
   1209  2371		       8a		      txa
   1210  2372		       cb 04		      sbx	#4
   1211  2374		       d0 f0		      bne	leftloop
      0  2376					      RETURN
      1  2376				  -	      ifnconst	bankswitch
      2  2376				  -	      rts
      3  2376					      else
      4  2376		       4c dd ff 	      jmp	BS_return
      5  2379					      endif
   1213  2379
   1214  2379				   notleft
   1215  2379		       4a		      lsr
   1216  237a		       90 15		      bcc	notright
   1217  237c							;right
   1218  237c
   1219  237c				  -	      ifconst	pfres
   1220  237c				  -	      ldx	#pfres*4
   1221  237c					      else
   1222  237c		       a2 30		      ldx	#48
   1223  237e					      endif
   1224  237e				   rightloop
   1225  237e		       b5 a0		      lda	playfield-4,x
   1226  2380		       4a		      lsr
   1227  2381				  -	      ifconst	superchip
   1228  2381				  -	      lda	playfield-3,x
   1229  2381				  -	      rol
   1230  2381				  -	      sta	playfield-131,x
   1231  2381				  -	      lda	playfield-2,x
   1232  2381				  -	      ror
   1233  2381				  -	      sta	playfield-130,x
   1234  2381				  -	      lda	playfield-1,x
   1235  2381				  -	      rol
   1236  2381				  -	      sta	playfield-129,x
   1237  2381				  -	      lda	playfield-4,x
   1238  2381				  -	      ror
   1239  2381				  -	      sta	playfield-132,x
   1240  2381					      else
   1241  2381		       36 a1		      rol	playfield-3,x
   1242  2383		       76 a2		      ror	playfield-2,x
   1243  2385		       36 a3		      rol	playfield-1,x
   1244  2387		       76 a0		      ror	playfield-4,x
   1245  2389					      endif
   1246  2389		       8a		      txa
   1247  238a		       cb 04		      sbx	#4
   1248  238c		       d0 f0		      bne	rightloop
      0  238e					      RETURN
      1  238e				  -	      ifnconst	bankswitch
      2  238e				  -	      rts
      3  238e					      else
      4  238e		       4c dd ff 	      jmp	BS_return
      5  2391					      endif
   1250  2391
   1251  2391				   notright
   1252  2391		       4a		      lsr
   1253  2392		       90 4b		      bcc	notup
   1254  2394							;up
   1255  2394		       4a		      lsr
   1256  2395		       90 02		      bcc	onedecup
   1257  2397		       c6 ef		      dec	playfieldpos
   1258  2399				   onedecup
   1259  2399		       c6 ef		      dec	playfieldpos
   1260  239b		       f0 02		      beq	shiftdown
   1261  239d		       10 3d		      bpl	noshiftdown2
   1262  239f				   shiftdown
   1263  239f				  -	      ifconst	pfrowheight
   1264  239f				  -	      lda	#pfrowheight
   1265  239f					      else
   1266  239f					      ifnconst	pfres
   1267  239f		       a9 08		      lda	#8
   1268  23a1				  -	      else
   1269  23a1				  -	      lda	#(96/pfres)	; try to come close to the real size
   1270  23a1					      endif
   1271  23a1					      endif
   1272  23a1
   1273  23a1		       85 ef		      sta	playfieldpos
   1274  23a3		       a5 a7		      lda	playfield+3
   1275  23a5		       85 9f		      sta	temp4
   1276  23a7		       a5 a6		      lda	playfield+2
   1277  23a9		       85 9e		      sta	temp3
   1278  23ab		       a5 a5		      lda	playfield+1
   1279  23ad		       85 9d		      sta	temp2
   1280  23af		       a5 a4		      lda	playfield
   1281  23b1		       85 9c		      sta	temp1
   1282  23b3		       a2 00		      ldx	#0
   1283  23b5				   up2
   1284  23b5		       b5 a8		      lda	playfield+4,x
   1285  23b7				  -	      ifconst	superchip
   1286  23b7				  -	      sta	playfield-128,x
   1287  23b7				  -	      lda	playfield+5,x
   1288  23b7				  -	      sta	playfield-127,x
   1289  23b7				  -	      lda	playfield+6,x
   1290  23b7				  -	      sta	playfield-126,x
   1291  23b7				  -	      lda	playfield+7,x
   1292  23b7				  -	      sta	playfield-125,x
   1293  23b7					      else
   1294  23b7		       95 a4		      sta	playfield,x
   1295  23b9		       b5 a9		      lda	playfield+5,x
   1296  23bb		       95 a5		      sta	playfield+1,x
   1297  23bd		       b5 aa		      lda	playfield+6,x
   1298  23bf		       95 a6		      sta	playfield+2,x
   1299  23c1		       b5 ab		      lda	playfield+7,x
   1300  23c3		       95 a7		      sta	playfield+3,x
   1301  23c5					      endif
   1302  23c5		       8a		      txa
   1303  23c6		       cb fc		      sbx	#252
   1304  23c8				  -	      ifconst	pfres
   1305  23c8				  -	      cpx	#(pfres-1)*4
   1306  23c8					      else
   1307  23c8		       e0 2c		      cpx	#44
   1308  23ca					      endif
   1309  23ca		       d0 e9		      bne	up2
   1310  23cc
   1311  23cc		       a5 9f		      lda	temp4
   1312  23ce
   1313  23ce				  -	      ifconst	superchip
   1314  23ce				  -	      ifconst	pfres
   1315  23ce				  -	      sta	playfield+pfres*4-129
   1316  23ce				  -	      lda	temp3
   1317  23ce				  -	      sta	playfield+pfres*4-130
   1318  23ce				  -	      lda	temp2
   1319  23ce				  -	      sta	playfield+pfres*4-131
   1320  23ce				  -	      lda	temp1
   1321  23ce				  -	      sta	playfield+pfres*4-132
   1322  23ce				  -	      else
   1323  23ce				  -	      sta	playfield+47-128
   1324  23ce				  -	      lda	temp3
   1325  23ce				  -	      sta	playfield+46-128
   1326  23ce				  -	      lda	temp2
   1327  23ce				  -	      sta	playfield+45-128
   1328  23ce				  -	      lda	temp1
   1329  23ce				  -	      sta	playfield+44-128
   1330  23ce				  -	      endif
   1331  23ce					      else
   1332  23ce				  -	      ifconst	pfres
   1333  23ce				  -	      sta	playfield+pfres*4-1
   1334  23ce				  -	      lda	temp3
   1335  23ce				  -	      sta	playfield+pfres*4-2
   1336  23ce				  -	      lda	temp2
   1337  23ce				  -	      sta	playfield+pfres*4-3
   1338  23ce				  -	      lda	temp1
   1339  23ce				  -	      sta	playfield+pfres*4-4
   1340  23ce					      else
   1341  23ce		       85 d3		      sta	playfield+47
   1342  23d0		       a5 9e		      lda	temp3
   1343  23d2		       85 d2		      sta	playfield+46
   1344  23d4		       a5 9d		      lda	temp2
   1345  23d6		       85 d1		      sta	playfield+45
   1346  23d8		       a5 9c		      lda	temp1
   1347  23da		       85 d0		      sta	playfield+44
   1348  23dc					      endif
   1349  23dc					      endif
   1350  23dc				   noshiftdown2
      0  23dc					      RETURN
      1  23dc				  -	      ifnconst	bankswitch
      2  23dc				  -	      rts
      3  23dc					      else
      4  23dc		       4c dd ff 	      jmp	BS_return
      5  23df					      endif
   1352  23df
   1353  23df
   1354  23df				   notup
   1355  23df							;down
   1356  23df		       4a		      lsr
   1357  23e0		       b0 02		      bcs	oneincup
   1358  23e2		       e6 ef		      inc	playfieldpos
   1359  23e4				   oneincup
   1360  23e4		       e6 ef		      inc	playfieldpos
   1361  23e6		       a5 ef		      lda	playfieldpos
   1362  23e8
   1363  23e8				  -	      ifconst	pfrowheight
   1364  23e8				  -	      cmp	#pfrowheight+1
   1365  23e8					      else
   1366  23e8					      ifnconst	pfres
   1367  23e8		       c9 09		      cmp	#9
   1368  23ea				  -	      else
   1369  23ea				  -	      cmp	#(96/pfres)+1	; try to come close to the real size
   1370  23ea					      endif
   1371  23ea					      endif
   1372  23ea
   1373  23ea		       90 3b		      bcc	noshiftdown
   1374  23ec		       a9 01		      lda	#1
   1375  23ee		       85 ef		      sta	playfieldpos
   1376  23f0
   1377  23f0				  -	      ifconst	pfres
   1378  23f0				  -	      lda	playfield+pfres*4-1
   1379  23f0				  -	      sta	temp4
   1380  23f0				  -	      lda	playfield+pfres*4-2
   1381  23f0				  -	      sta	temp3
   1382  23f0				  -	      lda	playfield+pfres*4-3
   1383  23f0				  -	      sta	temp2
   1384  23f0				  -	      lda	playfield+pfres*4-4
   1385  23f0					      else
   1386  23f0		       a5 d3		      lda	playfield+47
   1387  23f2		       85 9f		      sta	temp4
   1388  23f4		       a5 d2		      lda	playfield+46
   1389  23f6		       85 9e		      sta	temp3
   1390  23f8		       a5 d1		      lda	playfield+45
   1391  23fa		       85 9d		      sta	temp2
   1392  23fc		       a5 d0		      lda	playfield+44
   1393  23fe					      endif
   1394  23fe
   1395  23fe		       85 9c		      sta	temp1
   1396  2400
   1397  2400				  -	      ifconst	pfres
   1398  2400				  -	      ldx	#(pfres-1)*4
   1399  2400					      else
   1400  2400		       a2 2c		      ldx	#44
   1401  2402					      endif
   1402  2402				   down2
   1403  2402		       b5 a3		      lda	playfield-1,x
   1404  2404				  -	      ifconst	superchip
   1405  2404				  -	      sta	playfield-125,x
   1406  2404				  -	      lda	playfield-2,x
   1407  2404				  -	      sta	playfield-126,x
   1408  2404				  -	      lda	playfield-3,x
   1409  2404				  -	      sta	playfield-127,x
   1410  2404				  -	      lda	playfield-4,x
   1411  2404				  -	      sta	playfield-128,x
   1412  2404					      else
   1413  2404		       95 a7		      sta	playfield+3,x
   1414  2406		       b5 a2		      lda	playfield-2,x
   1415  2408		       95 a6		      sta	playfield+2,x
   1416  240a		       b5 a1		      lda	playfield-3,x
   1417  240c		       95 a5		      sta	playfield+1,x
   1418  240e		       b5 a0		      lda	playfield-4,x
   1419  2410		       95 a4		      sta	playfield,x
   1420  2412					      endif
   1421  2412		       8a		      txa
   1422  2413		       cb 04		      sbx	#4
   1423  2415		       d0 eb		      bne	down2
   1424  2417
   1425  2417		       a5 9f		      lda	temp4
   1426  2419				  -	      ifconst	superchip
   1427  2419				  -	      sta	playfield-125
   1428  2419				  -	      lda	temp3
   1429  2419				  -	      sta	playfield-126
   1430  2419				  -	      lda	temp2
   1431  2419				  -	      sta	playfield-127
   1432  2419				  -	      lda	temp1
   1433  2419				  -	      sta	playfield-128
   1434  2419					      else
   1435  2419		       85 a7		      sta	playfield+3
   1436  241b		       a5 9e		      lda	temp3
   1437  241d		       85 a6		      sta	playfield+2
   1438  241f		       a5 9d		      lda	temp2
   1439  2421		       85 a5		      sta	playfield+1
   1440  2423		       a5 9c		      lda	temp1
   1441  2425		       85 a4		      sta	playfield
   1442  2427					      endif
   1443  2427				   noshiftdown
      0  2427					      RETURN
      1  2427				  -	      ifnconst	bankswitch
      2  2427				  -	      rts
      3  2427					      else
      4  2427		       4c dd ff 	      jmp	BS_return
      5  242a					      endif
   1445  242a							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1446  242a
   1447  242a							;standard routines needed for pretty much all games
   1448  242a							; just the random number generator is left - maybe we should remove this asm file altogether?
   1449  242a							; repositioning code and score pointer setup moved to overscan
   1450  242a							; read switches, joysticks now compiler generated (more efficient)
   1451  242a
   1452  242a				   randomize
   1453  242a		       a5 a2		      lda	rand
   1454  242c		       4a		      lsr
   1455  242d				  -	      ifconst	rand16
   1456  242d				  -	      rol	rand16
   1457  242d					      endif
   1458  242d		       90 02		      bcc	noeor
   1459  242f		       49 b4		      eor	#$B4
   1460  2431				   noeor
   1461  2431		       85 a2		      sta	rand
   1462  2433				  -	      ifconst	rand16
   1463  2433				  -	      eor	rand16
   1464  2433					      endif
      0  2433					      RETURN
      1  2433				  -	      ifnconst	bankswitch
      2  2433				  -	      rts
      3  2433					      else
      4  2433		       4c dd ff 	      jmp	BS_return
      5  2436					      endif
   1466  2436							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1467  2436
   1468  2436				   drawscreen
   1469  2436				  -	      ifconst	debugscore
   1470  2436				  -	      ldx	#14
   1471  2436				  -	      lda	INTIM	; display # cycles left in the score
   1472  2436				  -
   1473  2436				  -	      ifconst	mincycles
   1474  2436				  -	      lda	mincycles
   1475  2436				  -	      cmp	INTIM
   1476  2436				  -	      lda	mincycles
   1477  2436				  -	      bcc	nochange
   1478  2436				  -	      lda	INTIM
   1479  2436				  -	      sta	mincycles
   1480  2436				  -nochange
   1481  2436				  -	      endif
   1482  2436				  -
   1483  2436				  -			; cmp #$2B
   1484  2436				  -			; bcs no_cycles_left
   1485  2436				  -	      bmi	cycles_left
   1486  2436				  -	      ldx	#64
   1487  2436				  -	      eor	#$ff	;make negative
   1488  2436				  -cycles_left
   1489  2436				  -	      stx	scorecolor
   1490  2436				  -	      and	#$7f	; clear sign bit
   1491  2436				  -	      tax
   1492  2436				  -	      lda	scorebcd,x
   1493  2436				  -	      sta	score+2
   1494  2436				  -	      lda	scorebcd1,x
   1495  2436				  -	      sta	score+1
   1496  2436				  -	      jmp	done_debugscore
   1497  2436				  -scorebcd
   1498  2436				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   1499  2436				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   1500  2436				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   1501  2436				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   1502  2436				  -scorebcd1
   1503  2436				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   1504  2436				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   1505  2436				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   1506  2436				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   1507  2436				  -done_debugscore
   1508  2436					      endif
   1509  2436
   1510  2436				  -	      ifconst	debugcycles
   1511  2436				  -	      lda	INTIM	; if we go over, it mucks up the background color
   1512  2436				  -			; cmp #$2B
   1513  2436				  -			; BCC overscan
   1514  2436				  -	      bmi	overscan
   1515  2436				  -	      sta	COLUBK
   1516  2436				  -	      bcs	doneoverscan
   1517  2436					      endif
   1518  2436
   1519  2436				   overscan
   1520  2436				  -	      ifconst	interlaced
   1521  2436				  -	      PHP
   1522  2436				  -	      PLA
   1523  2436				  -	      EOR	#4	; flip interrupt bit
   1524  2436				  -	      PHA
   1525  2436				  -	      PLP
   1526  2436				  -	      AND	#4	; isolate the interrupt bit
   1527  2436				  -	      TAX		; save it for later
   1528  2436					      endif
   1529  2436
   1530  2436				   overscanloop
   1531  2436		       ad 84 02 	      lda	INTIM	;wait for sync
   1532  2439		       30 fb		      bmi	overscanloop
   1533  243b				   doneoverscan
   1534  243b
   1535  243b							;do VSYNC
   1536  243b
   1537  243b				  -	      ifconst	interlaced
   1538  243b				  -	      CPX	#4
   1539  243b				  -	      BNE	oddframevsync
   1540  243b					      endif
   1541  243b
   1542  243b		       a9 02		      lda	#2
   1543  243d		       85 02		      sta	WSYNC
   1544  243f		       85 00		      sta	VSYNC
   1545  2441		       85 02		      STA	WSYNC
   1546  2443		       85 02		      STA	WSYNC
   1547  2445		       4a		      lsr
   1548  2446		       85 02		      STA	WSYNC
   1549  2448		       85 00		      STA	VSYNC
   1550  244a		       85 01		      sta	VBLANK
   1551  244c					      ifnconst	overscan_time
   1552  244c		       a9 a5		      lda	#37+128
   1553  244e				  -	      else
   1554  244e				  -	      lda	#overscan_time+128
   1555  244e					      endif
   1556  244e		       8d 96 02 	      sta	TIM64T
   1557  2451
   1558  2451				  -	      ifconst	interlaced
   1559  2451				  -	      jmp	postsync
   1560  2451				  -
   1561  2451				  -oddframevsync
   1562  2451				  -	      sta	WSYNC
   1563  2451				  -
   1564  2451				  -	      LDA	($80,X)	; 11 waste
   1565  2451				  -	      LDA	($80,X)	; 11 waste
   1566  2451				  -	      LDA	($80,X)	; 11 waste
   1567  2451				  -
   1568  2451				  -	      lda	#2
   1569  2451				  -	      sta	VSYNC
   1570  2451				  -	      sta	WSYNC
   1571  2451				  -	      sta	WSYNC
   1572  2451				  -	      sta	WSYNC
   1573  2451				  -
   1574  2451				  -	      LDA	($80,X)	; 11 waste
   1575  2451				  -	      LDA	($80,X)	; 11 waste
   1576  2451				  -	      LDA	($80,X)	; 11 waste
   1577  2451				  -
   1578  2451				  -	      lda	#0
   1579  2451				  -	      sta	VSYNC
   1580  2451				  -	      sta	VBLANK
   1581  2451				  -	      ifnconst	overscan_time
   1582  2451				  -	      lda	#37+128
   1583  2451				  -	      else
   1584  2451				  -	      lda	#overscan_time+128
   1585  2451				  -	      endif
   1586  2451				  -	      sta	TIM64T
   1587  2451				  -
   1588  2451				  -postsync
   1589  2451					      endif
   1590  2451
   1591  2451				  -	      ifconst	legacy
   1592  2451				  -	      if	legacy < 100
   1593  2451				  -	      ldx	#4
   1594  2451				  -adjustloop
   1595  2451				  -	      lda	player0x,x
   1596  2451				  -	      sec
   1597  2451				  -	      sbc	#14	;?
   1598  2451				  -	      sta	player0x,x
   1599  2451				  -	      dex
   1600  2451				  -	      bpl	adjustloop
   1601  2451				  -	      endif
   1602  2451					      endif
   1603  2451				  -	      if	((<*)>$e9)&&((<*)<$fa)
   1604  2451				  -	      repeat	($fa-(<*))
   1605  2451				  -	      nop
   1606  2451				  -	      repend
   1607  2451					      endif
   1608  2451		       85 02		      sta	WSYNC
   1609  2453		       a2 04		      ldx	#4
      0  2455					      SLEEP	3
      1  2455				   .CYCLES    SET	3
      2  2455
      3  2455				  -	      IF	.CYCLES < 2
      4  2455				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2455				  -	      ERR
      6  2455					      ENDIF
      7  2455
      8  2455					      IF	.CYCLES & 1
      9  2455					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2455		       04 00		      nop	0
     11  2457				  -	      ELSE
     12  2457				  -	      bit	VSYNC
     13  2457					      ENDIF
     14  2457				   .CYCLES    SET	.CYCLES - 3
     15  2457					      ENDIF
     16  2457
     17  2457				  -	      REPEAT	.CYCLES / 2
     18  2457				  -	      nop
     19  2457					      REPEND
   1611  2457				   HorPosLoop		; 5
   1612  2457		       b5 80		      lda	player0x,X	;+4 9
   1613  2459		       38		      sec		;+2 11
   1614  245a				   DivideLoop
   1615  245a		       e9 0f		      sbc	#15
   1616  245c		       b0 fc		      bcs	DivideLoop	;+4 15
   1617  245e		       95 9c		      sta	temp1,X	;+4 19
   1618  2460		       95 10		      sta	RESP0,X	;+4 23
   1619  2462		       85 02		      sta	WSYNC
   1620  2464		       ca		      dex
   1621  2465		       10 f0		      bpl	HorPosLoop	;+5 5
   1622  2467							; 4
   1623  2467
   1624  2467		       a2 04		      ldx	#4
   1625  2469		       b4 9c		      ldy	temp1,X
   1626  246b		       b9 c7 f3 	      lda	repostable-256,Y
   1627  246e		       95 20		      sta	HMP0,X	;+14 18
   1628  2470
   1629  2470		       ca		      dex
   1630  2471		       b4 9c		      ldy	temp1,X
   1631  2473		       b9 c7 f3 	      lda	repostable-256,Y
   1632  2476		       95 20		      sta	HMP0,X	;+14 32
   1633  2478
   1634  2478		       ca		      dex
   1635  2479		       b4 9c		      ldy	temp1,X
   1636  247b		       b9 c7 f3 	      lda	repostable-256,Y
   1637  247e		       95 20		      sta	HMP0,X	;+14 46
   1638  2480
   1639  2480		       ca		      dex
   1640  2481		       b4 9c		      ldy	temp1,X
   1641  2483		       b9 c7 f3 	      lda	repostable-256,Y
   1642  2486		       95 20		      sta	HMP0,X	;+14 60
   1643  2488
   1644  2488		       ca		      dex
   1645  2489		       b4 9c		      ldy	temp1,X
   1646  248b		       b9 c7 f3 	      lda	repostable-256,Y
   1647  248e		       95 20		      sta	HMP0,X	;+14 74
   1648  2490
   1649  2490		       85 02		      sta	WSYNC
   1650  2492
   1651  2492		       85 2a		      sta	HMOVE	;+3 3
   1652  2494
   1653  2494
   1654  2494				  -	      ifconst	legacy
   1655  2494				  -	      if	legacy < 100
   1656  2494				  -	      ldx	#4
   1657  2494				  -adjustloop2
   1658  2494				  -	      lda	player0x,x
   1659  2494				  -	      clc
   1660  2494				  -	      adc	#14	;?
   1661  2494				  -	      sta	player0x,x
   1662  2494				  -	      dex
   1663  2494				  -	      bpl	adjustloop2
   1664  2494				  -	      endif
   1665  2494					      endif
   1666  2494
   1667  2494
   1668  2494
   1669  2494
   1670  2494							;set score pointers
   1671  2494		       a7 95		      lax	score+2
   1672  2496		       20 c7 f4 	      jsr	scorepointerset
   1673  2499		       84 9b		      sty	scorepointers+5
   1674  249b		       86 98		      stx	scorepointers+2
   1675  249d		       a7 94		      lax	score+1
   1676  249f		       20 c7 f4 	      jsr	scorepointerset
   1677  24a2		       84 9a		      sty	scorepointers+4
   1678  24a4		       86 97		      stx	scorepointers+1
   1679  24a6		       a7 93		      lax	score
   1680  24a8		       20 c7 f4 	      jsr	scorepointerset
   1681  24ab		       84 99		      sty	scorepointers+3
   1682  24ad		       86 96		      stx	scorepointers
   1683  24af
   1684  24af				   vblk
   1685  24af							; run possible vblank bB code
   1686  24af				  -	      ifconst	vblank_bB_code
   1687  24af				  -	      jsr	vblank_bB_code
   1688  24af					      endif
   1689  24af				   vblk2
   1690  24af		       ad 84 02 	      LDA	INTIM
   1691  24b2		       30 fb		      bmi	vblk2
   1692  24b4		       4c 00 f0 	      jmp	kernel
   1693  24b7
   1694  24b7
   1695  24b7		       80 70 60 50*	      .byte.b	$80,$70,$60,$50,$40,$30,$20,$10,$00
   1696  24c0		       f0 e0 d0 c0*	      .byte.b	$F0,$E0,$D0,$C0,$B0,$A0,$90
   1697  24c7				   repostable
   1698  24c7
   1699  24c7				   scorepointerset
   1700  24c7		       29 0f		      and	#$0F
   1701  24c9		       0a		      asl
   1702  24ca		       0a		      asl
   1703  24cb		       0a		      asl
   1704  24cc		       69 74		      adc	#<scoretable
   1705  24ce		       a8		      tay
   1706  24cf		       8a		      txa
   1707  24d0							; and #$F0
   1708  24d0							; lsr
   1709  24d0		       4b f0		      asr	#$F0
   1710  24d2		       69 74		      adc	#<scoretable
   1711  24d4		       aa		      tax
   1712  24d5		       60		      rts
   1713  24d6							;bB.asm
   1714  24d6							; bB.asm file is split here
   1715  24d6				   .
   1716  24d6							; 
   1717  24d6
   1718  24d6				   .L02 		;  set kernel_options no_blank_lines
   1719  24d6
   1720  24d6					      if	ECHOFIRST
      2718 bytes of ROM space left in bank 2
   1721  24d6					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 2")
   1722  24d6					      endif
   1723  24d6		       00 01	   ECHOFIRST  =	1
   1724  24d6
   1725  24d6
   1726  24d6							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1727  24d6
   1728  24d6							; feel free to modify the score graphics - just keep each digit 8 high
   1729  24d6							; and keep the conditional compilation stuff intact
   1730  24d6				  -	      ifconst	ROM2k
   1731  24d6				  -	      ORG	$F7AC-8
   1732  24d6					      else
   1733  24d6					      ifconst	bankswitch
   1734  24d6					      if	bankswitch == 8
   1735  2f74					      ORG	$2F94-bscode_length
   1736  2f74					      RORG	$FF94-bscode_length
   1737  2f74					      endif
   1738  2f74				  -	      if	bankswitch == 16
   1739  2f74				  -	      ORG	$4F94-bscode_length
   1740  2f74				  -	      RORG	$FF94-bscode_length
   1741  2f74					      endif
   1742  2f74				  -	      if	bankswitch == 32
   1743  2f74				  -	      ORG	$8F94-bscode_length
   1744  2f74				  -	      RORG	$FF94-bscode_length
   1745  2f74					      endif
   1746  2f74				  -	      if	bankswitch == 64
   1747  2f74				  -	      ORG	$10F80-bscode_length
   1748  2f74				  -	      RORG	$1FF80-bscode_length
   1749  2f74					      endif
   1750  2f74				  -	      else
   1751  2f74				  -	      ORG	$FF9C
   1752  2f74					      endif
   1753  2f74					      endif
   1754  2f74
   1755  2f74							; font equates
   1756  2f74		       00 01	   .21stcentury =	1
   1757  2f74		       00 02	   alarmclock =	2
   1758  2f74		       00 03	   handwritten =	3
   1759  2f74		       00 04	   interrupted =	4
   1760  2f74		       00 05	   retroputer =	5
   1761  2f74		       00 06	   whimsey    =	6
   1762  2f74		       00 07	   tiny       =	7
   1763  2f74		       00 08	   hex	      =	8
   1764  2f74
   1765  2f74				  -	      ifconst	font
   1766  2f74				  -	      if	font == hex
   1767  2f74				  -	      ORG	. - 48
   1768  2f74				  -	      endif
   1769  2f74					      endif
   1770  2f74
   1771  2f74				   scoretable
   1772  2f74
   1773  2f74				  -	      ifconst	font
   1774  2f74				  -	      if	font == .21stcentury
   1775  2f74				  -	      include	"score_graphics.asm.21stcentury"
   1776  2f74				  -	      endif
   1777  2f74				  -	      if	font == alarmclock
   1778  2f74				  -	      include	"score_graphics.asm.alarmclock"
   1779  2f74				  -	      endif
   1780  2f74				  -	      if	font == handwritten
   1781  2f74				  -	      include	"score_graphics.asm.handwritten"
   1782  2f74				  -	      endif
   1783  2f74				  -	      if	font == interrupted
   1784  2f74				  -	      include	"score_graphics.asm.interrupted"
   1785  2f74				  -	      endif
   1786  2f74				  -	      if	font == retroputer
   1787  2f74				  -	      include	"score_graphics.asm.retroputer"
   1788  2f74				  -	      endif
   1789  2f74				  -	      if	font == whimsey
   1790  2f74				  -	      include	"score_graphics.asm.whimsey"
   1791  2f74				  -	      endif
   1792  2f74				  -	      if	font == tiny
   1793  2f74				  -	      include	"score_graphics.asm.tiny"
   1794  2f74				  -	      endif
   1795  2f74				  -	      if	font == hex
   1796  2f74				  -	      include	"score_graphics.asm.hex"
   1797  2f74				  -	      endif
   1798  2f74					      else		; default font
   1799  2f74
   1800  2f74		       3c		      .byte.b	%00111100
   1801  2f75		       66		      .byte.b	%01100110
   1802  2f76		       66		      .byte.b	%01100110
   1803  2f77		       66		      .byte.b	%01100110
   1804  2f78		       66		      .byte.b	%01100110
   1805  2f79		       66		      .byte.b	%01100110
   1806  2f7a		       66		      .byte.b	%01100110
   1807  2f7b		       3c		      .byte.b	%00111100
   1808  2f7c
   1809  2f7c		       7e		      .byte.b	%01111110
   1810  2f7d		       18		      .byte.b	%00011000
   1811  2f7e		       18		      .byte.b	%00011000
   1812  2f7f		       18		      .byte.b	%00011000
   1813  2f80		       18		      .byte.b	%00011000
   1814  2f81		       38		      .byte.b	%00111000
   1815  2f82		       18		      .byte.b	%00011000
   1816  2f83		       08		      .byte.b	%00001000
   1817  2f84
   1818  2f84		       7e		      .byte.b	%01111110
   1819  2f85		       60		      .byte.b	%01100000
   1820  2f86		       60		      .byte.b	%01100000
   1821  2f87		       3c		      .byte.b	%00111100
   1822  2f88		       06		      .byte.b	%00000110
   1823  2f89		       06		      .byte.b	%00000110
   1824  2f8a		       46		      .byte.b	%01000110
   1825  2f8b		       3c		      .byte.b	%00111100
   1826  2f8c
   1827  2f8c		       3c		      .byte.b	%00111100
   1828  2f8d		       46		      .byte.b	%01000110
   1829  2f8e		       06		      .byte.b	%00000110
   1830  2f8f		       06		      .byte.b	%00000110
   1831  2f90		       1c		      .byte.b	%00011100
   1832  2f91		       06		      .byte.b	%00000110
   1833  2f92		       46		      .byte.b	%01000110
   1834  2f93		       3c		      .byte.b	%00111100
   1835  2f94
   1836  2f94		       0c		      .byte.b	%00001100
   1837  2f95		       0c		      .byte.b	%00001100
   1838  2f96		       7e		      .byte.b	%01111110
   1839  2f97		       4c		      .byte.b	%01001100
   1840  2f98		       4c		      .byte.b	%01001100
   1841  2f99		       2c		      .byte.b	%00101100
   1842  2f9a		       1c		      .byte.b	%00011100
   1843  2f9b		       0c		      .byte.b	%00001100
   1844  2f9c
   1845  2f9c		       3c		      .byte.b	%00111100
   1846  2f9d		       46		      .byte.b	%01000110
   1847  2f9e		       06		      .byte.b	%00000110
   1848  2f9f		       06		      .byte.b	%00000110
   1849  2fa0		       3c		      .byte.b	%00111100
   1850  2fa1		       60		      .byte.b	%01100000
   1851  2fa2		       60		      .byte.b	%01100000
   1852  2fa3		       7e		      .byte.b	%01111110
   1853  2fa4
   1854  2fa4		       3c		      .byte.b	%00111100
   1855  2fa5		       66		      .byte.b	%01100110
   1856  2fa6		       66		      .byte.b	%01100110
   1857  2fa7		       66		      .byte.b	%01100110
   1858  2fa8		       7c		      .byte.b	%01111100
   1859  2fa9		       60		      .byte.b	%01100000
   1860  2faa		       62		      .byte.b	%01100010
   1861  2fab		       3c		      .byte.b	%00111100
   1862  2fac
   1863  2fac		       30		      .byte.b	%00110000
   1864  2fad		       30		      .byte.b	%00110000
   1865  2fae		       30		      .byte.b	%00110000
   1866  2faf		       18		      .byte.b	%00011000
   1867  2fb0		       0c		      .byte.b	%00001100
   1868  2fb1		       06		      .byte.b	%00000110
   1869  2fb2		       42		      .byte.b	%01000010
   1870  2fb3		       3e		      .byte.b	%00111110
   1871  2fb4
   1872  2fb4		       3c		      .byte.b	%00111100
   1873  2fb5		       66		      .byte.b	%01100110
   1874  2fb6		       66		      .byte.b	%01100110
   1875  2fb7		       66		      .byte.b	%01100110
   1876  2fb8		       3c		      .byte.b	%00111100
   1877  2fb9		       66		      .byte.b	%01100110
   1878  2fba		       66		      .byte.b	%01100110
   1879  2fbb		       3c		      .byte.b	%00111100
   1880  2fbc
   1881  2fbc		       3c		      .byte.b	%00111100
   1882  2fbd		       46		      .byte.b	%01000110
   1883  2fbe		       06		      .byte.b	%00000110
   1884  2fbf		       3e		      .byte.b	%00111110
   1885  2fc0		       66		      .byte.b	%01100110
   1886  2fc1		       66		      .byte.b	%01100110
   1887  2fc2		       66		      .byte.b	%01100110
   1888  2fc3		       3c		      .byte.b	%00111100
   1889  2fc4
   1890  2fc4					      ifnconst	DPC_kernel_options
   1891  2fc4
   1892  2fc4		       00		      .byte.b	%00000000
   1893  2fc5		       00		      .byte.b	%00000000
   1894  2fc6		       00		      .byte.b	%00000000
   1895  2fc7		       00		      .byte.b	%00000000
   1896  2fc8		       00		      .byte.b	%00000000
   1897  2fc9		       00		      .byte.b	%00000000
   1898  2fca		       00		      .byte.b	%00000000
   1899  2fcb		       00		      .byte.b	%00000000
   1900  2fcc
   1901  2fcc					      endif
   1902  2fcc
   1903  2fcc					      endif
   1904  2fcc
   1905  2fcc				  -	      ifconst	ROM2k
   1906  2fcc				  -	      ORG	$F7FC
   1907  2fcc					      else
   1908  2fcc					      ifconst	bankswitch
   1909  2fcc					      if	bankswitch == 8
   1910  2fd4					      ORG	$2FF4-bscode_length
   1911  2fd4					      RORG	$FFF4-bscode_length
   1912  2fd4					      endif
   1913  2fd4				  -	      if	bankswitch == 16
   1914  2fd4				  -	      ORG	$4FF4-bscode_length
   1915  2fd4				  -	      RORG	$FFF4-bscode_length
   1916  2fd4					      endif
   1917  2fd4				  -	      if	bankswitch == 32
   1918  2fd4				  -	      ORG	$8FF4-bscode_length
   1919  2fd4				  -	      RORG	$FFF4-bscode_length
   1920  2fd4					      endif
   1921  2fd4				  -	      if	bankswitch == 64
   1922  2fd4				  -	      ORG	$10FE0-bscode_length
   1923  2fd4				  -	      RORG	$1FFE0-bscode_length
   1924  2fd4					      endif
   1925  2fd4				  -	      else
   1926  2fd4				  -	      ORG	$FFFC
   1927  2fd4					      endif
   1928  2fd4					      endif
   1929  2fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1930  2fd4
   1931  2fd4							; every bank has this stuff at the same place
   1932  2fd4							; this code can switch to/from any bank at any entry point
   1933  2fd4							; and can preserve register values
   1934  2fd4							; note: lines not starting with a space are not placed in all banks
   1935  2fd4							;
   1936  2fd4							; line below tells the compiler how long this is - do not remove
   1937  2fd4							;size=32
   1938  2fd4
   1939  2fd4				   begin_bscode
   1940  2fd4		       a2 ff		      ldx	#$ff
   1941  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1942  2fd6				  -	      stx	FASTFETCH
   1943  2fd6					      endif
   1944  2fd6		       9a		      txs
   1945  2fd7				  -	      if	bankswitch == 64
   1946  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1947  2fd7					      else
   1948  2fd7		       a9 f2		      lda	#>(start-1)
   1949  2fd9					      endif
   1950  2fd9		       48		      pha
   1951  2fda		       a9 4f		      lda	#<(start-1)
   1952  2fdc		       48		      pha
   1953  2fdd
   1954  2fdd				   BS_return
   1955  2fdd		       48		      pha
   1956  2fde		       8a		      txa
   1957  2fdf		       48		      pha
   1958  2fe0		       ba		      tsx
   1959  2fe1
   1960  2fe1					      if	bankswitch != 64
   1961  2fe1		       b5 04		      lda	4,x	; get high byte of return address
   1962  2fe3
   1963  2fe3		       2a		      rol
   1964  2fe4		       2a		      rol
   1965  2fe5		       2a		      rol
   1966  2fe6		       2a		      rol
   1967  2fe7		       29 01		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1968  2fe9		       aa		      tax
   1969  2fea		       e8		      inx
   1970  2feb				  -	      else
   1971  2feb				  -	      lda	4,x	; get high byte of return address
   1972  2feb				  -	      tay
   1973  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1974  2feb				  -	      sta	4,x
   1975  2feb				  -	      tya
   1976  2feb				  -	      lsr
   1977  2feb				  -	      lsr
   1978  2feb				  -	      lsr
   1979  2feb				  -	      lsr
   1980  2feb				  -	      tax
   1981  2feb				  -	      inx
   1982  2feb					      endif
   1983  2feb
   1984  2feb				   BS_jsr
   1985  2feb		       bd f7 1f 	      lda	bankswitch_hotspot-1,x
   1986  2fee		       68		      pla
   1987  2fef		       aa		      tax
   1988  2ff0		       68		      pla
   1989  2ff1		       60		      rts
   1990  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1991  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1992  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1993  2ff2					      endif
   1994  2ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1995  2ff2
   1996  2ff2					      ifconst	bankswitch
   1997  2ff2					      if	bankswitch == 8
   1998  2ffc					      ORG	$2FFC
   1999  2ffc					      RORG	$FFFC
   2000  2ffc					      endif
   2001  2ffc				  -	      if	bankswitch == 16
   2002  2ffc				  -	      ORG	$4FFC
   2003  2ffc				  -	      RORG	$FFFC
   2004  2ffc					      endif
   2005  2ffc				  -	      if	bankswitch == 32
   2006  2ffc				  -	      ORG	$8FFC
   2007  2ffc				  -	      RORG	$FFFC
   2008  2ffc					      endif
   2009  2ffc				  -	      if	bankswitch == 64
   2010  2ffc				  -	      ORG	$10FF0
   2011  2ffc				  -	      RORG	$1FFF0
   2012  2ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   2013  2ffc				  -	      ORG	$10FF8
   2014  2ffc				  -	      RORG	$1FFF8
   2015  2ffc				  -	      ifconst	superchip
   2016  2ffc				  -	      .byte	"E","F","S","C"
   2017  2ffc				  -	      else
   2018  2ffc				  -	      .byte	"E","F","E","F"
   2019  2ffc				  -	      endif
   2020  2ffc				  -	      ORG	$10FFC
   2021  2ffc				  -	      RORG	$1FFFC
   2022  2ffc					      endif
   2023  2ffc				  -	      else
   2024  2ffc				  -	      ifconst	ROM2k
   2025  2ffc				  -	      ORG	$F7FC
   2026  2ffc				  -	      else
   2027  2ffc				  -	      ORG	$FFFC
   2028  2ffc				  -	      endif
   2029  2ffc					      endif
   2030  2ffc		       50 f2		      .word.w	(start & $ffff)
   2031  2ffe		       50 f2		      .word.w	(start & $ffff)
